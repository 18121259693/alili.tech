<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alili</title>
  
  <subtitle>前端大爆炸! - WEB BANG! BANG!! BANG!!!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://alili.tech/"/>
  <updated>2018-10-18T06:20:10.790Z</updated>
  <id>https://alili.tech/</id>
  
  <author>
    <name>Fan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>滑向未来（现代 JavaScript 与 CSS 滚动实现指南）</title>
    <link href="https://alili.tech/archive/8a174493/"/>
    <id>https://alili.tech/archive/8a174493/</id>
    <published>2018-12-13T11:33:33.000Z</published>
    <updated>2018-10-18T06:20:10.790Z</updated>
    
    <content type="html"><![CDATA[<div class="uk-card-body uk-padding-remove-top">                              <div class="uk-cover-container uk-height-medium">            <img src="https://p4.ssl.qhimg.com/t013bea140bd875db38.gif" alt="" uk-cover="" class="uk-cover" style="height: 572px; width: 724px">          </div>                    <h2 class="detail-title uk-margin-medium-top">滑向未来（现代 JavaScript 与 CSS 滚动实现指南）</h2>                    <div class="original-source uk-padding uk-padding-remove-horizontal uk-padding-remove-top">            <span>原文链接：</span>            <a class="uk-link-muted orginal-source-url" href="https://evilmartians.com/chronicles/scroll-to-the-future-modern-javascript-css-scrolling-implementations" target="_blank">evilmartians.com</a>          </div>                    <div class="markdown-body">            <p>一些（网站）滚动的效果是如此令人着迷但你却不知该如何实现，本文将为你揭开它们的神秘面纱。我们将基于最新的技术与规范为你介绍最新的 JavaScript 与 CSS 特性，（当你付诸实践时，）将使你的页面滚动更平滑、美观且性能更好。</p><p>大多数的网页的内容都无法在一屏内全部展现，因而（页面）滚动对于用户而言是必不可少的。对于前端工程师与 UX 设计师而言，跨浏览器提供良好的滚动体验，同时符合设计（要求），无疑是一个挑战。尽管 web 标准的发展速度远超从前，但代码的实现往往是落后的。下文将为你介绍一些常见的关于滚动的案例，检查一下你所用的解决方案是否被更优雅的方案所代替。</p><h2>消逝的滚动条</h2><p>在过去的三十年里，滚动条的外观不断改变以符合设计的趋势，设计师们为（滚动条的）颜色、阴影、上下箭头的形状与边框的圆角实验了多种风格。以下是 Windows 上的变化历程：</p><p><img src="https://p0.ssl.qhimg.com/t0192ca4668e75fbabf.png" alt="Design of Windows scrollbars over time">（Windows 上的滚动条）</p><p>在2011年，苹果设计师从 ios 上获得灵感，为如何定义“美观的”滚动条确定了方向。所有滚动条均从 Mac 电脑中消失，不再占据任何页面空间，只有在用户触发滚动时（滚动条）才会重新出现（有些用户会设置不隐藏滚动条）。</p><p><img src="https://p0.ssl.qhimg.com/t012d0ddfb483382882.png" alt="Design of Mac scrollbars over time">（Mac 上的滚动条）</p><p>滚动条安静地消逝并未引起苹果粉丝的不满，已经习惯了 iPhone 与 iPad 上滚动方式的用户很快地习惯了这一设计。大多数开发人员与设计师都认为这是一个“好消息”，因为计算滚动条的宽度可真是件苦差事。</p><blockquote><p>然而，我们生活在一个拥有众多操作系统与浏览器的世界中，它们（对于滚动）的实现各不相同。如果你和我们一样是一名 Web 开发者，你可不能把“滚动条问题”置之不理。</p></blockquote><p>以下将为你介绍一些小技巧，使你的用户在滚动时有更好的体验。</p><h2>隐藏但可滚动</h2><p>先来看看一个关于模态框的经典例子。当它被打开的时候，主页面应该停止滚动。在 CSS 中有如下的快捷实现方式：</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> {  <span class="hljs-attribute">overflow</span>: hidden;}</code></pre><p>但上述代码会带来一点不良的副作用：</p><p><img src="https://p0.ssl.qhimg.com/t011ad376d358ab2462.gif" alt="Jitter when a scrollbar disappears">（注意红色剪头）</p><p>在这个示例中，为了演示目的，我们在 Mac 系统中设置了强制显示滚动条，因而用户体验与 Windows 用户相似。</p><p>我们该如何解决这个问题呢？如果我们知道滚动条的宽度，每次当模态框出现时，可在主页面的右边设置一点边距。</p><p>由于不同的操作系统与浏览器对滚动条的宽度不一，因而获取它的宽度并不容易。在Mac 系统中，无论任何浏览器（滚动条）都是统一15px，然而 Windows 系统可会令开发者发狂：</p><p><img src="https://p0.ssl.qhimg.com/t011568ba7ae0bebd32.png" alt="Scrollbar sizes under different browsers">（“百花齐放”的宽度）</p><p>注意，以上仅是 Windows 系统下基于当前最新版浏览器（测试所得）的结果。以前的（浏览器）版本（宽度）可能有所不同，也没人知道未来（滚动条的宽度）会如何变化。</p><p>不同于猜测（滚动条的宽度），你可以通过 JavaScript 计算它的宽度（译者注：实测以下代码仅能测出原始的宽度，通过 CSS 改变了滚动条宽度后，以下代码也无法测出实际宽度）：</p><pre><code class="hljs dart"><span class="hljs-keyword">const</span> outer = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);<span class="hljs-keyword">const</span> inner = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);outer.style.overflow = <span class="hljs-string">'scroll'</span>;<span class="hljs-built_in">document</span>.body.appendChild(outer);outer.appendChild(inner);<span class="hljs-keyword">const</span> scrollbarWidth = outer.offsetWidth - inner.offsetWidth;<span class="hljs-built_in">document</span>.body.removeChild(outer);</code></pre><p>尽管仅仅七行代码（就能测出滚动条的宽度），但有数行代码是操作 DOM 的。（为性能起见，）如非必要，尽量避免进行 DOM 操作。</p><p>解决这个问题的另一个方法是在模态框出现时仍保留滚动条，以下是基于这思路的纯 CSS 实现：</p><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> {  <span class="hljs-attribute">overflow-y</span>: scroll;}</code></pre><p>尽管“模态框抖动”问题解决了，但整体的外观却被一个无法使用的滚动条影响了，这无疑是设计中的硬伤。</p><p>在我们看来，更好的解决方案是完全地隐藏滚动条。纯粹用 CSS 也是可以实现的。该方法（达到的效果）和 macOS 的表现并不是完全一致，（当用户）滚动时滚动条仍然是不可见的。滚动条总是处于不可见状态，然而页面是可被滚动的。对于Chrome，Safari 和 Opera 而言，可以使用以下的 CSS：</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::-webkit-scrollbar</span> {  <span class="hljs-attribute">display</span>: none;}</code></pre><p>IE 或 Edge 可用以下代码:</p><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> {  <span class="hljs-attribute">-ms-overflow-style</span>: none;}</code></pre><p>至于 Firefox，很不幸，没有任何办法隐藏滚动条。</p><p>正如你所见，并没有任何银弹。任何解决方案都有它的优点与缺点，应根据你项目的需要选择最合适的。</p><h2>外观争议</h2><p>需要承认的是，滚动条的样子在部分操作系统上并不好看。一些设计师喜欢完全掌控他们（所设计）应用的样式，任何一丝细节也不放过。在<a href="https://github.com/search?l=JavaScript&amp;q=custom+scrollbar&amp;type=Repositories" target="_blank" rel="noopener"> GitHub 上有上百个库</a>借助 JavaScript 取代系统滚动条的默认实现，以达到自定义的效果。</p><blockquote><p>但如果你想根据现有的浏览器定制一个滚动条呢？（很遗憾，）并没有通用的  API，每个浏览器都有其独特的代码实现。</p></blockquote><p>尽管5.5版本以后的 IE 浏览器允许你修改滚动条的样式，但它只允许你修改滚动条的颜色。以下是如何重新绘制（滚动条）拖动部分与箭头的代码：</p><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> {  <span class="hljs-attribute">scrollbar-face-color</span>: blue;}</code></pre><p>但只改变颜色对提高用户体验而言帮助不大。据此，WebKit 的开发者在2009年提出了（修改滚动条）样式的方案。以下是使用 <code>-webkit</code> 前缀在支持相关样式的浏览器中模拟 macOS 滚动条样式的代码：</p><pre><code class="hljs css"><span class="hljs-selector-pseudo">::-webkit-scrollbar</span> {  <span class="hljs-attribute">width</span>: <span class="hljs-number">8px</span>;}<span class="hljs-selector-pseudo">::-webkit-scrollbar-thumb</span> {  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#c1c1c1</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;}</code></pre><p>Chrome、Safari、Opera 甚至于 UC 浏览器或者三星自带的桌面浏览器都支持（上述 CSS）。Edge <a href="https://wpdev.uservoice.com/forums/257854-microsoft-edge-developer/suggestions/9081910-add-support-for-scrollbar-styling" target="_blank" rel="noopener">也有计划实现它们</a>。但三年过去了，该计划仍在中等优先级中（而尚未被实现）。</p><p>当我们讨论滚动条的定制时，Mozilla 基金会基本上是无视了设计师的需求。（有开发者在）<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=77790" target="_blank" rel="noopener">17年前</a>就已经提出了一个希望修改滚动条样式的请求。而就在几个月前，Jeff Griffiths（Firefox 浏览器总监）终于为这个问题作出了回答：</p><p><em>“除非团队中有人对此有兴趣，否则我对此毫不关心。”</em></p><p>公平地说，从 W3C 的角度看来，尽管 WebKit 的实现得到广泛的支持，但它仍然不是标准。现有的为滚动条修改样式的草案，是基于 IE 的：仅能修改它的颜色。</p><p>伴随着请求如同 WebKit 一样支持滚动条样式修改 <a href="https://github.com/w3c/csswg-drafts/issues/2009" target="_blank" rel="noopener">issue</a> 的提交，争议仍在继续。如果你想影响 CSS 工作小组，是时候参与讨论了。也许这不是优先级最高的问题，但（如同 WebKit 一样修改滚动条样式）得到标准化后，能使很多前端工程师与设计师轻松很多。</p><h2>流畅的操作体验</h2><p>对于滚动而言，最常见的任务是登录页的导航（跳转）。通常，它是通过锚点链接来完成的。只需要知道元素的 <code>id</code> 即可：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#section"</span>&gt;</span>Section<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>点击该链接会 <em>跳</em> 到（该锚点对应的）区块上，（然而） UX 设计师一般会坚持认为该过程应是平滑地运动的。<a href="https://github.com/search?l=JavaScript&amp;q=animate+scroll&amp;type=Repositories" target="_blank" rel="noopener">GitHub 上有大量造好的轮子</a>（帮你解决这个问题），然而它们或多或少都用到 JavaScript。（其实）只用一行代码也能实现同样的效果，最近DOM API 中的 <code>Element.scrollIntoView()</code> 可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView" target="_blank" rel="noopener">传入配置对象</a>来实现平滑滚动：</p><pre><code class="hljs css"><span class="hljs-selector-tag">elem</span><span class="hljs-selector-class">.scrollIntoView</span>({  <span class="hljs-attribute">behavior</span>: <span class="hljs-string">'smooth'</span>});</code></pre><p>然而该属性<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView#Browser_compatibility" target="_blank" rel="noopener">兼容性较差</a>且仍是通过脚本（来控制样式）。如有可能，应尽量少用额外的脚本。</p><p>幸运的是，有一个全新的 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior" target="_blank" rel="noopener"> CSS 属性</a>（仍在工作草案中），可以用简单的一行代码改变整个页面滚动的行为。</p><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> {  <span class="hljs-attribute">scroll-behavior</span>: smooth;}</code></pre><p>结果如下:</p><p><img src="https://p0.ssl.qhimg.com/t013bea140bd875db38.gif" alt="Jumping from one section to another"></p><p>（从一个区块跳到另一个）</p><p><img src="https://p0.ssl.qhimg.com/t017553ad00d8fac638.gif" alt="Scrolling smoothly"></p><p>（平滑地滚动）</p><p>你可以在<a href="https://codepen.io/askd/full/WdXOYW" target="_blank" rel="noopener"> codepen </a>上试验这个属性。在撰写本文时，<code>scroll-behavior</code> 仅在 Chrome、 Firefox 与 Opera 上被支持，但我们希望它能被广泛支持，因为使用 CSS （比使用 JavaScript）在解决页面滚动问题时优雅得多，并更符合“<a href="https://en.wikipedia.org/wiki/Progressive_enhancement" target="_blank" rel="noopener">渐进增强</a>”的模式。</p><h2>粘性 CSS</h2><p>另一个常见的需求是根据滚动方向动态地定住元素，即有名的“粘性（即 CSS 中的<code>position: sticky</code>）”效应。</p><p><img src="https://p0.ssl.qhimg.com/t01b63092e8592f0126.gif" alt="A sticky element">（一个粘性元素）</p><p>在以前的日子里，要实现一个“粘性”元素需要编写复杂的滚动处理函数去计算元素的大小。（然而）该函数较难处理元素在“黏住”与“不黏住”之间微小的延迟，（通常会）导致（元素）抖动的出现。通过 JavaScript 来实行（“粘性”元素）也有性能上的问题，特别是在（需要）调用 [<code>Element.getBoundingClientRect()</code>  ]时(<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)。" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)。</a></p><p>不久之前，CSS 实现了 <code>position: sticky</code> 属性。只需通过指定（某方向上的）偏移量即可实现我们想要的效果。</p><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> {  <span class="hljs-attribute">position</span>: sticky;  <span class="hljs-attribute">top</span>: <span class="hljs-number">50px</span>;}</code></pre><p>（编写上述代码后，）剩下的就交由浏览器实现即可。你可以在 <a href="https://codepen.io/askd/full/ppGQya" target="_blank" rel="noopener"> codepen </a>上试验一下。撰写本文之时，<code>position: sticky</code> 在各式浏览器（包括移动端浏览器）上支持良好，所以如果你还在使用 JavaScript 去解决这个问题的话，是时候换成纯 CSS 的实现了。</p><h2>全面使用函数节流</h2><p>从浏览器的角度看来，滚动是一个<em>事件</em>，因此在 JavaScript 中是使用一个标准化的事件监听器 <code>addEventListener</code> 去处理它：，</p><pre><code class="hljs typescript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'scroll'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {  <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-built_in">window</span>.scrollY;  <span class="hljs-comment">/* doSomething with scrollTop */</span>});</code></pre><p>用户往往高频率地滚动（页面），但如果滚动事件触发太频繁的话，会导致性能上的问题，可以通过使用<em>函数节流</em>这一技巧去优化它。</p><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'scroll'</span>, throttle(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {  <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-built_in">window</span>.scrollY;  <span class="hljs-comment">/* doSomething with scrollTop */</span>}));</code></pre><p>你需要定义一个节流函数包装原来的事件监听函数，（节流函数是）减少被包装函数的执行次数，只允许它在固定的时间间隔之内执行一次：</p><pre><code class="hljs vbscript"><span class="hljs-keyword">function</span> throttle(action, wait = <span class="hljs-number">1000</span>) {  <span class="hljs-keyword">let</span> <span class="hljs-built_in">time</span> = <span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>();  return <span class="hljs-keyword">function</span>() {    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">time</span> + wait - <span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>()) &lt; <span class="hljs-number">0</span>) {        action();        <span class="hljs-built_in">time</span> = <span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>();    }  }}</code></pre><p>为了使（节流后的）滚动更平滑，你可以通过使用 <code>window.requestAnimationFrame()</code> 来实现函数节流：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">action</span>) </span>{  <span class="hljs-keyword">let</span> isRunning = <span class="hljs-literal">false</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{    <span class="hljs-keyword">if</span> (isRunning) <span class="hljs-keyword">return</span>;    isRunning = <span class="hljs-literal">true</span>;    <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {      action();      isRunning = <span class="hljs-literal">false</span>;    });  }}</code></pre><p>当然，你可以通过现有的开源轮子来<a href="https://lodash.com/docs/4.17.5#throttle" target="_blank" rel="noopener">实现</a>，就像<a href="https://lodash.com/" target="_blank" rel="noopener"> Lodash </a>一样。你可以访问<a href="https://codepen.io/askd/full/RxEYOv" target="_blank" rel="noopener"> codepen </a>来看看上述解决方案与 Lodash 中的 <code>_.throttle</code> 之间的区别。</p><p>使用哪个（开源库）并不重要，重要的是在需要的时候，记得优化你（页面中的）滚动处理函数。</p><h2>在视窗中显示</h2><p>当你需要实现图片<em>懒加载</em>或者<em>无限滚动</em>时，需要确定元素是否出现在视窗中。这可以在事件监听器中处理，最常见的解决方案是使用 <code>lement.getBoundingClientRect()</code> ：</p><pre><code class="hljs qml"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'scroll'</span>, () =&gt; {  <span class="hljs-keyword">const</span> <span class="hljs-built_in">rect</span> = elem.getBoundingClientRect();  <span class="hljs-keyword">const</span> inViewport = <span class="hljs-built_in">rect</span>.bottom &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">rect</span>.right &gt; <span class="hljs-number">0</span> &amp;&amp;                     <span class="hljs-built_in">rect</span>.left &lt; <span class="hljs-built_in">window</span>.innerWidth &amp;&amp;                     <span class="hljs-built_in">rect</span>.top &lt; <span class="hljs-built_in">window</span>.innerHeight;});</code></pre><p>上述代码的问题在于每次调用 <code>getBoundingClientRect</code> 时都会触发<em>回流</em>，严重地影响了性能。在事件处理函数中调用（ <code>getBoundingClientRect</code> ）尤为糟糕，就算使用了函数节流（的技巧）也可能对性能没多大帮助。（回流是指浏览器为局部或整体地重绘某个元素，需要重新计算该元素在文档中的位置与形状。）</p><p>在2016年后，可以通过使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener"> Intersection Observer </a>这一 API 来解决问题。它允许你追踪目标元素与其祖先元素或视窗的交叉状态。此外，尽管只有<em>一部分</em>元素出现在视窗中，哪怕只有一像素，也可以选择触发回调函数：</p><pre><code class="hljs pony">const observer = <span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">IntersectionObserver</span>(callback, options);<span class="hljs-title">observer</span>.<span class="hljs-title">observe</span>(element);</span></code></pre><p>（点击<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="noopener">这里</a>，查看触发回流的 DOM 属性和方法。）</p><p>此 API 被广泛地支持，但仍有一些浏览器需要  <a href="https://github.com/w3c/IntersectionObserver" target="_blank" rel="noopener">polyfill</a>。尽管如此，它仍是目前最好的解决方案。</p><h2>滚动边界问题</h2><p>如果你的弹框或下拉列表是可滚动的，那你务必要了解<em>连锁滚动</em>相关的问题：当用户滚动到（弹框或下拉列表）末尾（后再继续滚动时），整个页面都会开始滚动。</p><p><img src="https://p0.ssl.qhimg.com/t01dad2dd2cea0ceffa.gif" alt="Scrolling chaining">（连锁滚动的表现）</p><p>当滚动元素到达底部时，你可以通过（改变）页面的 <code>overflow</code> 属性或在滚动元素的滚动事件处理函数中取消默认行为来解决这问题。</p><p>如果你选择使用 JavaScript （来处理），请记住要处理的不是“scroll（事件）”，而是每当用户使用鼠标滚轮或触摸板时触发的<a href="https://developer.mozilla.org/en-US/docs/Web/Events/wheel" target="_blank" rel="noopener">“wheel（事件）”</a>：</p><pre><code class="hljs maxima">function handleOverscroll(event) {  const <span class="hljs-built_in">delta</span> = -event.deltaY;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">delta</span> &lt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">elem</span>.offsetHeight - <span class="hljs-built_in">delta</span> &gt; <span class="hljs-built_in">elem</span>.scrollHeight - <span class="hljs-built_in">elem</span>.scrollTop) {    <span class="hljs-built_in">elem</span>.scrollTop = <span class="hljs-built_in">elem</span>.scrollHeight;    event.preventDefault();    <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;  }  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">delta</span> &gt; <span class="hljs-built_in">elem</span>.scrollTop) {    <span class="hljs-built_in">elem</span>.scrollTop = <span class="hljs-number">0</span>;    event.preventDefault();    <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;  }  <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;}</code></pre><p>不幸的是，这个解决方案不太可靠。同时可能对（页面）性能产生负面影响。</p><p>过度滚动对移动端的影响尤为严重。<a href="https://en.wikipedia.org/wiki/Loren_Brichter" target="_blank" rel="noopener">Loren Brichter</a> 在 iOS 的 Tweetie 应用上创造了一个“下拉刷新”的新手势，这在 UX 社区中引起了轰动：包括 Twitter 与 Facebook 在内的各大应用纷纷采用了（相同的手势）。</p><p>当这个特性出现在安卓端的 Chrome 浏览器中时，问题出现了：它会刷新整个页面而不是加载更多的内容，成为开发者在他们的应用中实现“下拉刷新”时的麻烦。</p><p>CSS 通过 <code>overscroll-behavior</code> 这个新属性解决问题。它通过控制元素滚动到尽头时的行为来解决下拉刷新与连锁滚动所带来的问题，（它的属性值中）也包含针对不同平台特殊值：安卓的 <code>glow</code> 与 苹果系统中的 <code>rubber band</code>。</p><p>现在，上面 GIF 中的问题，在 Chrome、Opera 或 Firefox 中可以通过以下一行代码来解决：</p><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> {  <span class="hljs-attribute">overscroll-behavior</span>: contain;}</code></pre><p>公平地说，IE 与 Edge 实现了（它独有的） <code>-ms-scroll-chaining</code> <a href="https://msdn.microsoft.com/en-us/library/hh772034.aspx" target="_blank" rel="noopener">属性</a>来控制连锁滚动，但它并不能处理所有的情况。幸运的是，根据<a href="https://wpdev.uservoice.com/forums/257854-microsoft-edge-developer/suggestions/32172871-implement-css-overscroll-behavior" target="_blank" rel="noopener">这消息</a>，微软的浏览器已经准备实现 <code>overscroll-behavior</code> 这一属性了。</p><h2>触屏之后</h2><p>触屏设备上的滚动（体验）是一个很大的话题，深入讨论需要另开一篇文章。然而，由于很多开发者忽略了这方面的内容，这里需要提及一下。</p><p>（滚动手势无处不在，令人沉迷，以至于想出了<a href="https://www.thetimes.co.uk/article/take-a-swipe-at-smartphone-addiction-with-fake-handset-5bz3l8gqs" target="_blank" rel="noopener">如此疯狂的主意</a>去解决“滚动上瘾”的问题。）</p><p>周围的人在智能手机屏幕上上下移动他们的手指的频率是多少呢？经常这样对吧，当你阅读本文时，你很可能就在这么做。</p><blockquote><p>当你的手指在屏幕上移动时，你期待的是：页面内容平滑且流畅地移动。 </p></blockquote><p>苹果公司<a href="https://thenextweb.com/apple/2012/08/07/the-apple-patent-steve-jobs-fought-hard-to-protect-and-his-connection-with-its-inventor/" target="_blank" rel="noopener">开创</a>了“惯性”滚动并拥有它的<a href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=7,469,381.PN.&amp;OS=PN/7,469,381&amp;RS=PN/7,469,381" target="_blank" rel="noopener">专利</a> 。它讯速地成为了用户交互的标准并且我们对此已习以为常。</p><p>但你也许已经注意到了，尽管移动端系统会为你实现页面上的惯性滚动，但当<em>页面内某个元素</em>发生滚动时，即使用户同样期待惯性滚动，但它并不会出现，这令人沮丧。</p><p>这里有一个 CSS 的解决方案，但看起来更像是个 hack：</p><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> {  <span class="hljs-attribute">-webkit-overflow-scrolling</span>: touch;}</code></pre><p>为什么这是个 hack 呢？首先，它只能在支持（webkit）前缀的浏览器上才能工作。其次，它只适用于触屏设备。最后，如果浏览器不支持的话，你就这样置之不理吗？但无论如何，这总归是一个解决方案，你可以试着使用它。</p><p>在触屏设备上，另一个需要考虑的问题是开发者如何处理 <code>touchstart</code> 与 <code>touchmove</code> 事件触发时可能存在的性能问题，它对用户滚动体验的影响非常大。<a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#the-problem" target="_blank" rel="noopener">这里</a>详细描述了整个问题。简单来说，现代的浏览器虽然知道如何使得滚动变得平滑，但为确认（滚动）事件处理函数中是否执行了 <code>Event.preventDefault()</code> 以取消默认行为，有时仍可能需要花费500毫秒来等待事件处理函数执行完毕。</p><p>即使是一个空的事件监听器，从不取消任何行为，鉴于浏览器仍会期待 <code>preventDefault</code> 的调用，也会对性能造成负面影响。</p><p>为了准确地告诉浏览器不必担心（事件处理函数中）取消了默认行为，在 <a href="https://whatwg.org/" target="_blank" rel="noopener">WHATWG</a> 的 DOM 标准中存在着一个<a href="https://dom.spec.whatwg.org/#dom-addeventlisteneroptions-passive" target="_blank" rel="noopener">不太显眼的特性</a>（能解决这问题）。（它就是）<a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md" target="_blank" rel="noopener">Passive event listeners</a>，浏览器对它的支持还是<a href="https://caniuse.com/#search=passive%20event%20listeners" target="_blank" rel="noopener">不错的</a>。事件监听函数新接受一个可选的对象作为参数，告诉浏览器当事件触发时，事件处理函数永远不会取消默认行为。（当然，添加此参数后，）在事件处理函数中调用 <code>preventDefault</code> 将不再产生效果。</p><pre><code class="hljs typescript">element.addEventListener(<span class="hljs-string">'touchstart'</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {  <span class="hljs-comment">/* doSomething */</span>}, { passive: <span class="hljs-literal">true</span> });</code></pre><p>针对不支持该参数的浏览器，这里也有一个<a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/EventListenerOptions.polyfill.js" target="_blank" rel="noopener"> polyfill </a>。<a href="https://www.youtube.com/watch?v=NPM6172J22g" target="_blank" rel="noopener">这视频</a>清晰地展示了此改进带来的影响。</p><h2>旧技术运行良好，为何还要改动？</h2><p>在现代互联网中，过渡地依赖 JavaScript 在各浏览器上实现相同的交互效果不再是合理的，“跨浏览器兼容性”已经成为过去式，更多的 CSS 属性与 DOM API 方法正逐步被各大浏览器所支持。</p><p>在我们看来，当你的项目中，有特别酷炫的滚动效果时，<a href="https://en.wikipedia.org/wiki/Progressive_enhancement" target="_blank" rel="noopener">渐进增强</a>是最好的做法。</p><blockquote><p>你应该提供（给用户）所有（你能提供的）基础用户体验，并逐步在更先进的浏览器上提供更好的体验。</p></blockquote><p>必要时使用 polyfill，它们不会产生（不必要的）依赖，一旦（某个 polyfill 所支持的属性）得到广泛地支持，你就可以轻松地将它删掉。</p><p>六个月之前，在本文尚未成文之时，之前我们描述的属性只被少量的浏览器所支持。而到了本文发表之时，这些属性已被广泛地支持。</p><p>也许到了现在，当你上下翻阅本文之时，（之前不支持某些属性的）浏览器已经支持了该属性，这使得你编程更容易，并使你的应用打包出来体积更小。</p><hr><p>感谢阅读至此！查阅浏览器的更新日志，积极参与讨论，有助于 web 标准驶向正确的方向。祝大家一帆风顺，顺利滑（滚）向未来！</p>          </div>        </div><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/scroll-to-the-future" target="_blank" rel="noopener">https://www.zcfy.cc/article/scroll-to-the-future</a><br>原文标题: 引言· 2018年前端开发工作手册</p><p>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/8a174493/">https://alili.tech/archive/8a174493/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;uk-card-body uk-padding-remove-top&quot;&gt;
          
          
          &lt;div class=&quot;uk-cover-container uk-height-medium&quot;&gt;
         
      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript引擎基础：优化原型</title>
    <link href="https://alili.tech/archive/44173d64/"/>
    <id>https://alili.tech/archive/44173d64/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-18T06:20:10.790Z</updated>
    
    <content type="html"><![CDATA[<p>本文对所有 JavaScript 引擎中常见的一些关键基础内容进行了介绍——这不仅仅局限于 V8 引擎(<a href="https://twitter.com/v8js" target="_blank" rel="noopener">https://twitter.com/v8js)</a>。作为一名 JavaScript 开发者，深入了解 JavaScript 引擎是如何工作的将有助于你了解自己所写代码的性能特征。</p><p><a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">前一篇</a>文章中，我们讨论了 JavaScript 引擎是如何通过 Shapes 和 Inline Caches 来优化访问对象与数组的。本文将介绍引擎在优化流程中的一些权衡与取舍，并对其在优化原型属性访问方面的优化加速工作进行介绍。</p><p><strong>注意：</strong> .如果你倾向看视频演讲，请移步 <a href="https://www.youtube.com/watch?v=IFWulQnM5E0" target="_blank" rel="noopener">YouTube</a> 查看更多。</p><h2>优化层级与执行效率的取舍</h2><p><a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">前一篇文章</a> 讨论了现代 JavaScript 引擎通用的工作流程：</p><p><img src="https://s2.ssl.qhres.com/static/4b3250c77560ffe9.svg" alt="To execute JavaScript, engines use an interpreter and one or more optimization tiers."></p><p>我们也指出，尽管从高级抽象层面来看，引擎之间的处理流程都很相似，但他们在优化流程上通常都存在差异。为什么呢？为什么有些引擎的优化层级会比其他引擎多一些？事实证明，在快速获取可运行的代码与花费更多时间获得最优运行性能的代码之间存在一些取舍与平衡点。</p><p><img src="https://s0.ssl.qhres.com/static/6574f46dd24b2af1.svg" alt=""></p><p>解释器可以快速生成字节码，但字节码通常效率不高。 相比之下，优化编译器虽然需要更长的时间进行处理，但最终会产生更高效的机器码。</p><p>这正是 V8 在使用的模型。它的解释器叫 Ignition，（就原始字节码执行速度而言）是所有引擎中最快的解释器。V8 的优化编译器名为 TurboFan，最终由它生成高度优化的机器码。</p><p><img src="https://s2.ssl.qhres.com/static/7fbc0b3140720fe0.svg" alt=""></p><p>我们往往需要在启动延迟与执行速度之间做出一些取舍，而这便是一些 JavaScript 引擎决定是否在流程中加入优化层的原因所在。例如，SpiderMonkey 在解释器和完整的 IonMonkey 优化编译器之间添加了一个 Baseline 层：</p><p><img src="https://s3.ssl.qhres.com/static/09c5c0245e6d11e3.svg" alt=""></p><p>解释器可以快速生成字节码，但字节码执行起来相对较慢。Baseline 生成代码需要花费更长的时间，但能提供更好的运行时性能。最后，IonMonkey 优化编译器花费最长时间来生成机器码，但该代码运行起来非常高效。</p><p>让我们通过一个具体的例子，看看不同引擎中的优化流程都有哪些差异。这是一些在循环中会经常出现的代码。</p><pre><code class="hljs nimrod"><span class="hljs-keyword">let</span> <span class="hljs-literal">result</span> = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4242424242</span>; ++i) {    <span class="hljs-literal">result</span> += i;}console.log(<span class="hljs-literal">result</span>);</code></pre><p>V8开始在 Ignition 解释器中运行字节码。从某些方面来看，代码是否足够 hot 由引擎决定，引擎还负责调度 TurboFan 前端，它是 TurboFan 中负责处理集成分析数据和构建代码在机器层面表示的一部分。这部分结果之后会被发送到另一个线程上的 TurboFan 优化器被进一步优化。</p><p><img src="https://s1.ssl.qhres.com/static/dffba67a00a752da.svg" alt=""></p><p>当优化器运行时，V8 会继续在 Ignition 中执行字节码。 当优化器处理完成后，我们获得可执行的机器码，执行流程便会继续下去</p><p>SpiderMonkey 引擎也开始在解释器中运行字节码。但它有一个额外的 Baseline 层，这意味着比较 hot 的代码会首先被发送到 Baseline。 Baseline 编译器在主线程上生成 Baseline 代码，并在完成后继续后面的执行。</p><p><img src="https://s4.ssl.qhres.com/static/6c6f54513e64a658.svg" alt=""></p><p>如果 Baseline 代码运行了一段时间，SpiderMonkey 最终会激活 IonMonkey 前端，并启动优化器 - 这与 V8 非常相似。当 IonMonkey 进行优化时，代码在 Baseline 中会一直运行。当优化器处理完成后，被执行的是优化后的代码而不是 Baseline 代码。</p><p>Chakra 的架构与 SpiderMonkey 非常相似，但 Chakra 尝试通过并行处理更多内容来避免阻塞主线程。Chakra 不在主线程上运行编译器，而是将不同编译器可能需要的字节码和分析数据复制出来，将其发送到一个专用的编译器进程。</p><p><img src="https://s2.ssl.qhres.com/static/35f20da7a2fcc4fd.svg" alt=""></p><p>当代码准备就绪，引擎便开始运行 SimpleJIT 代码而不是字节码。 对于 FullJIT 来说流程同样如此。这种方法的好处是，与运行完整的编译器（前端）相比，复制所产生的中断时间通常要短得多。但其缺点在于这种启发式复制可能会遗漏某些优化所需的某些信息，因此它在一定程度上是用代码质量来换时间的消耗。</p><p>在 JavaScriptCore 中，所有优化编译器都与主 JavaScript 执行完全并发运行；根本没有复制阶段！相反，主线程仅仅是触发了另一个线程上的编译作业。然后，编译器使用复杂的加锁方式从主线程中获取到要访问的分析数据。</p><p><img src="https://s4.ssl.qhres.com/static/3b24c6d64b3199eb.svg" alt=""></p><p>这种方法的优点在于它减少了主线程上由 JavaScript 优化引起的抖动。 缺点是它需要处理复杂的多线程问题并为各种操作付出一些加锁的成本。</p><p>我们已经讨论过在使用解释器快速生成代码或使用优化编译器生成可高效执行代码之间的一些权衡。但还有另一个权衡：内存使用！为了说明这一点，来看一个简单的两数相加 JvaScript 函数。</p><pre><code class="hljs dockerfile">function <span class="hljs-keyword">add</span><span class="bash">(x, y) {</span>    return x + y;}<span class="hljs-keyword">add</span><span class="bash">(1, 2);</span></code></pre><p>这是我们使用 V8 中的 Ignition 解释器为 add 函数生成的字节码：</p><pre><code class="hljs dockerfile">StackCheckLdar a1<span class="hljs-keyword">Add</span><span class="bash"> a0, [0]</span>Return</code></pre><p>不要在意这些字节码 ——你不需要了解细节。关键在于它只是四条指令！</p><p>当代码变得 hot，TurboFan 便会开始处理以生成如下高度优化的机器码：</p><pre><code class="hljs x86asm">leaq <span class="hljs-built_in">rcx</span>,[<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x0</span>]<span class="hljs-keyword">movq</span> <span class="hljs-built_in">rcx</span>,[<span class="hljs-built_in">rcx</span>-<span class="hljs-number">0x37</span>]testb [<span class="hljs-built_in">rcx</span>+<span class="hljs-number">0xf</span>],<span class="hljs-number">0x1</span><span class="hljs-keyword">jnz</span> CompileLazyDeoptimizedCode<span class="hljs-keyword">push</span> <span class="hljs-built_in">rbp</span><span class="hljs-keyword">movq</span> <span class="hljs-built_in">rbp</span>,<span class="hljs-built_in">rsp</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">rsi</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">rdi</span>cmpq <span class="hljs-built_in">rsp</span>,[<span class="hljs-built_in">r13</span>+<span class="hljs-number">0xe88</span>]<span class="hljs-keyword">jna</span> StackOverflow<span class="hljs-keyword">movq</span> <span class="hljs-built_in">rax</span>,[<span class="hljs-built_in">rbp</span>+<span class="hljs-number">0x18</span>]<span class="hljs-keyword">test</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x1</span><span class="hljs-keyword">jnz</span> Deoptimize<span class="hljs-keyword">movq</span> <span class="hljs-built_in">rbx</span>,[<span class="hljs-built_in">rbp</span>+<span class="hljs-number">0x10</span>]testb <span class="hljs-built_in">rbx</span>,<span class="hljs-number">0x1</span><span class="hljs-keyword">jnz</span> Deoptimize<span class="hljs-keyword">movq</span> <span class="hljs-built_in">rdx</span>,<span class="hljs-built_in">rbx</span>shrq <span class="hljs-built_in">rdx</span>, <span class="hljs-number">32</span><span class="hljs-keyword">movq</span> <span class="hljs-built_in">rcx</span>,<span class="hljs-built_in">rax</span>shrq <span class="hljs-built_in">rcx</span>, <span class="hljs-number">32</span>addl <span class="hljs-built_in">rdx</span>,<span class="hljs-built_in">rcx</span><span class="hljs-keyword">jo</span> Deoptimizeshlq <span class="hljs-built_in">rdx</span>, <span class="hljs-number">32</span><span class="hljs-keyword">movq</span> <span class="hljs-built_in">rax</span>,<span class="hljs-built_in">rdx</span><span class="hljs-keyword">movq</span> <span class="hljs-built_in">rsp</span>,<span class="hljs-built_in">rbp</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">rbp</span><span class="hljs-keyword">ret</span> <span class="hljs-number">0x18</span></code></pre><p>这么一大堆代码，这比四行要远远超出更多！通常来说，字节码比机器码更紧凑，特别是对比优化过的机器码。但另一方面，字节码需要解释器才能执行，而优化过机器码可以由处理器直接执行。</p><p>这就是为什么 JavaScript 引擎不简单粗暴”优化一切”的主要原因之一。正如我们之前所见，生成优化的机器码也需要很长时间，而最重要的是，我们刚刚了解到优化的机器码也需要更多的内存。</p><p><img src="https://s4.ssl.qhres.com/static/7745735fec980b69.svg" alt=""></p><p><strong>总结:</strong> JavaScript 引擎之所以具有不同优化层，就在于使用解释器快速生成代码或使用优化编译器生成高效代码之间存在一个基本权衡。通过添加更多优化层可以让你做出更细粒度的决策，但是以额外的复杂性和开销为代价。此外，在优化级别和生成代码所占用的内存之间也存在折衷。这就是为什么 JavaScript 引擎仅尝试优化比较 hot 功能的原因所在。</p><h2>原型属性访问优化</h2><p><a href="https://mathiasbynens.be/notes/shapes-ics#optimizing-property-access" target="_blank" rel="noopener">上一篇文章</a> 解释了 JavaScript 引擎如何使用 Shapes 和 Inline Caches 优化对象属性加载。回顾一下，引擎将对象的 Shape 与对象值分开存储。</p><p><img src="https://s0.ssl.qhres.com/static/3087c8fd4323793d.svg" alt=""></p><p>Shapes 可以实现称为 Inline Caches 或简称 ICs 的优化。通过组合，Shapes 和 ICs 可以加快代码中相同位置的重复属性访问速度。</p><p><img src="https://s1.ssl.qhres.com/static/dfed740115e04ffc.svg" alt=""></p><h3>Class和基于原型的编程</h3><p>既然我们知道如何在 JavaScript 对象上快速进行属性访问，那么让我们看一下最近添加到 JavaScript 中的特性：class（类）。JavaScript 中的类语法如下所示：</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>{    <span class="hljs-keyword">constructor</span>(x) {        <span class="hljs-keyword">this</span>.x = x;    }    getX() {        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x;    }}</code></pre><p>尽管它看上去是 JavaScript 中的一个全新概念，但它仅仅是基于原型编程的语法糖：</p><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bar</span><span class="hljs-params">(x)</span> </span>{    <span class="hljs-keyword">this</span>.x = x;}Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> </span>{    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x;};</code></pre><p>在这里，我们在 Bar.prototype 对象上分配一个 getX 属性。这与其他任何对象的工作方式完全相同，因为<strong>原型只是 JavaScript 中的对象</strong>！在基于原型的编程语言（如 JavaScript）中，方法通过原型共享，而字段则存储在实际的实例上。</p><p>让我们来实际看看，当我们创建一个名为 foo 的 Bar 新实例时，幕后所发生的事情。</p><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Bar(<span class="hljs-literal">true</span>);</code></pre><p>通过运行此代码创建的实例具有一个带有属性 “x” 的 shape。foo 的原型是属于 class Bar 的 Bar.prototype。</p><p><img src="https://s4.ssl.qhres.com/static/0cf96e0c1703e975.svg" alt=""></p><p>Bar.prototype 有自己的 shape，其中包含一个属性 'getX'，取值则是函数 getX，它在调用时只返回 this.x。Bar.prototype 的原型是 Object.prototype，它是 JavaScript 语言的一部分。由于 Object.prototype 是原型树的根节点，因此它的原型是 null。</p><p><img src="https://s0.ssl.qhres.com/static/ecb0485cf520b78b.svg" alt=""></p><p>如果你在这个类上创建另一个实例，那么两个实例将共享对象 shape。两个实例都指向相同的 Bar.prototype 对象。</p><h3>原型属性访问</h3><p>好的，现在我们知道当我们定义一个类并创建一个新实例时会发生什么。但是如果我们在一个实例上调用一个方法会发生什么，比如我们在这里做了什么？</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>{    <span class="hljs-keyword">constructor</span>(x) { <span class="hljs-keyword">this</span>.x = x; }    getX() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x; }}<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Bar(<span class="hljs-literal">true</span>);<span class="hljs-keyword">const</span> x = foo.getX();<span class="hljs-comment">//        ^^^^^^^^^^</span></code></pre><p>你可以将任何方法视为两个单独的步骤：</p><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> x = foo.getX()<span class="hljs-comment">;</span>// is actually two steps:<span class="hljs-keyword">const</span> $getX = foo.getX<span class="hljs-comment">;</span><span class="hljs-keyword">const</span> x = $getX.<span class="hljs-built_in">call</span>(foo)<span class="hljs-comment">;</span></code></pre><p>第1步：是加载这个方法，它只是原型上的一个属性（其值恰好是一个函数）。第2步：是使用实例作为 this 值来调用该函数。让我们来看看第一步，即从实例 foo 中加载方法 getX。</p><p><img src="https://s2.ssl.qhres.com/static/a0281d20f0a52903.svg" alt=""></p><p>引擎从 foo 实例开始，并且意识到 foo 的 shape 上没有 'getX' 属性，所以它必须向原型链追溯。我们到了 Bar.prototype，查看它的原型 shape，发现它在偏移0处有 'getX' 属性。我们在 Bar.prototype 的这个偏移处查找该值，并找到我们想要的JSFunction getX。就是以上这样！</p><p>JavaScript的灵活性使我们可以改变原型的链接，举个例子：</p><pre><code class="hljs dart"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Bar(<span class="hljs-keyword">true</span>);foo.getX();<span class="hljs-comment">// → true</span><span class="hljs-built_in">Object</span>.setPrototypeOf(foo, <span class="hljs-keyword">null</span>);foo.getX();<span class="hljs-comment">// → Uncaught TypeError: foo.getX is not a function</span></code></pre><p>在这个例子中，我们调用了foo,getX()函数两次，但是每次都有不同的含义和结果。这就是为什么尽管原型只是 JavaScript 中的对象，但优化原型属性访问对于 JavaScript 引擎而言比优化常规对象的属性访问更具挑战性的原因了。</p><p>粗略的来看，加载原型属性是一个非常频繁的操作：每次调用一个方法时都会发生这种情况！</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>{    <span class="hljs-keyword">constructor</span>(x) { <span class="hljs-keyword">this</span>.x = x; }    getX() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x; }}<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Bar(<span class="hljs-literal">true</span>);<span class="hljs-keyword">const</span> x = foo.getX();<span class="hljs-comment">//        ^^^^^^^^^^</span></code></pre><p>之前，我们讨论了引擎如何通过使用 Shapes 和 Inline Caches 来优化访问常规属性的。 我们如何在具有相似 shape 的对象上优化原型属性的重复访问呢？ 我们在上面已经看过是如何访问属性的。</p><p><img src="https://s0.ssl.qhres.com/static/29646a52a2460f43.svg" alt=""></p><p>为了在这种特殊情况下实现快速重复访问，我们需要知道这三件事：</p><ol><li><p>foo的 shape 不包含 'getX' 并且没有改变过。这意味着没有人通过添加或删除属性或通过更改其中一个属性来更改对象 foo。</p></li><li><p>foo 的原型仍然是最初的 Bar.prototype。这意味着没有人通过使用Object.setPrototypeOf() 或通过赋予特殊的 <em>proto</em> 属性来更改 foo 的原型。</p></li><li><p>Bar.prototype 的形状包含 'getX' 并且没有改变。这意味着没有人通过添加或删除属性或更改其中一个属性来更改 Bar.prototype。</p></li></ol><p>一般情况下，这意味着我们必须对实例本身执行1次检查，并对每个原型进行2次检查，直到找到我们正在寻找的属性所在原型。(1 + 2N )次检查（其中 N 是所涉及的原型的数量）对于这种情况听起来可能不太糟糕，因为这里原型链相对较浅 - 但是引擎通常必须处理更长的原型链，就像常见的 DOM 类一样。下面是一个例子：</p><pre><code class="hljs pf">const <span class="hljs-built_in">anchor</span> = document.createElement('a');// → HTMLAnchorElementconst title = <span class="hljs-built_in">anchor</span>.getAttribute('title');</code></pre><p>我们有一个 HTMLAnchorElement，在其上调用 getAttribute() 方法。这个简单的锚元素原型链就已经涉及6个原型！大多数有趣的 DOM 方法并不是直接存在于 HTMLAnchorElement 原型中，而是在原型链的更高层。</p><p><img src="https://s3.ssl.qhres.com/static/fd0b3aa99f88edf1.svg" alt=""></p><p>我们可以在 Element的原型链上找到 getAttribute() 方法。这意味着我们每次调用 anchor.getAttribute() 时，JavaScript引擎都需要……</p><ol><li><p>检测到 'getAttribute' 不在锚对象本身上，</p></li><li><p>检测到直属的原型链是HTMLAnchorElement.prototype,</p></li><li><p>断言原型上缺少'getAttribute' ,</p></li><li><p>检查它的下一个原型是 HTMLElement.prototype,</p></li><li><p>断言也不存在与 'getAttribute' 这个原型上,</p></li><li><p>最终检测出下一个原型是 Element.prototype，</p></li><li><p>最后找到 'getAttribute'。</p></li></ol><p>总共有7次检测！由于这是 Web 上一种非常常见的代码，因此引擎会应用技巧来减少原型上属性加载所需的检查次数。</p><p>回到最初的例子，我们在foo上访问getX总共进行了三次检查：</p><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>{    <span class="hljs-keyword">constructor</span>(x) { <span class="hljs-keyword">this</span>.x = x; }    getX() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x; }}<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Bar(<span class="hljs-literal">true</span>);<span class="hljs-keyword">const</span> $getX = foo.getX;</code></pre><p>在直到我们找到携带目标属性的原型之前，我们需要对原型链上的每个对象进行 shape 的缺失检查。如果我们可以通过将原型检查折叠到缺失检查来减少检查次数，那就太好了。而这基本上就是引擎所做的：引擎将原型链在 Shape 上，<strong>而不是直接链在实例上</strong>。</p><p><img src="https://s2.ssl.qhres.com/static/03335cde9d0a1f67.svg" alt=""></p><p>每个 shape 都指向原型。这也意味着每次 foo 原型发生变化时，引擎都会转换到一个新 shape。 现在我们只需要检查一个对象的 shape，这样既可以断言某些属性的缺失，也可以保护原型链链接。</p><p>通过这种方法，我们可以将检查次数从 1 + 2N 降到 1 + N，以便在原型上更快地访问属性。但这仍相当昂贵，因为它在原型链的长度上仍然是线性的。 为了进一步将检查次数减少到一个常量级别，引擎采用了不同的技巧，尤其是对于相同属性访问的后续执行。</p><h3>Validity cells</h3><p>V8专门为此目的处理原型的 shape。每个原型都具有一个不与其他对象（特别是不与其他原型共享）共享且独特的 shape，且每个原型的 shape 都具有与之关联的一个特殊 ValidityCell。</p><p><img src="https://s5.ssl.qhres.com/static/677908aab86d1483.svg" alt=""></p><p>只要有人更改其相关原型或其祖先的任何原型，此 ValidityCell 就会失效。让我们来看看它是如何工作的。</p><p>为了加速原型的后续访问，V8 建立了一个 Inline Cache，其中包含四个字段：</p><p><img src="https://s3.ssl.qhres.com/static/1ea3c306acc8c7bb.svg" alt="The Inline Cache for prototype loads has four fields: ValidityCell, Prototype, Shape, and Offset."></p><p>在第一次运行此代码预热 inline cache 时，V8 会记住目标属性在原型中的偏移量，找到属性的原型（本例中为 Bar.prototype），实例的 shape（在这种情况下为 foo 的 shape），以及与实例 shape 链接的直接原型中 ValidityCell 的链接（在本例中也恰好是 Bar.prototype）。</p><p>下次 inline cache 命中时，引擎必须检查实例的 shape 和 ValidityCell。如果它仍然有效，则引擎可以直接到达 Prototype 上的 Offset 位置，跳过其他查找。</p><p><img src="https://s3.ssl.qhres.com/static/1dbbc3bb477862a9.svg" alt=""></p><p>当原型改变时，shape 将重新分配，且先前的 ValidityCell 失效。因此，Inline Cache 在下次执行时会失效，从而导致性能下降。</p><p>回到之前的 DOM 示例，这意味着对 Object.prototype 的任何更改不仅会使 Object.prototype本身的 inline cache 失效，而且还会使其下游的所有原型失效，包括EventTarget.prototype，Node.prototype，Element.prototype 等，直到 HTMLAnchorElement.prototype 为止。</p><p><img src="https://s0.ssl.qhres.com/static/b6b3dd08eff7e084.svg" alt=""></p><p>实际上，在运行代码时修改 Object.prototype 意味着完全抛弃性能上的考虑。不要这样做！</p><p>让我们用一个具体的例子来探讨这个问题。 假设我们有一个类叫做 Bar，并且我们有一个函数 loadX，它调用 Bar 对象上的方法。 我们用同一个类的实例多调用这个 loadX 函数几次。</p><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>{ <span class="hljs-comment">/* … */</span> }<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadX</span></span>(bar) {    <span class="hljs-keyword">return</span> bar.getX(); <span class="hljs-comment">// IC for 'getX' on Bar instances.</span>}loadX(<span class="hljs-keyword">new</span> <span class="hljs-type">Bar</span>(<span class="hljs-literal">true</span>));loadX(<span class="hljs-keyword">new</span> <span class="hljs-type">Bar</span>(<span class="hljs-literal">false</span>));<span class="hljs-comment">// IC in loadX now links the ValidityCell for</span><span class="hljs-comment">// Bar.prototype.</span>Object.prototype.<span class="hljs-keyword">new</span><span class="hljs-type">Method</span> = y =&gt; y;<span class="hljs-comment">// The ValidityCell in the loadX IC is invalid</span><span class="hljs-comment">// now, because Object.prototype changed.</span></code></pre><p>loadX 中的 inline cache 现在指向 Bar.prototype 的 ValidityCell。 如果你之后执行了类似于改变 Object.prototype（这是 JavaScript 中所有原型的根节点）的操作，则ValidityCell 将失效，且现有的 inline cache 会在下次命中时丢失，从而导致性能下降。</p><p>修改 Object.prototype 被认为是一个不好的操作，因为它使引擎在此之前为原型访问准备的所有 inline cache 都失效。 这是另一个不推荐的例子：</p><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/* … */</span> };<span class="hljs-comment">// Run critical code:</span>someObject.foo();<span class="hljs-comment">// End of critical code.</span><span class="hljs-keyword">delete</span> <span class="hljs-built_in">Object</span>.prototype.foo;</code></pre><p>我们扩展了 Object.prototype，它使引擎在此之前存储的所有原型 inline cache 均无效了。然后我们运行一些用到新原型方法的代码。引擎此时则需要从头开始，并为所有原型属性的访问设置新的 inline cache。最后，我们删除了之前添加的原型方法。</p><p>删除，这听起来像个好主意，对吧？然而在这种情况下，它只会让情况变得更糟！删除属性会修改 Object.prototype，因此所有 inline cache 会再次失效，而引擎又必须从头开始。</p><p><strong>总结：</strong> 虽然原型只是对象，但它们由 JavaScript 引擎专门处理，以优化在原型上查找方法的性能表现。把你的原型放在一旁！或者，如果你确实需要修改原型，请在其他代码运行之前执行此操作，这样至少不会让引擎所做的优化付诸东流。</p><h2>Take-aways</h2><p>我们已经了解了 JavaScript 引擎是如何存储对象与类的，Shapes、Inline Caches 和 ValidityCells 是如何帮助优化原型的。基于这些知识，我们认为有一个普适实用的 JavaScript 编码技巧，可以帮助提高性能：<strong>请勿随意修改原型对象</strong>（即便你真的需要，那么请在其他代码运行之前做这件事）。</p><h2>翻译</h2><ul><li><p><a href="https://hijiangtao.github.io/2018/08/21/Prototypes/" target="_blank" rel="noopener">中文参考翻译</a></p></li><li><p><a href="https://shlrur.github.io/javascripts/javascript-engine-fundamentals-optimizing-prototypes/" target="_blank" rel="noopener">韩文参考翻译</a></p></li></ul>          <h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/javascript-engine-fundamentals-optimizing-prototypes" target="_blank" rel="noopener">https://www.zcfy.cc/article/javascript-engine-fundamentals-optimizing-prototypes</a><br>原文标题: JavaScript引擎基础：优化原型</p><p>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/44173d64/">https://alili.tech/archive/44173d64/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文对所有 JavaScript 引擎中常见的一些关键基础内容进行了介绍——这不仅仅局限于 V8 引擎(&lt;a href=&quot;https://twitter.com/v8js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://twitter.com
      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript .filter() 方法全解析</title>
    <link href="https://alili.tech/archive/136637be/"/>
    <id>https://alili.tech/archive/136637be/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-18T06:20:10.790Z</updated>
    
    <content type="html"><![CDATA[<p>.filter是一个内置的数组迭代方法，它接受一个“谓词（译者注: 指代一个过滤条件的函数）”，该“谓词”针对每个值进行调用，并返回一个符合该条件(“truthy值”)的数组。</p><p>上面那句话包含了很多信息，让我们来逐一解答一下。</p><ul><li><p>“内置”只是意味着它是语言的一部分 - 您不需要添加任何库来访问此功能。</p></li><li><p>“迭代方法”是指接受针对数组的每个项运行的函数。.map和.reduce都是迭代方法的示例。</p></li><li><p>“谓词”是指.fiflter中接受的的函数。</p></li><li><p>“truthy值”是强制转换为布尔值时计算为true的任何值。几乎所有值都是真实的，除了：undefined，null，false，0，NaN或“”（空字符串）。</p></li></ul><p>让我们来看看下面这个例子，看一下.filter是怎么运行的。</p><pre><code class="hljs sqf">const restaurants = [    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"Dan's Hamburgers"</span>,        price: <span class="hljs-string">'Cheap'</span>,        cuisine: <span class="hljs-string">'Burger'</span>,    },    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"Austin's Pizza"</span>,        price: <span class="hljs-string">'Cheap'</span>,        cuisine: <span class="hljs-string">'Pizza'</span>,    },    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"Via 313"</span>,        price: <span class="hljs-string">'Moderate'</span>,        cuisine: <span class="hljs-string">'Pizza'</span>,    },    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"Bufalina"</span>,        price: <span class="hljs-string">'Expensive'</span>,        cuisine: <span class="hljs-string">'Pizza'</span>,    },    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"P. Terry's"</span>,        price: <span class="hljs-string">'Cheap'</span>,        cuisine: <span class="hljs-string">'Burger'</span>,    },    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"Hopdoddy"</span>,        price: <span class="hljs-string">'Expensive'</span>,        cuisine: <span class="hljs-string">'Burger'</span>,    },    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"Whataburger"</span>,        price: <span class="hljs-string">'Moderate'</span>,        cuisine: <span class="hljs-string">'Burger'</span>,    },    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"Chuy's"</span>,        cuisine: <span class="hljs-string">'Tex-Mex'</span>,        price: <span class="hljs-string">'Moderate'</span>,    },    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"Taquerias Arandina"</span>,        cuisine: <span class="hljs-string">'Tex-Mex'</span>,        price: <span class="hljs-string">'Cheap'</span>,    },    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"El Alma"</span>,        cuisine: <span class="hljs-string">'Tex-Mex'</span>,        price: <span class="hljs-string">'Expensive'</span>,    },    {        <span class="hljs-built_in">name</span>: <span class="hljs-string">"Maudie's"</span>,        cuisine: <span class="hljs-string">'Tex-Mex'</span>,        price: <span class="hljs-string">'Moderate'</span>,    },];</code></pre><p>这是很多信息。我现在想要一个汉堡，所以让我们过滤掉一下这个数组。</p><pre><code class="hljs ebnf"><span class="hljs-attribute">const isBurger</span> = ({cuisine}) =&gt; cuisine === <span class="hljs-string">'Burger'</span>;<span class="hljs-attribute">const burgerJoints</span> = restaurants.filter(isBurger);</code></pre><p>isBurger是谓词，而burgerJoints是<em>new</em>数组，它是餐馆的子集。<strong>值得注意的是，restaurants 这个数组是不变。</strong></p><p>下面是两个正在呈现的列表的简单示例 - 一个原始的餐馆数组，以及一个过滤的burgerJoints数组。</p><p>See the Pen <a href="https://codepen.io/AdamGiese/pen/ajLZNz/" target="_blank" rel="noopener">.filter - isBurger</a> by Adam Giese (<a href="https://codepen.io/AdamGiese" target="_blank" rel="noopener">@AdamGiese</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><h3>否定谓词</h3><blockquote><p>对于每个谓词，都有一个相反的否定谓词。</p></blockquote><p>谓词是一个返回布尔值的函数。由于布尔值只有true 和 false，这意味着很容易“翻转”谓词的值。</p><p>我吃了汉堡已经过了几个小时，现在又饿了。这一次，我想过滤<em>out</em>汉堡尝试新的东西。一种选择是从头开始编写新的isNotBurger谓词。</p><pre><code class="hljs coffeescript">const isBurger = <span class="hljs-function"><span class="hljs-params">({cuisine})</span> =&gt;</span> cuisine === <span class="hljs-string">'Burger'</span>;const isNotBurger = <span class="hljs-function"><span class="hljs-params">({cuisine})</span> =&gt;</span> cuisine !== <span class="hljs-string">'Burger'</span>;</code></pre><p>但是，请查看两个谓词之间的相似程度。这不是 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">DRY code</a>。另一种选择是调用isBurger谓词并翻转结果。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> isBurger = <span class="hljs-function">(<span class="hljs-params">{cuisine}</span>) =&gt;</span> cuisine === <span class="hljs-string">'Burger'</span>;<span class="hljs-keyword">const</span> isNotBurger = <span class="hljs-function"><span class="hljs-params">restaurant</span> =&gt;</span> !isBurger(restaurant);</code></pre><p>这个更好！如果汉堡的定义发生变化，您只需要在一个地方更改逻辑。但是，如果我们想要一些否定的谓词呢？由于这是我们可能经常想要做的事情，因此编写否定函数可能是个好主意。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> negate = <span class="hljs-function"><span class="hljs-params">predicate</span> =&gt;</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{  <span class="hljs-keyword">return</span> !predicate.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>);}<span class="hljs-keyword">const</span> isBurger = <span class="hljs-function">(<span class="hljs-params">{cuisine}</span>) =&gt;</span> cuisine === <span class="hljs-string">'Burger'</span>;<span class="hljs-keyword">const</span> isNotBurger = negate(isBurger);<span class="hljs-keyword">const</span> isPizza = <span class="hljs-function">(<span class="hljs-params">{cuisine}</span>) =&gt;</span> cuisine === <span class="hljs-string">'Pizza'</span>;<span class="hljs-keyword">const</span> isNotPizza = negate(isPizza);</code></pre><p>你可能有一些问题。</p><h4>什么是.apply？</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">MDN:</a></p><blockquote><p>apply（）方法调用具有给定this的函数，并将参数作为数组（或类数组对象）提供。</p></blockquote><h4>什么是arguments?</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">MDN:</a></p><blockquote><p>arguments对象是所有（非箭头）函数中可用的局部变量。您可以使用参数在函数内引用函数的参数object.</p></blockquote><h4>为什么要使用旧的function，而不使用更酷的箭头函数？</h4><p>在这种情况下，使用传统函数是必要的，因为arguments对象在传统函数上是_唯一_可用的。</p><p><strong>到2018年8月20日。</strong>正如一些评论家所正确指出的那样, 你可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="noopener">rest参数</a>用<a href="https://css-tricks.com/level-up-your-filter-game/#comment-1651631" target="_blank" rel="noopener">箭头函数写\ negate \</a>。</p><h3>返回谓词</h3><p>正如我们在使用negate函数看到的那样，函数很容易在JavaScript中返回一个新函数。这对于编写“谓词”非常有用。例如，让我们回顾一下我们的isBurger和isPizza谓词。</p><pre><code class="hljs coffeescript">const isBurger = <span class="hljs-function"><span class="hljs-params">({cuisine})</span> =&gt;</span> cuisine === <span class="hljs-string">'Burger'</span>;const isPizza  = <span class="hljs-function"><span class="hljs-params">({cuisine})</span> =&gt;</span> cuisine === <span class="hljs-string">'Pizza'</span>;</code></pre><p>这两个谓词具有相同的逻辑;他们只是在比较上有所不同。因此，我们可以将共享逻辑包装在isCuisine函数中。</p><pre><code class="hljs ebnf"><span class="hljs-attribute">const isCuisine</span> = comparison =&gt; ({cuisine}) =&gt; cuisine === comparison;<span class="hljs-attribute">const isBurger</span>  = isCuisine(<span class="hljs-string">'Burger'</span>);<span class="hljs-attribute">const isPizza</span>   = isCuisine(<span class="hljs-string">'Pizza'</span>);</code></pre><p>现在，如果我们想开始检查价格怎么办？</p><pre><code class="hljs ebnf"><span class="hljs-attribute">const isPrice</span> = comparison =&gt; ({price}) =&gt; price === comparison;<span class="hljs-attribute">const isCheap</span> = isPrice(<span class="hljs-string">'Cheap'</span>);<span class="hljs-attribute">const isExpensive</span> = isPrice(<span class="hljs-string">'Expensive'</span>);</code></pre><p>现在isCheap和isExpensive 都是DRY（译者注：Don't repeat yourself ，一种编程原则，不也要写重复的代码），isPizza和isBurger都是DRY，但isPrice和isCuisine可以公用他们的逻辑！</p><pre><code class="hljs cs"><span class="hljs-keyword">const</span> isKeyEqualToValue = key =&gt; <span class="hljs-keyword">value</span> =&gt; <span class="hljs-keyword">object</span> =&gt; <span class="hljs-keyword">object</span>[key] === <span class="hljs-keyword">value</span>;<span class="hljs-comment">// these can be rewritten</span><span class="hljs-keyword">const</span> isCuisine = isKeyEqualToValue(<span class="hljs-string">'cuisine'</span>);<span class="hljs-keyword">const</span> isPrice = isKeyEqualToValue(<span class="hljs-string">'price'</span>);<span class="hljs-comment">// these don't need to change</span><span class="hljs-keyword">const</span> isBurger = isCuisine(<span class="hljs-string">'Burger'</span>);<span class="hljs-keyword">const</span> isPizza = isCuisine(<span class="hljs-string">'Pizza'</span>);<span class="hljs-keyword">const</span> isCheap = isPrice(<span class="hljs-string">'Cheap'</span>);<span class="hljs-keyword">const</span> isExpensive = isPrice(<span class="hljs-string">'Expensive'</span>);</code></pre><p>对我来说，这就是箭头功能之美。在一行中，您可以优雅地创建三阶函数。</p><p>看看从原始餐馆阵列创建多个筛选列表是多么容易？</p><p>See the Pen <a href="https://codepen.io/AdamGiese/pen/mjqvdo/" target="_blank" rel="noopener">.filter - returning predicates</a> by Adam Giese (<a href="https://codepen.io/AdamGiese" target="_blank" rel="noopener">@AdamGiese</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><h3>撰写谓词</h3><p>我们现在可以通过汉堡或廉价的价格过滤我们的阵列......但是如果你想要<em>cheap burgers</em>怎么办？一种选择是将两个过滤器链接在一起。</p><pre><code class="hljs processing"><span class="hljs-keyword">const</span> cheapBurgers = restaurants.<span class="hljs-built_in">filter</span>(isCheap).<span class="hljs-built_in">filter</span>(isBurger);</code></pre><p>另一个选择是将两个谓词“组合”成一个谓词。</p><pre><code class="hljs lisp">const isCheapBurger = restaurant =&gt; isCheap(<span class="hljs-name">restaurant</span>) &amp;&amp; isBurger(<span class="hljs-name">restaurant</span>)<span class="hljs-comment">;</span>const isCheapPizza = restaurant =&gt; isCheap(<span class="hljs-name">restaurant</span>) &amp;&amp; isPizza(<span class="hljs-name">restaurant</span>)<span class="hljs-comment">;</span></code></pre><p>看看所有重复的代码。我们绝对可以将它包装成一个新功能！</p><pre><code class="hljs ebnf"><span class="hljs-attribute">const both</span> = (predicate1, predicate2) =&gt; value =&gt;  predicate1(value) &amp;&amp; predicate2(value);<span class="hljs-attribute">const isCheapBurger</span> = both(isCheap, isBurger);<span class="hljs-attribute">const isCheapPizza</span> = both(isCheap, isPizza);<span class="hljs-attribute">const cheapBurgers</span> = restaurants.filter(isCheapBurger);<span class="hljs-attribute">const cheapPizza</span> = restaurants.filter(isCheapPizza);</code></pre><p>如果你没有披萨或汉堡包怎么办？</p><pre><code class="hljs cs"><span class="hljs-keyword">const</span> either = (predicate1, predicate2) =&gt; <span class="hljs-keyword">value</span> =&gt;  predicate1(<span class="hljs-keyword">value</span>) || predicate2(<span class="hljs-keyword">value</span>);<span class="hljs-keyword">const</span> isDelicious = either(isBurger, isPizza);<span class="hljs-keyword">const</span> deliciousFood = restaurants.filter(isDelicious);</code></pre><p>这是朝着正确方向迈出的一步，但是如果您想要包含两种以上的食物呢？这不是一种可扩展的方法。有两种内置的数组方法在这里派上用场。.every和.some都是谓词方法，也接受谓词。.every检查数组的每个成员是否传递谓词，而.some检查数组的<em>any</em>成员是否通过谓词。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> isDelicious = <span class="hljs-function"><span class="hljs-params">restaurant</span> =&gt;</span>  [isPizza, isBurger, isBbq].some(<span class="hljs-function"><span class="hljs-params">predicate</span> =&gt;</span> predicate(restaurant));<span class="hljs-keyword">const</span> isCheapAndDelicious = <span class="hljs-function"><span class="hljs-params">restaurant</span> =&gt;</span>  [isDelicious, isCheap].every(<span class="hljs-function"><span class="hljs-params">predicate</span> =&gt;</span> predicate(restaurant));</code></pre><p>并且，像往常一样，让我们​​将它们包装成一些有用的抽象。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> isEvery = <span class="hljs-function"><span class="hljs-params">predicates</span> =&gt;</span> value =&gt;  predicates.every(<span class="hljs-function"><span class="hljs-params">predicate</span> =&gt;</span> predicate(value));<span class="hljs-keyword">const</span> isAny = <span class="hljs-function"><span class="hljs-params">predicates</span> =&gt;</span> value =&gt;  predicates.some(<span class="hljs-function"><span class="hljs-params">predicate</span> =&gt;</span> predicate(value));<span class="hljs-keyword">const</span> isDelicious = isAny([isBurger, isPizza, isBbq]);<span class="hljs-keyword">const</span> isCheapAndDelicious = isEvery([isCheap, isDelicious]);</code></pre><p>isEvery和isAny都接受一个谓词数组并返回一个谓词。</p><p>由于所有这些谓词都可以通过高阶函数轻松创建，因此根据用户的交互创建和应用这些谓词并不困难。综合我们学到的所有课程，这里是一个应用程序示例，通过应用基于按钮点击的过滤器来搜索餐馆。</p><p>See the Pen <a href="https://codepen.io/AdamGiese/pen/xJPMrJ/" target="_blank" rel="noopener">.filter - dynamic filters</a> by Adam Giese (<a href="https://codepen.io/AdamGiese" target="_blank" rel="noopener">@AdamGiese</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><h3>总结</h3><p>过滤器是JavaScript开发的重要组成部分。无论您是从API响应中挑选出错误数据还是响应用户交互，您都会无数次想要数组值的子集。我希望这个概述有助于您可以操作谓词来编写更易读和可维护的代码。</p>          <h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/level-up-your-filter-game" target="_blank" rel="noopener">https://www.zcfy.cc/article/level-up-your-filter-game</a><br>原文标题: JavaScript .filter() 方法全解析<br>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/136637be/">https://alili.tech/archive/136637be/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;.filter是一个内置的数组迭代方法，它接受一个“谓词（译者注: 指代一个过滤条件的函数）”，该“谓词”针对每个值进行调用，并返回一个符合该条件(“truthy值”)的数组。&lt;/p&gt;
&lt;p&gt;上面那句话包含了很多信息，让我们来逐一解答一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>离屏Canvas — 使用Web Worker提高你的Canvas运行速度</title>
    <link href="https://alili.tech/archive/e116eb40/"/>
    <id>https://alili.tech/archive/e116eb40/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-18T06:20:10.790Z</updated>
    
    <content type="html"><![CDATA[<p>现在因为有了离屏Canvas，你可以不用在你的主线程中绘制图像了！</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas" target="_blank" rel="noopener">Canvas</a> 是一个非常受欢迎的表现方式，同时也是WebGL的入口。它能绘制图形，图片，展示动画，甚至是处理视频内容。它经常被用来在富媒体web应用中创建炫酷的用户界面或者是制作在线（web）游戏。</p><p>它是非常灵活的，这意味着绘制在Canvas的内容可以被编程。举个🌰，JavaScript就提供了Canvas的系列API。这些给了Canvas非常好的灵活度。</p><p>但同时，在一些现代化的web站点，脚本解析运行是实现流畅用户反馈的最大的问题之一。因为Canvas计算和渲染和用户操作响应都发生在同一个线程中，在动画中（有时候很耗时）的计算操作将会导致App卡顿，降低用户体验。</p><p>幸运的是, <a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas" target="_blank" rel="noopener">OffscreenCanvas</a> 离屏Canvas可以非常棒的解决这个麻烦！</p><p>到目前为止，Canvas的绘制功能都与<code>&lt;canvas&gt;</code>标签绑定在一起，这意味着Canvas API和DOM是耦合的。而OffscreenCanvas，正如它的名字一样，通过将Canvas移出屏幕来解耦了DOM和Canvas API。</p><p>由于这种解耦，OffscreenCanvas的渲染与DOM完全分离了开来，并且比普通Canvas速度提升了一些，而这只是因为两者（Canvas和DOM）之间没有同步。但更重要的是，将两者分离后，Canvas将可以在Web Worker中使用，即使在Web Worker中没有DOM。这给Canvas提供了更多的可能性。</p><h2>在Worker中使用OffscreenCanvas</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">Workers</a> 是一个Web版的线程——它允许你在幕后运行你的代码。将你的一部分代码放到Worker中可以给你的主线程更多的空闲时间，这可以提高你的用户体验度。就像其没有DOM一样，直到现在，在Worker中都没有Canvas API。</p><p>而OffscreenCanvas并不依赖DOM，所以在Worker中Canvas API可以被某种方法来代替。下面是我在Worker中用OffscreenCanvas来计算渐变颜色的🌰：</p><pre><code class="hljs lsl"><span class="hljs-comment">// file: worker.js</span>function getGradientColor(percent) {    const canvas = new OffscreenCanvas(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>);    const ctx = canvas.getContext('<span class="hljs-number">2</span>d');    const gradient = ctx.createLinearGradient(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.width, <span class="hljs-number">0</span>);    gradient.addColorStop(<span class="hljs-number">0</span>, 'red');    gradient.addColorStop(<span class="hljs-number">1</span>, 'blue');    ctx.fillStyle = gradient;    ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ctx.canvas.width, <span class="hljs-number">1</span>);    const imgd = ctx.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ctx.canvas.width, <span class="hljs-number">1</span>);    const colors = imgd.data.slice(percent * <span class="hljs-number">4</span>, percent * <span class="hljs-number">4</span> + <span class="hljs-number">4</span>);    return rgba(${colors[<span class="hljs-number">0</span>]}, ${colors[<span class="hljs-number">1</span>]}, ${colors[<span class="hljs-number">2</span>]}, ${colors[]);}getGradientColor(<span class="hljs-number">40</span>);  <span class="hljs-comment">// rgba(152, 0, 104, 255 )</span></code></pre><h2>不要阻塞主线程</h2><p>当我们将大量的计算移到Worker中运行时，可以释放主线程上的资源，这很有意思。我们可以使用transferControlToOffscreen 方法将常规的Canvas映射到OffscreenCanvas实例上。之后所有应用于OffscreenCanvas的操作将自动呈现在在源Canvas上。</p><pre><code class="hljs dart"><span class="hljs-keyword">const</span> offscreen = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">'canvas'</span>).transferControlToOffscreen();<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">'myworkerurl.js'</span>);worker.postMessage({ canvas: offscreen }, [offscreen]);</code></pre><p>OffscreenCanvas 是 [可转移的](<a href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Transferable)</a>)。除了将其指定为传递信息中的字段之一以外，还需要将其作为postMessage（传递信息给Worker的方法）中的第二个参数传递出去，以便可以在Worker线程的context（上下文）中使用它。</p><p>在下面的🌰中，当颜色主题发生变化时会发生“复杂的计算”，这个计算即使在高性能的台式机上也要花费几毫秒。而你可以选择在主线程或Worker上运行这段动画。在主线程下，当复杂计算开始运行时，你将无法与按钮交互 - 线程被阻塞掉了。而在Worker下，UI的响应并没有被影响。</p><p><a href="https://devnook.github.io/OffscreenCanvasDemo/keep-ui-responsive.html" target="_blank" rel="noopener">Demo</a></p><p>它也是另一种解释方式：任务繁忙的主线程也不会影响在Worker上运行的动画。所以即使主线程非常繁忙，你也可以通过此功能来避免掉帧并保证流畅的动画：</p><p><a href="https://devnook.github.io/OffscreenCanvasDemo/index.html" target="_blank" rel="noopener">Demo</a></p><p>上例展示了在普通Canvas的下，当主线程被添加繁忙任务时动画被阻塞了，而基于Worker的OffscreenCanvas播放却很流利。</p><h2>与流行库一起使用</h2><p>得益于OffscreenCanvas API一般情况下与常规Canvas元素的相API兼容，你可以很轻松地渐进地使用它，也可以使用社区里的一些优秀的图形处理的库/框架。</p><p>举个🌰，你可以对其进行特征检测，如果可用的话，可通过在渲染的构造函数中指定canvas的配置项，然后实现与Three.js一起使用的功能：</p><pre><code class="hljs dart"><span class="hljs-keyword">const</span> canvasEl = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">"canvas"</span>);<span class="hljs-keyword">const</span> canvas = (<span class="hljs-string">'OffscreenCanvas'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>) ? canvasEl.transferControlToOffscreen() : canvasEl;canvas.style = { width: <span class="hljs-number">0</span>, height: <span class="hljs-number">0</span> }<span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> THREE.WebGLRenderer({ canvas: canvas });</code></pre><p>上例的问题是Three.js需要Canvas具有style.width和style.height属性。而OffscreenCanvas是与DOM完全分离的，没有这些属性。所以你需要自己提供这些属性，或者通过将其从three.js逻辑中删除或者自行编写这些值与初始Canvas尺寸相关联的逻辑。</p><p>下面是一个运行基本Three.js动画的demo：</p><p><a href="https://devnook.github.io/OffscreenCanvasDemo/use-with-lib.html" target="_blank" rel="noopener">Demo</a></p><p>但是请记住，有一些与DOM相关的API在Worker中并不容易获得，因此如果你想使用更高级的Three.js功能（比如纹理）的话，可能需要更多变通的方法。有关这方面已经开始尝试的一些想法，请查看 <a href="https://www.youtube.com/watch?v=wkDd-x0EkFU" target="_blank" rel="noopener">Google I/O 2017的视频</a>。</p><p>此视频的示例中出现的commit()方法我们并不推荐。请改用worker.requestAnimationFrame。</p><h2>结论</h2><p>如果你对图像绘画使用得非常多，OffscreenCanvas可以有效的提高你APP的性能。它使得Worker可以处理canvas的渲染绘制，让你的APP更好地利用了多核系统。</p><p>OffscreenCanvas在Chrome 69中已经不需要开启flag（实验性功能）就可以使用了。它也正在被 Firefox 实现。由于其API与普通canvas元素非常相似，所以你可以轻松地对其进行特征检测并循序渐进地使用它，而不会破坏现有的APP或库的运行逻辑。OffscreenCanvas在任何涉及到图形计算以及动画表现且与DOM关系并不密切（即依赖DOM API不多）的情况下，它都具有性能优势。</p><h2>其它资源</h2><ul><li><p><a href="https://html.spec.whatwg.org/#the-offscreencanvas-interface" target="_blank" rel="noopener">W3c spec</a></p></li><li><p><a href="https://www.chromestatus.com/feature/4691191559880704" target="_blank" rel="noopener">chromestatus.com entry</a></p></li></ul>          <h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/offscreencanvas-speed-up-your-canvas-operations-with-a-web-worker" target="_blank" rel="noopener">https://www.zcfy.cc/article/offscreencanvas-speed-up-your-canvas-operations-with-a-web-worker</a><br>原文标题: 离屏Canvas — 使用Web Worker提高你的Canvas运行速度<br>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/e116eb40/">https://alili.tech/archive/e116eb40/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在因为有了离屏Canvas，你可以不用在你的主线程中绘制图像了！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>在你的下一个Web应用中使用Vue.js的三个理由</title>
    <link href="https://alili.tech/archive/d3f22047/"/>
    <id>https://alili.tech/archive/d3f22047/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-18T06:20:10.815Z</updated>
    
    <content type="html"><![CDATA[<h4>Vue.js是那么地易上手，它在提供了大量开箱即用的功能的同时也提供了良好的性能。请继续阅读以下事例及代码片段以便更加了解Vue.js。</h4><p>选择一个JavaScript框架真是太难了——因为有太多的框架可以供我们使用，并且它们之间的差距并不是很明显。如果你认为生产率（“我开发起来有多快”）和性能（“我的网页性能如何”）是最重要的两点的话，就让我展示一下为什么Vue.js是一个非常可靠的构建网页以及SPA（单页Web应用）的框架吧。</p><h2>1) 组件库基于HTML/CSS和JS，使其易于入门</h2><p>你需要做的第一件事就是设置你的环境。Vue.js非常容易上手，并不一定需要像Webpack这样的构建工具。你所要做的就是在标签中进行导入：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>首先，我们要去创建一个简单的组件。其目的是为了展示一下你写的模版和JavaScript代码是如何连接起来的。</p><h3>如何去创建你的第一个组件</h3><p>你有两种方式去创建一个组件，让我们先试试简单的那个方法。它只是一个HTML和JavaScript的一种简单格式的组合。</p><p><strong>app.js</strong></p><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> app = <span class="hljs-literal">new</span> Vue({ el: <span class="hljs-string">'#app'</span>, <span class="hljs-built_in">data</span>: {   name: <span class="hljs-string">'James'</span> }})</code></pre><p><strong>app.html</strong></p><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"app"</span>&gt; Hello &lt;input type=<span class="hljs-string">"text"</span> value={{ <span class="hljs-built_in">name</span> }} /&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre><p><strong>app.css</strong></p><pre><code class="hljs css"><span class="hljs-selector-id">#app</span> <span class="hljs-selector-tag">input</span> {  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#121212</span>;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;}</code></pre><p>这几乎就是你创建第一个应用所需的全部。</p><p>如你所见，我们通过id为app的这个元素保存了模版和JavaScript之间的对应关系。然后我们仅仅提供了数据，你就能看到这些数据在你的HTML中自动绑定并渲染。</p><h3>如何连接数据和其模版？</h3><p>Vue.js 设计了一个双向绑定系统，这意味着你可以通过JavaScript或者模版的其中任意一种方式改变数据。让我们考虑一下上面的代码：如果你改变了输入框中的内容，它会自动地更新你在JavaScript中对应的变量。同样的，如果你在JavaScript文件中改变了数据，它会在你的模版中渲染出改变后的数值。</p><h3>一种Web组件的共享方法</h3><p>Vue.js 非常依赖模版声明，这能确保你的代码在第一眼看到的时候就能被理解。</p><p>它也是你可以获得的最接近 <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements" target="_blank" rel="noopener">Web自定义元素标准</a> 的模版，并且它没有繁杂的polyfill，在老式浏览器中也没有糟糕的性能。你可以在一些Web组件实现（例如 Polymer）中找到它。</p><h2>2) 路由及数据管理等基本功能已被官方库支持</h2><p>Vue.js包含的核心模块可以构建我们所创建的组件，但它还包括些组由Vue.js团队自己构建/维护的自定义库，例如管理路由的vue-router，管理数据的Vuex， 可以迅速创建一个新项目的脚手架vue-cli等。</p><h3>如何创建一个路由</h3><p>对于任何Web APP，路由都是重点之一。你可以放心的使用vue-router，可以以非常简洁的方式声明并创建所有的路由，同时只需要在组件中使用几行代码来配置动态路由的参数。</p><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> Page <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/page'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter({  [    { path: <span class="hljs-string">'/page/:uid'</span>, component: Page }  ]});</code></pre><h3>组件间如何通信？</h3><p>Web APP中的另一个基本功能是组件之间的通信，以及管理数据的方式。</p><p>Vuex是一个受Redux和Elm架构启发而诞生的模块。它提供了一种非常清晰的方式来处理组件中的操作并将数据传递给任何受它管辖组件。</p><pre><code class="hljs pf">const store = new Vuex.Store({  <span class="hljs-keyword">state</span>: {    doc: null  },  mutations: {    <span class="hljs-built_in">set</span>Document(<span class="hljs-keyword">state</span>, doc) {      <span class="hljs-keyword">state</span>.doc = doc    }  },  actions: {    async queryDocument({ commit }, { customType, uid }) {      commit('<span class="hljs-built_in">set</span>Document', await Prismic.getByUID(customType, uid))    }  }})</code></pre><h3>如何创建一个将Vuex和vue-router联系起来的组件</h3><p>现在，是时候去让所有功能运行在一个简单的组件中了。</p><pre><code class="hljs lisp">var app = new Vue({ el: '#page, beforeRouteUpdate(<span class="hljs-name">to</span>, from, next) {  store.dispatch('queryDocument', { customType: 'homepage', uid: to.params.uid })  .then(<span class="hljs-name">next</span>)})</code></pre><p>beforeRouteUpdate只是一个组件声明周期钩子，用于在组件切换路由之后应执行的代码。</p><h3>使用vue-cli快速创建项目</h3><p>vue-cli是一个命令行工具，可以使用其已经配置好的构建工具快速创建一个简单的项目。</p><p>在扩展名为.vue的文件中书写组件的方式非常好用，它允许你将HTML，CSS和JavaScript放在同一个文件中，并且确保其在正确的作用域内。</p><p>它对你写JavaScript代码也很有用，因为你可以使用像babel这样的工具来使用JS中的新语法，比如async / await。</p><p>你可以在 <a href="https://cli.vuejs.org" target="_blank" rel="noopener">Vue.js官方文档</a> 中寻找到更多帮你起步的知识。</p><h2>3) 虚拟DOM技术确保页面快速渲染，进而使得加载时间变短</h2><h3>30KB!</h3><p>Vue.js 核心模块，路由器和Vuex，Vue.js加起来通过gzip压缩后只有大约 30 KB 。</p><p>最小的占用空间也就意味着较短的加载时间，这意味着用户可以更快地使用你的Web APP，同时也可以得到更好的Google爬虫的访问速度评估值。</p><h3>虚拟 DOM!</h3><p>Vue.js也从ReactJS中获得了灵感，从版本2.0开始实现了虚拟 DOM技术。虚拟DOM简单来说是一种 在每次改变状态时，将其与实际DOM进行比对，同时在内存中生成DOM更新后版本的方法，因此你只需要更新你所改变的部分而不是重新渲染整个页面。</p><h3>基准测试</h3><p>正如以下基准测试的数据，Vue.js在各方面都提供了非常好的性能：</p><p><img src="https://p0.ssl.qhimg.com/t01aafa835ef482e90b.png" alt=""></p><p><strong>运行时间（毫秒） ± 标准差</strong></p><p><img src="https://p0.ssl.qhimg.com/t015ef8a7638bba08e1.png" alt=""></p><p><strong>内存消耗（以MB为单位）</strong></p><p>(来源: <a href="https://www.stefankrause.net/js-frameworks-benchmark7/table.html" target="_blank" rel="noopener">third-party benchmarks</a> by Stefan Krause)</p><h2>如何管理Vue.js项目中的文件</h2><p>在Prismic，我们认为Vue.js是构建复杂Web应用程序的一种非常平易近人的框架，可以通过其API很轻松地集成外部的工具。</p><p>如果您有兴趣将内容管理系统集成到你的Vue.js项目中——以便非技术的作者和文章编辑可以在他们所熟悉的环境下编辑网站的内容的话——请查看Vue.js的官方完整文档以及插件库和启动项目等。</p>          <h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/3-reasons-to-use-vue-js-in-your-next-web-project" target="_blank" rel="noopener">https://www.zcfy.cc/article/3-reasons-to-use-vue-js-in-your-next-web-project</a><br>原文标题: 在你的下一个Web应用中使用Vue.js的三个理由</p><p>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/d3f22047/">https://alili.tech/archive/d3f22047/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4&gt;Vue.js是那么地易上手，它在提供了大量开箱即用的功能的同时也提供了良好的性能。请继续阅读以下事例及代码片段以便更加了解Vue.js。&lt;/h4&gt;
&lt;p&gt;选择一个JavaScript框架真是太难了——因为有太多的框架可以供我们使用，并且它们之间的差距并不是很明显。如果你认
      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript中的this</title>
    <link href="https://alili.tech/archive/a5ceba90/"/>
    <id>https://alili.tech/archive/a5ceba90/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-18T06:20:10.797Z</updated>
    
    <content type="html"><![CDATA[<p><code>this</code> 在不同的地方被调用有不同的值。</p><p>不知道这些细节可能会导致很多头疼的问题, 所以你不妨花5分钟的时间来了解一下这些坑。</p><h2><code>this</code> 在严格模式下</h2><p>除了在声明的对象内被调用, <code>this</code> 在 <strong>严格模式下</strong> 永远是 <code>undefined</code>。</p><p>注意我提到的是严格模式。如果不是在严格模式下 (在js的头部，你没有明确的添加<code>'use strict'</code>关键字 ), 那么你就处在非严格模式的状态下, <code>this</code> 在这个环境下， 除了我下面提到的特殊案例外 ，this指代的是全局对象的值。</p><p>在浏览器的上下文环境中，这个值就是<code>window</code> 。</p><h2>在函数方法中的<code>this</code></h2><p>方法就是以函数形式附属于一个对象。</p><p>函数可以有不同的声明形式。</p><p>下面就是其中的一种：</p><pre><code class="hljs gams">const car = {  maker: <span class="hljs-string">'Ford'</span>,  <span class="hljs-keyword">model</span>: <span class="hljs-string">'Fiesta'</span>,  drive() {    console.<span class="hljs-built-in">log</span>(Driving a <span class="hljs-symbol">$</span>{this.maker} <span class="hljs-symbol">$</span>{this.<span class="hljs-keyword">model</span>} car!)  }}car.drive()<span class="hljs-comment">//Driving a Ford Fiesta car!</span></code></pre><p>在这个例子中，使用了常规的函数声明的形式, <code>this</code> 自动绑定为car这个对象。</p><p>注意: 上面的函数声明是 <code>drive: function() {</code>…这样声明的缩写</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> car = {  <span class="hljs-attr">maker</span>: <span class="hljs-string">'Ford'</span>,  <span class="hljs-attr">model</span>: <span class="hljs-string">'Fiesta'</span>,  <span class="hljs-attr">drive</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{    <span class="hljs-built_in">console</span>.log(Driving a ${<span class="hljs-keyword">this</span>.maker} ${<span class="hljs-keyword">this</span>.model} car!)  }}</code></pre><p>和上面的例子一样的指代:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> car = {  <span class="hljs-attr">maker</span>: <span class="hljs-string">'Ford'</span>,  <span class="hljs-attr">model</span>: <span class="hljs-string">'Fiesta'</span>}car.drive = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{  <span class="hljs-built_in">console</span>.log(Driving a ${<span class="hljs-keyword">this</span>.maker} ${<span class="hljs-keyword">this</span>.model} car!)}car.drive()<span class="hljs-comment">//Driving a Ford Fiesta car!</span></code></pre><p>在同样的语境下，使用箭头函数来声明函数，<code>this</code>的指代是不一样的，它属于词法（静态）绑定:</p><pre><code class="hljs coffeescript">const car = {  maker: <span class="hljs-string">'Ford'</span>,  model: <span class="hljs-string">'Fiesta'</span>,  drive: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {    <span class="hljs-built_in">console</span>.log(Driving a ${<span class="hljs-keyword">this</span>.maker} ${<span class="hljs-keyword">this</span>.model} car!)  }}car.drive()<span class="hljs-regexp">//</span>Driving a <span class="hljs-literal">undefined</span> <span class="hljs-literal">undefined</span> car!</code></pre><h2>使用箭头函数</h2><p>你不能在箭头函数中像其他正常的函数声明形式那样给函数绑定一个值来改变this的值。</p><p>导致这个的主要原因是箭头函数的工作原理。 <code>this</code>在箭头函数中是<strong>词法绑定</strong>的, 也就是说它的值仅取决于它在哪个对象下被定义。</p><h2>明确地传递一个对象来改变<code>this</code>的值</h2><p>JavaScript提供了一些方法来映射this所指代的对象，从而得到你想要的值。</p><p>在 <strong>函数声明</strong> 的阶段，使用 <code>bind()</code>:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> car = {  <span class="hljs-attr">maker</span>: <span class="hljs-string">'Ford'</span>,  <span class="hljs-attr">model</span>: <span class="hljs-string">'Fiesta'</span>}<span class="hljs-keyword">const</span> drive = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{  <span class="hljs-built_in">console</span>.log(Driving a ${<span class="hljs-keyword">this</span>.maker} ${<span class="hljs-keyword">this</span>.model} car!)}.bind(car)drive()<span class="hljs-comment">//Driving a Ford Fiesta car!</span></code></pre><p>你可以绑定一个已定义的对象来改变<code>this</code> 的值:</p><pre><code class="hljs gams">const car = {  maker: <span class="hljs-string">'Ford'</span>,  <span class="hljs-keyword">model</span>: <span class="hljs-string">'Fiesta'</span>,  drive() {    console.<span class="hljs-built-in">log</span>(Driving a <span class="hljs-symbol">$</span>{this.maker} <span class="hljs-symbol">$</span>{this.<span class="hljs-keyword">model</span>} car!)  }}const anotherCar = {  maker: <span class="hljs-string">'Audi'</span>,  <span class="hljs-keyword">model</span>: <span class="hljs-string">'A4'</span>}car.drive.bind(anotherCar)()<span class="hljs-comment">//Driving a Audi A4 car!</span></code></pre><p>使用<code>call()</code> 或者 <code>apply()</code>, 在 <strong>函数调用</strong> 阶段:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> car = {  <span class="hljs-attr">maker</span>: <span class="hljs-string">'Ford'</span>,  <span class="hljs-attr">model</span>: <span class="hljs-string">'Fiesta'</span>}<span class="hljs-keyword">const</span> drive = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">kmh</span>) </span>{  <span class="hljs-built_in">console</span>.log(Driving a ${<span class="hljs-keyword">this</span>.maker} ${<span class="hljs-keyword">this</span>.model} car at ${kmh} km/h!)}drive.call(car, <span class="hljs-number">100</span>)<span class="hljs-comment">//Driving a Ford Fiesta car at 100 km/h!</span>drive.apply(car, [<span class="hljs-number">100</span>])<span class="hljs-comment">//Driving a Ford Fiesta car at 100 km/h!</span></code></pre><p>第一个传递给<code>call()</code> 或者 <code>apply()</code>的参数是新的 <code>this</code>所指代的值。 call() 和 apply()两个函数的差异在于第二个参数，apply() 接受的是一个数组来作为它的参数，而call() 函数接受的是一串参数列表。</p><h2>DOM事件处理函数的特殊案例</h2><p>在浏览器事件处理函数的时候, <code>this</code> 指代的是HTML对象，像下面的这样：</p><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#button'</span>).addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">//HTMLElement</span>}</code></pre><p>但你可以使用bind() 函数来改变this值：</p><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#button'</span>).addEventListener(  <span class="hljs-string">'click'</span>,  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">//Window if global, or your context</span>  }.bind(<span class="hljs-keyword">this</span>))</code></pre>          <h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/this-in-javascript" target="_blank" rel="noopener">https://www.zcfy.cc/article/this-in-javascript</a><br>原文标题: JavaScript中的this</p><p>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/a5ceba90/">https://alili.tech/archive/a5ceba90/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;this&lt;/code&gt; 在不同的地方被调用有不同的值。&lt;/p&gt;
&lt;p&gt;不知道这些细节可能会导致很多头疼的问题, 所以你不妨花5分钟的时间来了解一下这些坑。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;this&lt;/code&gt; 在严格模式下&lt;/h2&gt;
&lt;p&gt;除了在声明的对象内被调用
      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>引言· 2018年前端开发工作手册</title>
    <link href="https://alili.tech/archive/9c0662f4/"/>
    <id>https://alili.tech/archive/9c0662f4/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-18T06:20:10.789Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/./" target="_blank" rel="noopener">Introduction</a></p><ul><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/what-is-a-FD.html" target="_blank" rel="noopener">什么是前端开发人员?</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/recap.html" target="_blank" rel="noopener">2017年度前端开发回顾</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/2018.html" target="_blank" rel="noopener">即将在2018的发生前端故事...</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice.html" target="_blank" rel="noopener">第一部分：前端实践</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/types-of-front-end-dev.html" target="_blank" rel="noopener">前端开发相关职位</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/tech-employed-by-fd.html" target="_blank" rel="noopener">前端开发基础知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/skills.html" target="_blank" rel="noopener">前端开发进阶知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/fd-dev-for.html" target="_blank" rel="noopener">前端程序运行环境一览</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/team.html" target="_blank" rel="noopener">在一个团队里前端开发的角色</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/myth.html" target="_blank" rel="noopener">全栈大神</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/interview-q.html" target="_blank" rel="noopener">前端面试问题合辑</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/jobboards.html" target="_blank" rel="noopener">前端求职平台合辑</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/salaries.html" target="_blank" rel="noopener">前端薪资水平</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/practice/making-fd.html" target="_blank" rel="noopener">前端开发相关知识具体组成</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning.html" target="_blank" rel="noopener">第二部分: 学习前端开发</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/self-direct-learning.html" target="_blank" rel="noopener">Self Directed Learning</a></p><ul><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/internet.html" target="_blank" rel="noopener">网络相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/browsers.html" target="_blank" rel="noopener">学习浏览器相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/dns.html" target="_blank" rel="noopener">学习DNS相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/http-networks.html" target="_blank" rel="noopener">学习HTTP/网络相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/hosting.html" target="_blank" rel="noopener">学习网络托管相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/front-end.html" target="_blank" rel="noopener">学习前端开发基础知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/ui-design-patterns.html" target="_blank" rel="noopener">学习UI以及用户交互相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/html-css.html" target="_blank" rel="noopener">学习HTML &amp; CSS相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/seo.html" target="_blank" rel="noopener">学习SEO相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/javascript.html" target="_blank" rel="noopener">学习JavaScript相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/animation.html" target="_blank" rel="noopener">学习动画相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/dom.html" target="_blank" rel="noopener">学习 DOM, BOM以及jQuery相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/fonts.html" target="_blank" rel="noopener">学习Web字体, 小图标制作以及图片相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/accessibility.html" target="_blank" rel="noopener">学习网页无障碍开发相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/web-api.html" target="_blank" rel="noopener">学习浏览器API相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/json.html" target="_blank" rel="noopener">学习JSON相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/templates.html" target="_blank" rel="noopener">学习JS模板化相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/static.html" target="_blank" rel="noopener">学习静态页面生成相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/cs.html" target="_blank" rel="noopener">用JS语言学习计算科学与技术</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/front-end-apps.html" target="_blank" rel="noopener">学习前端应用程序架构</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/data-api.html" target="_blank" rel="noopener">学习数据API设计</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/react.html" target="_blank" rel="noopener">学习React相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/state.html" target="_blank" rel="noopener">学习状态管理相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/pwa.html" target="_blank" rel="noopener">学习渐进式网页应用开发相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/js-api.html" target="_blank" rel="noopener">学习JS API设计</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/browser-dev-tools.html" target="_blank" rel="noopener">学习使用前端开发调试工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/cli.html" target="_blank" rel="noopener">学习使用命令行</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/node.html" target="_blank" rel="noopener">学习Node.js相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/module.html" target="_blank" rel="noopener">学习JS模块相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/module-bundlers-loaders.html" target="_blank" rel="noopener">学习关于JS模块加载器相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/package-manager.html" target="_blank" rel="noopener">学习包管理器相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/version-control.html" target="_blank" rel="noopener">学习版本控制相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/build.html" target="_blank" rel="noopener">学习前端自动化开发相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/perf.html" target="_blank" rel="noopener">学习网站性能优化相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/test.html" target="_blank" rel="noopener">学习测试相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/headless-browsers.html" target="_blank" rel="noopener">学习无界面化测试</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/offline.html" target="_blank" rel="noopener">学习离线开发技巧</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/security.html" target="_blank" rel="noopener">学习前端安全相关知识</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/multi-device-dev.html" target="_blank" rel="noopener">学习前端多端开发相关知识（例如：响应式网页设计）</a></p></li></ul></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/direct-learning.html" target="_blank" rel="noopener">Directed Learning</a></p><ul><li><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/courses.html" target="_blank" rel="noopener">前端开发学习相关在线学校</a></li></ul></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/learn-from.html" target="_blank" rel="noopener">前端开发者的知识来源</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/learning/news-podcasts.html" target="_blank" rel="noopener">前端开发相关周刊，新闻以及相关的博客</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools.html" target="_blank" rel="noopener">第三部分：前端开发工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/browsedocs.html" target="_blank" rel="noopener">API文档相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/seo.html" target="_blank" rel="noopener">SEO相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/proto.html" target="_blank" rel="noopener">原型和线框图工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/diagram.html" target="_blank" rel="noopener">绘图工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/http.html" target="_blank" rel="noopener">http工具以及相关网络工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/code-editor.html" target="_blank" rel="noopener">编辑器相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/browser.html" target="_blank" rel="noopener">浏览器相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/html.html" target="_blank" rel="noopener">HTML相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/css.html" target="_blank" rel="noopener">CSS相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/dom.html" target="_blank" rel="noopener">DOM开发相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/js.html" target="_blank" rel="noopener">JavaScript开发相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/static.html" target="_blank" rel="noopener">静态网页生成相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/accessibility.html" target="_blank" rel="noopener">一些好用的网页开发辅助工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/apps.html" target="_blank" rel="noopener">APP开发（桌面端以及手机移动端）相关框架工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/state.html" target="_blank" rel="noopener">状态管理器相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/pwa.html" target="_blank" rel="noopener">渐进式网页应用开发相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/dev-tools.html" target="_blank" rel="noopener">GUI相关开发工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/templates.html" target="_blank" rel="noopener">数据绑定相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/ui.html" target="_blank" rel="noopener">UI小部件和组件工具包</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/charting.html" target="_blank" rel="noopener">数据可视化相关工具 （例如： 图表)</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/graphics.html" target="_blank" rel="noopener">图形相关工具 （例如： SVG, canvas, webgl）</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/animation.html" target="_blank" rel="noopener">动画相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/json.html" target="_blank" rel="noopener">JSON相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/placeholder.html" target="_blank" rel="noopener">占位符、图像以及文本相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/testing.html" target="_blank" rel="noopener">测试相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/db.html" target="_blank" rel="noopener">前端数据储存管理相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/loaders.html" target="_blank" rel="noopener">模块打包工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/repo.html" target="_blank" rel="noopener">模块仓库管理工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/hosting.html" target="_blank" rel="noopener">网站托管相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/project-hosting.html" target="_blank" rel="noopener">项目管理以及代码托管相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/comm.html" target="_blank" rel="noopener">合作与交流相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/cms.html" target="_blank" rel="noopener">内容托管工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/baas.html" target="_blank" rel="noopener">后端服务工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/offline.html" target="_blank" rel="noopener">离线开发工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/security.html" target="_blank" rel="noopener">网络安全相关工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/task.html" target="_blank" rel="noopener">任务管理工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/deploy.html" target="_blank" rel="noopener">部署工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/uptime.html" target="_blank" rel="noopener">网页监控工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/error.html" target="_blank" rel="noopener">JS错误监视工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/perf.html" target="_blank" rel="noopener">其他一些优秀的工具合辑</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/tools/find-tools.html" target="_blank" rel="noopener">查找工具</a></p></li><li><p><a href="https://frontendmasters.com/books/front-end-handbook/2018/frontendmasters.html" target="_blank" rel="noopener">由Frontend Masters赞助</a></p></li></ul></li></ul><ul><li><a href="https://www.gitbook.com" target="_blank" rel="noopener">由GitBook发布</a></li></ul><h1><a href="https://frontendmasters.com/books/front-end-handbook/2018/." target="_blank" rel="noopener">Introduction</a></h1><h1>Front-End Developer Handbook 2018</h1><h3>作者：<a href="http://codylindley.com/" target="_blank" rel="noopener">Cody Lindley</a></h3><p>由 <a href="https://frontendmasters.com/" target="_blank" rel="noopener">Frontend Masters</a>赞助, 通过丰富的、主流的前端课程来提高你的技术。</p><p><img src="https://p0.ssl.qhimg.com/t0162cbcd691f22fba8.jpg" alt="Front End Handbook 2018 Cover"></p><p>这是一个任何人都可以用来学习前端开发的指南。 它对前端开发进行广泛的概述和探讨： 在2018年度如何学习前端技术及其相关的开发工具。</p><p>这个手册的主要目的是为了帮助那些想成为前端开发这个领域专业人员的人提供学习该技术的专业资源。另外，也可以帮助经理、首席技术官、讲师或者猎头们了解前端开发这个领域应该具备的知识技能。</p><p>这本手册的内容偏向于web前端开发技术（HTML, CSS, DOM, and JavaScript），另外这些解决方案的资源是直接建立在这些开放技术上的。在手册中被引用和被讨论的资源要么是在目前最主流的，要么是目前解决该领域问题最好的方案。</p><p>这本手册不能被认为是前端开发人员最全面的知识概括。 它的价值在于简洁、及时、集中整理了关于当前前端开发者所应具备的知识大纲，以补全你在某一方面的短板。</p><p>我们想法是每年发布一次更新。</p><p>这本手册主要由下面三部分组成：</p><h2>Part I. 前端实践</h2><p>第一部分主要概括了前端开发技术</p><h2>Part II: 学习前端开发</h2><p>第二部分明确地给那些想成为前端开发人员的人提供了学习知识的资源。</p><h2>Part III: 前端开发工具</h2><p>第三部分简要的解释和分析了改领域的前端开发工具。</p><hr><p><strong>下在 .pdf, .epub, 或者 .mobi 文件</strong> :</p><ul><li><a href="https://www.gitbook.com/book/frontendmasters/front-end-developer-handbook-2018/details" target="_blank" rel="noopener">https://www.gitbook.com/book/frontendmasters/front-end-developer-handbook-2018/details</a></li></ul><p><strong>在github上贡献内容、建议和修复</strong>：</p><ul><li><a href="https://github.com/FrontendMasters/front-end-handbook-2018" target="_blank" rel="noopener">https://github.com/FrontendMasters/front-end-handbook-2018</a></li></ul><hr><p> <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank" rel="noopener"><img src="https://p0.ssl.qhimg.com/t0141f106e620166c86.png" alt="Creative Commons License"></a> 这项工作由 [Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License]授权(<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank" rel="noopener">http://creativecommons.org/licenses/by-nc-nd/3.0/)</a>).</p>          <h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/introduction-front-end-developer-handbook-2018" target="_blank" rel="noopener">https://www.zcfy.cc/article/introduction-front-end-developer-handbook-2018</a><br>原文标题: 引言· 2018年前端开发工作手册</p><p>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/9c0662f4/">https://alili.tech/archive/9c0662f4/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://frontendmasters.com/books/front-end-handbook/2018/./&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introduction&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript Functions详解（包含ES6箭头函数）</title>
    <link href="https://alili.tech/archive/2d483fa4/"/>
    <id>https://alili.tech/archive/2d483fa4/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-18T06:20:10.790Z</updated>
    
    <content type="html"><![CDATA[<h2>简介</h2><p>JavaScript中的所有内容都发生在函数中。</p><p>函数是一个代码块，可以定义一次并随时运行。</p><p>函数可以选择接受参数，并返回一个值。</p><p>JavaScript中的函数是<strong>对象</strong>，一种特殊的对象：<strong>函数对象</strong>。</p><p>另外，函数被称为<strong>第一类函数</strong>，因为它们可以被赋值给一个值，它们可以作为参数传递并用作返回值。</p><h2>句法</h2><p>让我们从“旧的”，ES6 / ES2015之前的语法开始。这是一个<strong>函数声明</strong>：</p><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dosomething</span><span class="hljs-params">(foo)</span> </span>{  <span class="hljs-comment">// do something</span>}</code></pre><p>（现在，在ES6 / ES2015世界中，被称为<strong>常规函数</strong>）</p><p>函数可以分配给变量（这称为<strong>函数表达式</strong>）：</p><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> dosomething = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(foo)</span> </span>{  <span class="hljs-comment">// do something</span>}</code></pre><p><strong>命名函数表达式</strong>类似，但在堆栈调用跟踪中更好用，这在发生错误时很有用 - 它保存函数的名称：</p><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> dosomething = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dosomething</span><span class="hljs-params">(foo)</span> </span>{  <span class="hljs-comment">// do something</span>}</code></pre><p>ES6 / ES2015引入了<strong>箭头函数</strong>，在使用内联函数时，特别适合用作参数或回调函数：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dosomething = <span class="hljs-function"><span class="hljs-params">foo</span> =&gt;</span> {  <span class="hljs-comment">//do something</span>}</code></pre><p>箭头函数与上面的其他函数定义有很大的不同，我们稍后会解释。</p><h2>参数</h2><p>一个函数可以有一个或多个参数。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dosomething = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {  <span class="hljs-comment">//do something</span>}<span class="hljs-keyword">const</span> dosomethingElse = <span class="hljs-function"><span class="hljs-params">foo</span> =&gt;</span> {  <span class="hljs-comment">//do something</span>}<span class="hljs-keyword">const</span> dosomethingElseAgain = <span class="hljs-function">(<span class="hljs-params">foo, bar</span>) =&gt;</span> {  <span class="hljs-comment">//do something</span>}</code></pre><p>从ES6 / ES2015开始，函数可以具有参数的默认值：</p><pre><code class="hljs coffeescript">const dosomething = <span class="hljs-function"><span class="hljs-params">(foo = <span class="hljs-number">1</span>, bar = <span class="hljs-string">'hey'</span>)</span> =&gt;</span> {  <span class="hljs-regexp">//</span><span class="hljs-keyword">do</span> something}</code></pre><p>这允许您在不填充所有参数的情况下调用函数：</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">dosomething</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span><span class="hljs-function"><span class="hljs-title">dosomething</span><span class="hljs-params">()</span></span></code></pre><p>ES2018引入了参数的尾随逗号，这个功能有助于减少因移动参数时丢失逗号而导致的错误（例如，移动中间的最后一个）：</p><pre><code class="hljs coffeescript">const dosomething = <span class="hljs-function"><span class="hljs-params">(foo = <span class="hljs-number">1</span>, bar = <span class="hljs-string">'hey'</span>)</span> =&gt;</span> {  <span class="hljs-regexp">//</span><span class="hljs-keyword">do</span> something}dosomething(<span class="hljs-number">2</span>, <span class="hljs-string">'ho!'</span>)</code></pre><p>您可以将所有参数包装在一个数组中，并在调用函数时使用spread运算符：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dosomething = <span class="hljs-function">(<span class="hljs-params">foo = <span class="hljs-number">1</span>, bar = <span class="hljs-string">'hey'</span></span>) =&gt;</span> {  <span class="hljs-comment">//do something</span>}<span class="hljs-keyword">const</span> args = [<span class="hljs-number">2</span>, <span class="hljs-string">'ho!'</span>]dosomething(...args)</code></pre><p>当使用许多参数的时候，记住这些参数可能很困难。这里可以使用对象，解构保留参数名称：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dosomething = <span class="hljs-function">(<span class="hljs-params">{ foo = <span class="hljs-number">1</span>, bar = <span class="hljs-string">'hey'</span> }</span>) =&gt;</span> {  <span class="hljs-comment">//do something</span>  <span class="hljs-built_in">console</span>.log(foo) <span class="hljs-comment">// 2</span>  <span class="hljs-built_in">console</span>.log(bar) <span class="hljs-comment">// 'ho!'</span>}<span class="hljs-keyword">const</span> args = { <span class="hljs-attr">foo</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">'ho!'</span> }dosomething(args)</code></pre><h2>返回值</h2><p>每个函数都返回一个值，默认情况下为“undefined”。</p><p><img src="https://p0.ssl.qhimg.com/t010130d4733855f140.png" alt="Undefined return value"></p><p>任何函数在其代码行结束时，或者当执行流找到<code>return</code>关键字时终止。</p><p>当JavaScript遇到此关键字时，它退出函数执行并将控制权交还给其调用者。</p><p>如果传递一个值，则该值将作为函数的结果返回：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dosomething = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {  <span class="hljs-keyword">return</span> <span class="hljs-string">'test'</span>}<span class="hljs-keyword">const</span> result = dosomething() <span class="hljs-comment">// result === 'test'</span></code></pre><p>您只能返回一个值。</p><p>要_模拟_返回多个值，您可以返回<strong>对象文字</strong>或<strong>数组</strong>，并在调用时使用<a href="https://flaviocopes.com/ecmascript/#destructuring-assignments" target="_blank" rel="noopener">解构赋值</a>功能。</p><p>使用数组：</p><p><img src="https://p0.ssl.qhimg.com/t010acfea4f4be3a7b3.png" alt="Destructuring using arrays"></p><p>使用对象：</p><p><img src="https://p0.ssl.qhimg.com/t01a912818eeb605c4c.png" alt="Destructuring using objects"></p><h2>嵌套函数</h2><p>可以在其他函数中定义函数：</p><pre><code class="hljs coffeescript">const dosomething = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {  const dosomethingelse = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}  dosomethingelse()  <span class="hljs-keyword">return</span> <span class="hljs-string">'test'</span>}</code></pre><p>嵌套函数的作用域是外部函数，不能从外部调用。</p><h2>对象方法</h2><p>当用作对象属性时，函数称为方法：</p><pre><code class="hljs vim">const car = {  brand: <span class="hljs-string">'Ford'</span>,  <span class="hljs-keyword">mode</span><span class="hljs-variable">l:</span> <span class="hljs-string">'Fiesta'</span>,  <span class="hljs-keyword">star</span><span class="hljs-variable">t:</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>    console.<span class="hljs-built_in">log</span>(Started)  }}car.start()</code></pre><h2>箭头函数中的<code>this</code></h2><p>当箭头函数与常规函数用作对象方法时，有一个重要的行为。考虑这个例子：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> car = {  <span class="hljs-attr">brand</span>: <span class="hljs-string">'Ford'</span>,  <span class="hljs-attr">model</span>: <span class="hljs-string">'Fiesta'</span>,  <span class="hljs-attr">start</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{    <span class="hljs-built_in">console</span>.log(Started ${<span class="hljs-keyword">this</span>.brand} ${<span class="hljs-keyword">this</span>.model})  },  <span class="hljs-attr">stop</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {    <span class="hljs-built_in">console</span>.log(Stopped ${<span class="hljs-keyword">this</span>.brand} ${<span class="hljs-keyword">this</span>.model})  }}</code></pre><p><code>stop（）</code>方法不能像你期望的那样工作。</p><p><img src="https://p0.ssl.qhimg.com/t01002a63df67722931.png" alt="Difference in arrow functions of this in methods"></p><p>这是因为<code>this</code>的处理在两个函数声明样式中是不同的。箭头函数中的<code>this</code>指的是封闭函数上下文，在本例中是<code>window</code>对象</p><p><img src="https://p0.ssl.qhimg.com/t01d733b90bb9e19d70.png" alt="this points to the window object"></p><p><code>this</code>，使用<code>function（）</code>引用宿主对象</p><p>这意味着<strong>箭头函数不适合用于对象方法</strong>和构造函数（箭头函数构造函数实际上会在调用时引发<code>TypeError</code>）。</p><h2>IIFE，立即调用函数表达式</h2><p>IIFE是一个在声明后立即执行的功能：</p><pre><code class="hljs javascript">;(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dosomething</span>(<span class="hljs-params"></span>) </span>{  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'executed'</span>)})()</code></pre><p>您可以将结果分配给变量：</p><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> something = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dosomething</span><span class="hljs-params">()</span> </span>{  <span class="hljs-keyword">return</span> <span class="hljs-string">'something'</span>})()</code></pre><p>它们非常方便，因为您无需在定义后单独调用该函数。</p><h2>Function 挂载</h2><p>执行代码之前的JavaScript会根据某些规则对其进行重新排序。</p><p>会将函数移动到其范围的顶部。这就是下面例子不会报错的原因;</p><pre><code class="hljs javascript">dosomething()<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dosomething</span>(<span class="hljs-params"></span>) </span>{  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'did something'</span>)}</code></pre><p><img src="https://p0.ssl.qhimg.com/t0102a94671f266ff7b.png" alt="Hoisting example"></p><p>在内部，JavaScript在调用之前移动函数，以及在同一范围内找到的所有其他函数：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dosomething</span>(<span class="hljs-params"></span>) </span>{  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'did something'</span>)}dosomething()</code></pre><p>现在，如果你使用命名函数表达式，因为你正在使用<a href="https://flaviocopes.com/javascript-variables/" target="_blank" rel="noopener">变量</a>，会发生不同的事情。变量声明被提升，但不是值，因此不是函数。</p><pre><code class="hljs javascript">dosomething()<span class="hljs-keyword">const</span> dosomething = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dosomething</span>(<span class="hljs-params"></span>) </span>{  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'did something'</span>)}</code></pre><p>不会工作：</p><p><img src="https://p0.ssl.qhimg.com/t01d1d015db154dd89a.png" alt="Hoisting named functions"></p><p>这是因为内部发生的事情是：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dosomethingdosomething()dosomething = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dosomething</span>(<span class="hljs-params"></span>) </span>{  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'did something'</span>)}</code></pre><p>“let”声明也是如此。<code>var</code>声明也不起作用，但是报的不是同样的错误：</p><p><img src="https://p0.ssl.qhimg.com/t012b57898c7f816900.png" alt="Hoisting var declarations"></p><p>这是因为<code>var</code>声明被提升并用<code>undefined</code>作为值初始化，而<code>const</code>和<code>let</code>被提升但未初始化。</p>          <h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/javascript-functions" target="_blank" rel="noopener">https://www.zcfy.cc/article/javascript-functions</a><br>原文标题: JavaScript Functions详解（包含ES6箭头函数）</p><p>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/2d483fa4/">https://alili.tech/archive/2d483fa4/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;JavaScript中的所有内容都发生在函数中。&lt;/p&gt;
&lt;p&gt;函数是一个代码块，可以定义一次并随时运行。&lt;/p&gt;
&lt;p&gt;函数可以选择接受参数，并返回一个值。&lt;/p&gt;
&lt;p&gt;JavaScript中的函数是&lt;strong&gt;对象&lt;/strong&gt;，一种特
      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>（...）这三个点在JavaScript中意味着什么？</title>
    <link href="https://alili.tech/archive/bacefe7d/"/>
    <id>https://alili.tech/archive/bacefe7d/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-18T06:20:10.789Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章的标题来自<a href="http://qr.ae/TUNtnE" target="_blank" rel="noopener">我在Quora上被要求回答的一个问题</a>。下面是我试图解释JavaScript中三个点的作用。希望这对于将来有相同问题的人来说可以消除围绕这个概念的迷雾。</p><h2>数组/对象扩展运算符</h2><p>假设您有以下对象：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">const adrian</span> = {  fullName: <span class="hljs-string">'Adrian Oprea'</span>,  occupation: <span class="hljs-string">'Software developer'</span>,  age: 31,  website: <span class="hljs-string">'https://oprea.rocks'</span>};</code></pre><p>假设您要创建一个具有不同名称和网站但具有相同职业和年龄的新对象（人）。</p><p>您可以通过仅指定所需的属性来执行此操作，并使用扩展运算符来完成其余操作，如下所示：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">const bill</span> = {  ...adrian,  fullName: <span class="hljs-string">'Bill Gates'</span>, website: <span class="hljs-string">'https://microsoft.com'</span>};</code></pre><p>上面代码的作用是遍布adrian对象并获取其所有属性，然后用我们传递的属性覆盖现有属性。可以将这种传播视为逐个提取所有单个属性并将它们传递给新对象。</p><p>在这种情况下，由于我们在扩展运算符启动后指定了fullName和网站属性，因此JavaScript引擎知道我们要覆盖来自原始对象的那些属性的原始值。</p><p>这与阵列类似。除了传播键和值之外，运算符不会传播索引(index)和值。与对象传播不同的是，你不会有重复的属性，因为这是JavaScript对象的工作方式（你不能拥有一个具有两个fullName属性的对象），如果你计划实现类似的东西，那么对于数组你最终可能会有重复的值到我们的对象示例。</p><p>这意味着下面的代码将导致您拥有包含重复元素的数组。</p><pre><code class="hljs lsl">const numbers1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];const numbers2 = [ ...numbers1, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]; <span class="hljs-comment">// this will be [1, 2, 3, 4, 5, 1, 2, 6, 7, 8]</span></code></pre><p>可以把它想象成<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank" rel="noopener">Array.prototype.concat</a>的替代品.</p><h2>rest运算符</h2><p>使用函数的参数时，无论是完全替换参数还是与函数的参数一起替换参数，这三个点也称为rest运算符。</p><p>当像这样使用它时，rest操作符使开发人员能够创建可以获取无限数量的参数的函数，也称为变量arity或可变函数。</p><p>这是这种功能最简单的例子。假设您要创建一个计算其所有参数之和的函数。请注意，它不是两个，三个或四个数字的总和，而是函数作为参数接收的所有数字的总和。</p><p>这是一个简单的实现，使用rest运算符</p><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-rest_arg">...numbers</span>)</span> </span>{    <span class="hljs-keyword">return</span> numbers.reduce((accumulator, current) =&gt; {        <span class="hljs-keyword">return</span> accumulator += current    });};sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span>sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">// 15</span></code></pre><p>最简单的解释是，rest运算符接收函数接收的参数并将它们转储到以后可以使用的实数数组中。</p><p>你可能会觉得，你可以通过请求用户传递一组数字来完成此操作。这在技术上是可行的，但是这样的用户体验很差，因为用户希望用普通数字而不是数字列表来调用sum函数。</p><p>您可能还认为可以使用arguments数组。这也是事实，但要小心，参数不是真正的数组，而是类似数组的对象（具有length属性的对象）。对于我们的sum函数的第一次调用，在前面的例子中，它实际上看起来像这样：</p><pre><code class="hljs xquery">{  <span class="hljs-string">'0'</span>: <span class="hljs-number">1</span>,  <span class="hljs-string">'1'</span>: <span class="hljs-number">2</span>,  <span class="hljs-string">'length'</span>: <span class="hljs-number">2</span>}</code></pre><p>要操作此对象并在其上使用数组方法，例如reduce，从我之前的示例中，您必须执行Array.prototype.slice.call（arguments，0）操作。就速度和内存使用而言，这表现不佳并且不优雅。这样的代码，容易让你的初级水平的同事感到困惑。</p><p>这应该是您需要了解的所有内容，以便在JavaScript中使用rest / spread运算符。</p><p>如果您对如何改进文章有任何建议，或者您需要一些帮助来围绕这个概念，请在下面留言。</p><p>祝你生活愉快！</p><p>Adrian.</p><blockquote><p>Image credits: By Otter <a href="http://www.gnu.org/copyleft/fdl.html" target="_blank" rel="noopener">GFDL</a> or <a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank" rel="noopener">CC-BY-SA-3.0</a>, from Wikimedia Commons</p></blockquote>          <h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/what-do-the-three-dots-mean-in-javascript" target="_blank" rel="noopener">https://www.zcfy.cc/article/what-do-the-three-dots-mean-in-javascript</a><br>原文标题: （…）这三个点在JavaScript中意味着什么？<br>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/bacefe7d/">https://alili.tech/archive/bacefe7d/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章的标题来自&lt;a href=&quot;http://qr.ae/TUNtnE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我在Quora上被要求回答的一个问题&lt;/a&gt;。下面是我试图解释JavaScript中三个点的作用。希望这对于将来有相同问题的人来说可以
      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript循环和作用域</title>
    <link href="https://alili.tech/archive/db5efcc5/"/>
    <id>https://alili.tech/archive/db5efcc5/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-18T06:20:10.810Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://flaviocopes.com/javascript/" target="_blank" rel="noopener">JavaScript</a>有一个特点，也许会让开发者头痛, 是与循环和作用域相关的.</p><p>举个例子:</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> operations = []<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {  operations.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {    <span class="hljs-built_in">console</span>.log(i)  })}<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> operation <span class="hljs-keyword">of</span> operations) {  operation()}</code></pre><p>它基本是循环了5次，将一个函数添加到operations数组里面。这个函数可打印出循环变量索引值<code>i</code>.</p><p>运行这些函数后</p><p>期望的结果应该是:</p><pre><code class="hljs lsl"><span class="hljs-number">0</span><span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span></code></pre><p>但实际发生的是这样的:</p><pre><code class="hljs lsl"><span class="hljs-number">5</span><span class="hljs-number">5</span><span class="hljs-number">5</span><span class="hljs-number">5</span><span class="hljs-number">5</span></code></pre><p>为什么会有这种情况? 因为使用的是<code>var</code>.</p><p>由于<strong>提升</strong>了<code>var</code>变量, 上面的代码等同于</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i;<span class="hljs-keyword">const</span> operations = []<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {  operations.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {    <span class="hljs-built_in">console</span>.log(i)  })}<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> operation <span class="hljs-keyword">of</span> operations) {  operation()}</code></pre><p>因此，在for-of循环中, <code>i</code> 依然是可见的, 它等于5，并且每次在函数中涉及到<code>i</code> ,都将使用这个值。</p><p>那么我们应该如何做让其变成我们想的这样呢?</p><p>最简单的方案是用 <code>let</code> 声明. 在ES2015中介绍到, 它们有很大的帮助，能避免关于使用<code>var</code>声明的一些奇怪问题。</p><p>简单的在循环变量时将<code>var</code> 变成 <code>let</code> ,能够很好的运行：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> operations = []<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {  operations.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {    <span class="hljs-built_in">console</span>.log(i)  })}<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> operation <span class="hljs-keyword">of</span> operations) {  operation()}</code></pre><p>这是输出结果:</p><pre><code class="hljs lsl"><span class="hljs-number">0</span><span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span></code></pre><p>这是怎么实现的呢?这是因为每次循环重复的时候，都将重新创造 <code>i</code> ,同时每个函数添加<code>operations</code>数组时，能获取它本身的<code>i</code>。</p><p>记住你不能使用 <code>const</code>在这种情况下, 因为这会导致<code>for</code>在第二次循环时， 尝试赋新值报错。</p><p>另外一个非常普遍的解决这个问题是使用pre-ES6代码, 同时它被称作<strong>即时调用函数表达式</strong> (IIFE).</p><p>在这种情况下，你可以包装整个函数，并将<code>i</code> 绑定在它上面。自这种方式，你正在创造一个能立即执行的函数，你从其返回的一个新的函数。因此我们可以稍后执行它。</p><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> operations = []<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {  operations.push(<span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">j</span>) =&gt; {    <span class="hljs-keyword">return</span> (<span class="hljs-params"></span>) =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-params">j</span>)  }</span>)(<span class="hljs-params">i</span>))}<span class="hljs-params">for</span> (<span class="hljs-params"><span class="hljs-keyword">const</span> operation of operations</span>) {  <span class="hljs-params">operation</span><span class="hljs-params">()</span>}</span></code></pre>          <h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/javascript-loops-and-scope" target="_blank" rel="noopener">https://www.zcfy.cc/article/javascript-loops-and-scope</a><br>原文标题: JavaScript循环和作用域</p><p>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/db5efcc5/">https://alili.tech/archive/db5efcc5/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://flaviocopes.com/javascript/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript&lt;/a&gt;有一个特点，也许会让开发者头痛, 是与循环和作用域相关的.&lt;/p&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>2018年值得关注的10大JavaScript动画库</title>
    <link href="https://alili.tech/archive/fd528aee/"/>
    <id>https://alili.tech/archive/fd528aee/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-18T06:20:10.790Z</updated>
    
    <content type="html"><![CDATA[<p><a href="">原文链接</a></p><p>现代网站客户端提供了高质量的动画，导致了JavaScript动画库的需求不断增加。幸运的是，供应似乎与需求相匹配，且有多种选择。至于选择哪一个就难以定夺了。在这一年里，许多动画库有可能完善得更好，为创建动画提供更好的解决方案。</p><p>让我们来看看2018年值得关注的十大JavaScript动画库。</p><h3><a href="https://github.com/mrdoob/three.js" target="_blank" rel="noopener">Three JS</a></h3><h4><strong>42,569 ★</strong></h4><p>TODO 粘贴图片在此</p><p>Three JS 是这里面排名第一、最受欢迎的动画库（该项目有900多位的贡献者）。八年了，Three JS 仍是一个强大的动画工具。Three JS 依赖于WebGL，可以用来构建浏览器端酷炫的3D计算机图形。Three JS的功能包括但不限于浮雕效果，透视和正交相机，几何工具，如平面，立方体，球体，环面。然而，这个库的一个缺点是一些开发人员发现它使用起来很慢。</p><p><strong>安装:</strong></p><p>使用NPM，可以使用以下命令安装Three JS。</p><p><strong>npm install three</strong></p><p>更多信息可从<a href="https://threejs.org/" target="_blank" rel="noopener">官方网站</a>或<a href="https://www.npmjs.com/package/three" target="_blank" rel="noopener">npm</a>获取。</p><h3><a href="https://github.com/juliangarnier/anime" target="_blank" rel="noopener">Anime JS</a></h3><h4>21,084 ★</h4><p>Anime JS作为Three JS的潜在替代方案，居于列表第二位。Anime JS由Julian Garnier创建，是您遇到过最快的动画库之一。Anime JS可以与DOM一起顺利运行，并且支持Chrome，Firefox，Opera，Safari，IE10+等的主流浏览器。此库包括但不限于以下功能：用于CSS动画的的<code>CSS transform</code>，用于线的SVG动画，用于同步多个实例的时间轴。Anime JS最吸引开发者的原因之一就它非常轻量级。</p><p><strong>安装:</strong></p><p>使用NPM，可以使用以下命令安装Anime JS。</p><p><strong>npm install animejs</strong></p><p>更多信息可从<a href="http://animejs.com/" target="_blank" rel="noopener">官方网站</a>或<a href="https://www.npmjs.com/package/animejs" target="_blank" rel="noopener">npm</a>获取。</p><h3><a href="https://github.com/VincentGarreau/particles.js" target="_blank" rel="noopener">Particles JS</a></h3><h4>15,612 ★</h4><p>接下来我们要看的第三个动画库是Particles JS。Particles JS由Vincent Garreau创建，是一款特定动画的JavaScript库，用于创建点和线组成的精彩动画。如前所述，该库用于创建看起来像粒子的动画。因此，它允许开发人员切换诸如粒子的密度，颜色，不透明度，形状和大小之类的东西。但是，由于它仅适用于粒子背景，因此不适合用来创建其他类型的动画。</p><p><strong>安装:</strong></p><p>使用NPM，可以使用以下命令安装Particles JS。</p><p><strong>npm install particlesjs</strong></p><p>更多信息可从<a href="https://vincentgarreau.com/particles.js/" target="_blank" rel="noopener">官方网站</a>或<a href="https://www.npmjs.com/package/particlesjs" target="_blank" rel="noopener">npm</a>获取。</p><h3><a href="https://github.com/jlmakes/scrollreveal" target="_blank" rel="noopener">ScrollReveal JS</a></h3><h4>15,499 ★</h4><p>ScrollReveal JS居于列表第四位，与前面讨论的Particles JS一样，也是一款特定动画的JavaScript库。ScrollReveal JS用于创建十分酷炫的滚动特效，是一个轻量级的工具（没有任何依赖），而且非常容易使用，因为它使用自然语言来发送创建动画的指令。ScrollReveal JS适用于DOM节点，多个容器，异步内容，并且支持3D旋转。ScrollReveal JS可能是创建滚动特效最好用的工具，它支持大量的浏览器，只要它们支持CSS Transform和CSS Transition特性。</p><p><strong>安装:</strong></p><p>使用NPM，可以使用以下命令安装ScrollReveal JS。</p><p><strong>npm install scrollreveal</strong></p><p>更多信息可从<a href="https://scrollrevealjs.org/" target="_blank" rel="noopener">官方网站</a>或<a href="https://www.npmjs.com/package/scrollreveal" target="_blank" rel="noopener">npm</a>获取。</p><h3><a href="https://github.com/julianshapiro/velocity" target="_blank" rel="noopener">Velocity JS</a></h3><h4>14,692 ★</h4><p>接下来在这个精彩的动画库列表上的就是Velocity JS了。它深得许多UI设计师的喜爱。通过使用HTML和SVG，该工具可以轻松创建功能强大的Web动画。Velocity JS可用于滚动浏览器窗口，甚至撤消以前的动画。Velocity JS尽管使用与jQuery的$.animate（）相同的API，您会发现它是少数独立于强大的jQuery框架的动画工具之一。像WhatsApp和MailChimp就是该优秀工具的知名用户。</p><p><strong>安装:</strong></p><p>使用NPM，可以使用以下命令安装Velocity JS。</p><p><strong>npm install velocity-animate</strong></p><p>更多信息可从<a href="http://velocityjs.org/" target="_blank" rel="noopener">官方网站</a>或<a href="https://www.npmjs.com/package/velocity-animate" target="_blank" rel="noopener">npm</a>获取。</p><h3><a href="https://github.com/Popmotion/popmotion" target="_blank" rel="noopener">Popmotion JS</a></h3><h4>13,777 ★</h4><p>Popmotion JS排行第六，是一款与Anime JS类似的动画库，可用于创建精彩的浏览器动画。该库还具有指针跟踪，弹簧物理，3D动画等功能，并可用于创建功能型，反应型的动画。</p><p><strong>安装:</strong></p><p>使用NPM，可以使用以下命令安装Popmotion JS。</p><p><strong>npm install popmotion</strong></p><p>更多信息可从<a href="https://popmotion.io/" target="_blank" rel="noopener">官方网站</a>或<a href="https://www.npmjs.com/package/popmotion" target="_blank" rel="noopener">npm</a>获取。</p><h3><a href="https://github.com/legomushroom/mojs" target="_blank" rel="noopener">Mo JS</a></h3><h4>13,461 ★</h4><p>与Popmotion JS类似，Mo JS排名第七，是一款用于创建Web动画的简单库。Mo JS简单易学，它的创建者Oleg Solomka已经创建了很多教程和demo，来帮助初学者快速上手。Mo JS还具有创建圆形，多边形，矩形，线条等功能。Mo JS看起来很简单，却可以构建出非常复杂的动态图形的Web动画。</p><p><strong>安装:</strong></p><p>使用NPM，可以使用以下命令安装Mo JS。</p><p><strong>npm install mo-js</strong></p><p>更多信息可从<a href="http://mojs.io//" target="_blank" rel="noopener">官方网站</a>或<a href="https://www.npmjs.com/package/mo-js" target="_blank" rel="noopener">npm</a>获取。</p><h3><a href="https://github.com/maxwellito/vivus" target="_blank" rel="noopener">Vivus JS</a></h3><h4>10,365 ★</h4><p>Vivus JS在这个名单上排名第八。如果您在此列表中寻找一个使用SVG的优秀库，那么Vivus JS是最佳之选，尤其适合初学者。这个库也很快、很轻量级，因为它没有任何依赖。除了使用SVG之外，Vivus JS还可用于创建漂亮的按钮，也有其他令人惊叹的动画可供使用。</p><p><strong>安装:</strong></p><p>使用NPM，可以使用以下命令安装Vivus JS。</p><p><strong>npm install vivus</strong></p><p>更多信息可从<a href="https://maxwellito.github.io/vivus/" target="_blank" rel="noopener">官方网站</a>或<a href="https://www.npmjs.com/package/vivus" target="_blank" rel="noopener">npm</a>获取。</p><h3><a href="https://github.com/greensock/GreenSock-JS" target="_blank" rel="noopener">GreenSock JS</a></h3><h4>7,767 ★</h4><p>GreenSock，通常被称为GSAP（GreenSock动画平台），我们忽略它在列表中的排名，它是列表中最受欢迎的库之一。GreenSock的速度和高效率是它受人喜爱的原因之一。这个强大的库也支持各式浏览器，并且没有任何依赖。</p><p><strong>安装:</strong></p><p>使用NPM，可以使用以下命令安装GreenSock JS。</p><p><strong>npm install gsap</strong></p><p>更多信息可从<a href="https://greensock.com/" target="_blank" rel="noopener">官方网站</a>或<a href="https://www.npmjs.com/package/gsap" target="_blank" rel="noopener">npm</a>获取。</p><h3><a href="https://github.com/michalsnik/aos" target="_blank" rel="noopener">AOS</a></h3><h4>6,613 ★</h4><p>因此，虽然本文中讨论的其它库大力依赖于JavaScript，但是AOS（Animate On Scroll）却更多地依赖于CSS。使用AOS，开发人员可以在向下滚动时为页面元素添加动画，然后在向上滚动时恢复之前的动画状态。这个库还附带了许多可由滚动事件触发的预定义事件。</p><p><strong>安装:</strong></p><p>使用NPM，可以使用以下命令安装Animate On Scroll。</p><p><strong>npm install aos</strong></p><p>更多信息可从<a href="https://michalsnik.github.io/aos/" target="_blank" rel="noopener">官方网站</a>或<a href="https://www.npmjs.com/package/aos" target="_blank" rel="noopener">npm</a>获取。</p><h3>总结</h3><p><img src="https://p0.ssl.qhimg.com/t011bb10673ad1f3fb3.png" alt=""></p><p>就这些了，十个用于创建精美动画的JavaScript库。您是否使用过这些库中的任意一个？是否在用户体验方面有些许建议？或者你认为这里应该列出哪些库，但没有？让我们来谈谈吧。</p><p><a href="https://dashbouquet.com/blog/frontend-development/blog/frontend-development/10-javascript-animation-libraries-to-follow-in-2018" target="_blank" rel="noopener"><strong>9 个最佳的JS图表库</strong></a></p><hr><p><a href="https://www.linkedin.com/in/anton-shaleynikov-45812a1/" target="_blank" rel="noopener">作者Anton Shaleynikov</a></p>          <h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/10-javascript-animation-libraries-to-follow-in-2018" target="_blank" rel="noopener">https://www.zcfy.cc/article/10-javascript-animation-libraries-to-follow-in-2018</a><br>原文标题: 2018年值得关注的10大JavaScript动画库<br>本文仅用于学习、研究和交流目的，欢迎非商业转载。转载请注明出处、完整链接。<br>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，<br>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/fd528aee/">https://alili.tech/archive/fd528aee/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现代网站客户端提供了高质量的动画，导致了JavaScript动画库的需求不断增加。幸运的是，供应似乎与需求相匹配，且有多种选择。至于选择哪一个就难以定夺了。在这一年里，许多动画库有可能完善得更好，为创建动画提供更好的解决
      
    
    </summary>
    
      <category term="reprint" scheme="https://alili.tech/categories/reprint/"/>
    
    
  </entry>
  
  <entry>
    <title>任天堂Switch 6.0+ 系统菜单汉化</title>
    <link href="https://alili.tech/archive/b3ccb586/"/>
    <id>https://alili.tech/archive/b3ccb586/</id>
    <published>2018-10-15T11:02:36.000Z</published>
    <updated>2018-10-17T03:26:05.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任天堂Switch汉化补丁"><a href="#任天堂Switch汉化补丁" class="headerlink" title="任天堂Switch汉化补丁"></a>任天堂Switch汉化补丁</h1><ol><li>仅支持6.0 和6.0.1系统</li><li>简体中文/繁体中文</li><li>支持大气层、ReiNX、RajNX、SXOS（TXOS）</li></ol><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><h2 id="汉化安装器"><a href="#汉化安装器" class="headerlink" title="汉化安装器"></a>汉化安装器</h2><p>汉化安装器：<a href="https://share.weiyun.com/5hS1LSk" target="_blank" rel="noopener">https://share.weiyun.com/5hS1LSk</a>  （强烈推荐）</p><h2 id="覆盖版：（当安装器闪退时使用，覆盖前要把原来的文件删干净。）"><a href="#覆盖版：（当安装器闪退时使用，覆盖前要把原来的文件删干净。）" class="headerlink" title="覆盖版：（当安装器闪退时使用，覆盖前要把原来的文件删干净。）"></a>覆盖版：（当安装器闪退时使用，覆盖前要把原来的文件删干净。）</h2><p>简体中文：<a href="https://share.weiyun.com/59MqPxr" target="_blank" rel="noopener">https://share.weiyun.com/59MqPxr</a><br>繁体中文：<a href="https://share.weiyun.com/52w0vp8" target="_blank" rel="noopener">https://share.weiyun.com/52w0vp8</a></p><h2 id="ReiNX汉化专用版本："><a href="#ReiNX汉化专用版本：" class="headerlink" title="ReiNX汉化专用版本："></a>ReiNX汉化专用版本：</h2><p>完整支持汉化，已经修复DOOM和2K19的问题<br><a href="https://share.weiyun.com/58azYtc" target="_blank" rel="noopener">https://share.weiyun.com/58azYtc</a></p><p>源码来自<a href="https://github.com/Reisyukaku/ReiNX" target="_blank" rel="noopener">https://github.com/Reisyukaku/ReiNX</a></p><h1 id="地址覆盖"><a href="#地址覆盖" class="headerlink" title="地址覆盖"></a>地址覆盖</h1><ul><li>大气层覆盖到atmosphere/titles</li><li>ReiNX覆盖到ReiNX/titles</li><li>SXOS覆盖到sxos/titles</li></ul><h1 id="汉化安装器教程："><a href="#汉化安装器教程：" class="headerlink" title="汉化安装器教程："></a>汉化安装器教程：</h1><ol><li>首先，用读卡器把SD卡插入电脑。</li><li>打开SD卡的盘。</li><li>把Nintendo Switch系统汉化补丁.exe 放入卡内。</li><li>运行Nintendo Switch系统汉化补丁.exe</li><li>看提示选择。</li></ol><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="汉化影响游戏吗？"><a href="#汉化影响游戏吗？" class="headerlink" title="汉化影响游戏吗？"></a>汉化影响游戏吗？</h2><p>一般汉化导致游戏崩溃是文本出错的原因，新的汉化已经修复大部分的问题。当然实际效果仍需测试。</p><h2 id="5-1系统能用吗？"><a href="#5-1系统能用吗？" class="headerlink" title="5.1系统能用吗？"></a>5.1系统能用吗？</h2><p>虽然5.1系统安装6.0的汉化可以开机。但不保证稳定性。也不保证能用。</p><h2 id="安装程序打不开怎么办？"><a href="#安装程序打不开怎么办？" class="headerlink" title="安装程序打不开怎么办？"></a>安装程序打不开怎么办？</h2><p>安装<br><a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=48145" target="_blank" rel="noopener">Visual C++ Redistributable for Visual Studio 2015</a><br>安装程序不支持32位系统，所以用覆盖版就行。</p><h2 id="安装汉化后无法开机怎么办？"><a href="#安装汉化后无法开机怎么办？" class="headerlink" title="安装汉化后无法开机怎么办？"></a>安装汉化后无法开机怎么办？</h2><p>别急，卸载汉化即可，不会影响原系统。</p><h2 id="部分游戏崩溃的问题"><a href="#部分游戏崩溃的问题" class="headerlink" title="部分游戏崩溃的问题"></a>部分游戏崩溃的问题</h2><p>如果你的游戏本身打了汉化补丁，是有可能崩溃的（目前已知龙珠超宇宙2）。<br>部分游戏崩溃是破解工具本身的问题。比如SXOS2.0极不稳定。大气层某些游戏无法运行与存档。如果你用的是SXOS 2.xx ，运行XCI游戏有很大几率崩溃，应该与汉化无关。</p><p>SXOS (2.0, 2.0.1, 2.1) XCI游戏待机死机的问题如果你的游戏本身使用了汉化，待机很大几率死机。与系统汉化无关。</p><h2 id="关于6-0-1系统"><a href="#关于6-0-1系统" class="headerlink" title="关于6.0.1系统"></a>关于6.0.1系统</h2><p>根据测试，6.0.1系统没有对文本做改动，所以6.0的汉化是完全可以兼容的。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>文件拷贝不建议使用mac系统!!!<br>文件拷贝不建议使用mac系统!!!<br>文件拷贝不建议使用mac系统!!!</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.91wii.com/forum.php?mod=viewthread&amp;tid=96891&amp;extra=page%3D1&amp;page=1" target="_blank" rel="noopener">https://www.91wii.com/forum.php?mod=viewthread&amp;tid=96891&amp;extra=page%3D1&amp;page=1</a></p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/b3ccb586/">https://alili.tech/archive/b3ccb586/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;任天堂Switch汉化补丁&quot;&gt;&lt;a href=&quot;#任天堂Switch汉化补丁&quot; class=&quot;headerlink&quot; title=&quot;任天堂Switch汉化补丁&quot;&gt;&lt;/a&gt;任天堂Switch汉化补丁&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;仅支持6.0 和6.0.1系统&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="Game" scheme="https://alili.tech/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>Switch的NSP和XCI什么区别？</title>
    <link href="https://alili.tech/archive/150b3ba6/"/>
    <id>https://alili.tech/archive/150b3ba6/</id>
    <published>2018-10-14T11:02:36.000Z</published>
    <updated>2018-10-15T15:12:51.716Z</updated>
    
    <content type="html"><![CDATA[<p>最近在折腾Switch, 在游戏安装中出现了两种游戏格式,分别是</p><ul><li>xci</li><li>nsp</li></ul><h2 id="他们之间到底有什么区别"><a href="#他们之间到底有什么区别" class="headerlink" title="他们之间到底有什么区别?"></a>他们之间到底有什么区别?</h2><p>在实际使用中:<br>xci，扔到内存卡里就可以使用,<br>nsp，需要安装之后才能使用<br>简单理解就是，xci是绿色版软件（正确说应该是ISO），nsp是安装版软件。</p><p>因为xci相当于卡带，不需要安装，需要切换.<br>nsp相当于数字版，需要安装，安装完直接能玩</p><p>所有的DLC或者更新包之类的都是nsp格式.</p><p>当我们使用xci格式的软件的时候,想要安装更新升级包的时候,其实都是nsp格式的,直接安装nsp效果都是一样的.</p><p>平常使用中,我喜欢nsp,安装过后就可以直接打开软件了,不需要再切换一次.个人觉得使用nsp是一劳永逸的.</p><h2 id="关于汉化"><a href="#关于汉化" class="headerlink" title="关于汉化"></a>关于汉化</h2><p>其实都是可以汉化的.两种格式只有使用上的差别,其他的并没有差别.</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/150b3ba6/">https://alili.tech/archive/150b3ba6/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在折腾Switch, 在游戏安装中出现了两种游戏格式,分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xci&lt;/li&gt;
&lt;li&gt;nsp&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;他们之间到底有什么区别&quot;&gt;&lt;a href=&quot;#他们之间到底有什么区别&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Game" scheme="https://alili.tech/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>Alili Weekly 前端周刊 第二期</title>
    <link href="https://alili.tech/archive/dc884d5f/"/>
    <id>https://alili.tech/archive/dc884d5f/</id>
    <published>2018-10-11T16:00:00.000Z</published>
    <updated>2018-10-13T06:52:48.765Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/github_61.png" alt="Alili Weekly 前端周刊 第二期"></p><h2 id="JavaScript引擎基础：优化原型"><a href="#JavaScript引擎基础：优化原型" class="headerlink" title="JavaScript引擎基础：优化原型"></a><a href="https://www.zcfy.cc/article/javascript-engine-fundamentals-optimizing-prototypes" target="_blank" rel="noopener">JavaScript引擎基础：优化原型</a></h2><p>本文对所有 JavaScript 引擎中常见的一些关键基础内容进行了介绍——这不仅仅局限于 V8 引擎( <a href="https://twitter.com/v8js" target="_blank" rel="noopener">https://twitter.com/v8js</a> ) 。。作为一名 JavaScript 开发者，深入了解 JavaScript 引擎是如何… </p><p><code>JAVASCRIPT</code> <code>前端</code> <code>DOM</code> <code>程序员</code> <code>架构</code> </p><hr><h2 id="JavaScript-filter-方法全解析"><a href="#JavaScript-filter-方法全解析" class="headerlink" title="JavaScript .filter() 方法全解析"></a><a href="https://www.zcfy.cc/article/level-up-your-filter-game" target="_blank" rel="noopener">JavaScript .filter() 方法全解析</a></h2><p>.filter是一个内置的数组迭代方法，它接受一个“谓词（译者注: 指代一个过滤条件的函数）”，该“谓词”针对每个值进行调用，并返回一个符合该条件(“truthy值”)的数组。上面那句话包含了很多信息，让我们来逐一解答一下。“内置”只是意味… </p><p><code>JAVASCRIPT</code> <code>应用</code> <code>移动</code> <code>API</code> </p><hr><h2 id="离屏Canvas-—-使用Web-Worker提高你的Canvas运行速度"><a href="#离屏Canvas-—-使用Web-Worker提高你的Canvas运行速度" class="headerlink" title="离屏Canvas — 使用Web Worker提高你的Canvas运行速度"></a><a href="https://www.zcfy.cc/article/offscreencanvas-speed-up-your-canvas-operations-with-a-web-worker" target="_blank" rel="noopener">离屏Canvas — 使用Web Worker提高你的Canvas运行速度</a></h2><p>现在因为有了离屏Canvas，你可以不用在你的主线程中绘制图像了！Canvas 是一个非常受欢迎的表现方式，同时也是WebGL的入口。它能绘制图形，图片，展示动画，甚至是处理视频内容。它经常被用来在富媒体web应用中创建炫酷的用户界面或者是… </p><p><code>CANVAS</code> <code>DOM</code> <code>API</code> <code>移动</code> <code>应用</code> </p><hr><h2 id="（…）这三个点在JavaScript中意味着什么？"><a href="#（…）这三个点在JavaScript中意味着什么？" class="headerlink" title="（…）这三个点在JavaScript中意味着什么？"></a><a href="https://www.zcfy.cc/article/what-do-the-three-dots-mean-in-javascript" target="_blank" rel="noopener">（…）这三个点在JavaScript中意味着什么？</a></h2><p>这篇文章的标题来自我在Quora上被要求回答的一个问题。下面是我试图解释JavaScript中三个点的作用。希望这对于将来有相同问题的人来说可以消除围绕这个概念的迷雾。数组/对象扩展运算符。假设您有以下对象：假设您要创建一个具有不同名称和网… </p><p><code>JAVASCRIPT</code> <code>程序员</code> </p><hr><h2 id="2018年值得关注的10大JavaScript动画库"><a href="#2018年值得关注的10大JavaScript动画库" class="headerlink" title="2018年值得关注的10大JavaScript动画库"></a><a href="https://www.zcfy.cc/article/10-javascript-animation-libraries-to-follow-in-2018" target="_blank" rel="noopener">2018年值得关注的10大JavaScript动画库</a></h2><p>原文链接现代网站的客户端依靠高质量的动画，这就使得JavaScript动画库的需求不断增加。幸运的是，供应似乎与需求相匹配，并且有多种选择。至于选择哪一个就难以… </p><p><code>JAVASCRIPT</code> <code>NPM</code> <code>浏览器</code> <code>层叠样式表</code> <code>程序员</code> </p><hr><h2 id="Webpack-4-和单页应用入门"><a href="#Webpack-4-和单页应用入门" class="headerlink" title="Webpack 4 和单页应用入门"></a><a href="https://juejin.im/entry/5b63eb8bf265da0f98317441" target="_blank" rel="noopener">Webpack 4 和单页应用入门</a></h2><p>很详细的 Webpack 4 入门文章。Webpack 配置工程师们看过来。 </p><p><code>Webpack</code> <code>前端工程</code> </p><hr><h2 id="基于后编译的国际化解决方案"><a href="#基于后编译的国际化解决方案" class="headerlink" title="基于后编译的国际化解决方案"></a><a href="https://juejin.im/post/5b47148c518825196b01ca3a" target="_blank" rel="noopener">基于后编译的国际化解决方案</a></h2><p>本文主要介绍了作者在做国际化项目的过程中所遇到的问题以及所做的思考。 </p><p><code>i18n</code> <code>Vue</code> <code>JavaScript</code> <code>前端工程</code> </p><hr><h2 id="Webpack-中的-sideEffects-到底该怎么用？"><a href="#Webpack-中的-sideEffects-到底该怎么用？" class="headerlink" title="Webpack 中的 sideEffects 到底该怎么用？"></a><a href="https://zhuanlan.zhihu.com/p/40052192" target="_blank" rel="noopener">Webpack 中的 sideEffects 到底该怎么用？</a></h2><p>webpack v4 开始新增了一个 sideEffects 特性，通过给 package.json 加入 sideEffects 声明该包/模块是否包含副作用，从而可以为 tree-shaking 提供更大的优化空间。 </p><p><code>Webpack</code> </p><hr><h2 id="webpack在es6和less自动更新上的简单构建"><a href="#webpack在es6和less自动更新上的简单构建" class="headerlink" title="webpack在es6和less自动更新上的简单构建"></a><a href="https://www.zcfy.cc/article/webpack-made-simple-building-es6-less-with-autorefresh" target="_blank" rel="noopener">webpack在es6和less自动更新上的简单构建</a></h2><p>更新于2015年/11月/08 babel 6.0版本仅仅是一个开发工具包？克隆压缩 webpack-black-triangle 或是 Unicorn Standard Starter Kit的工作原理从ES2015 到es2016 已实… </p><p><code>WEBPACK</code> <code>JAVASCRIPT</code> <code>ECMASCRIPT 6</code> <code>浏览器</code> <code>NPM</code> </p><hr><h2 id="关于CSS变量你需要知道的一切"><a href="#关于CSS变量你需要知道的一切" class="headerlink" title="关于CSS变量你需要知道的一切"></a><a href="https://www.zcfy.cc/article/everything-you-need-to-know-about-css-variables" target="_blank" rel="noopener">关于CSS变量你需要知道的一切</a></h2><p>这是我新书的第一章（PDF和Mobi格式都有）。多数编程语言都支持变量。但是CSS从最初就一直缺少对原生变量的功能支持。你写CSS吧？那你就没办法用变量。不过，你还可以用Sass这样的预编译器。Sass这样的预编译器就把变量作为一个巨大的卖… </p><p><code>层叠样式表</code> <code>JAVASCRIPT</code> <code>浏览器</code> <code>移动</code> <code>应用</code> </p><hr><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/dc884d5f/">https://alili.tech/archive/dc884d5f/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/github_61.png&quot; alt=&quot;Alili Weekly 前端周刊 第二期&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;JavaScript引擎基础：优化原型&quot;&gt;&lt;a href=&quot;#JavaScript引擎基础：优化原型&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="前端周刊" scheme="https://alili.tech/tags/%E5%89%8D%E7%AB%AF%E5%91%A8%E5%88%8A/"/>
    
      <category term="Weekly" scheme="https://alili.tech/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>Nintendo Switch破解原理</title>
    <link href="https://alili.tech/archive/33fa548c/"/>
    <id>https://alili.tech/archive/33fa548c/</id>
    <published>2018-10-11T11:02:36.000Z</published>
    <updated>2018-10-16T02:00:11.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nintendo-Switch"><a href="#Nintendo-Switch" class="headerlink" title="Nintendo Switch"></a>Nintendo Switch</h1><p>Nintendo Switch ，是任天堂出品的电子游戏机 ，于2017年3月3日在日本、北美、欧洲和香港发售，同年12月1日在韩国与台湾发售。 拥有可拆卸控制器和可分离式主机，游戏载体使用了专用卡匣 。<br>主机处理器使用了NVIDIA定制的Tegra X1系统芯片 ，这是任天堂首次采用NVIDIA的系统芯片。<br>任天堂Switch主机的内置存储空间为32GB，可使用microSD进行扩充，最高支持microSDXC标准，最大支持2TB容量； 主机在初始系统1.0.0时只能支持到microSD标准，发售同日提供的系统2.0 .0更新使其可支持microSDXC标准。</p><h1 id="破解原理"><a href="#破解原理" class="headerlink" title="破解原理"></a>破解原理</h1><p>Nintendo Switch（任天堂switch） 的CPU使用的是Nvidia X1 T210的处理器，存在一个可进入的工程模式（Recovery Mode），简称RCM，<br>Nintendo Switch的右joycon连接口中隐藏着一个特殊金属引脚（pin10）。如果在开机时，按住音量键+，并且将这个引脚接地（pin1,7,9），Nintendo Switch就能进入工程模式（RCM），从而设法运行自制代码。</p><p>你可以在淘宝上轻易买到这个短接器。也可以通过锡纸，别针或者3D打印等很方便的制作。短接器的作用就是将这个特殊引脚接地。<br>由上可知， Nintendo Switch破解依赖的是基于Nvidia X1 T210的处理器的工程模式。注入（发射）特殊代码引导自制系统或程序。达成破解。</p><p>这个方法不会被封堵，普通的系统更新补并不会影响破解。无法通过软件层面封堵。因为工程模式启动的优先级高于系统。不论以后更新什么系统，进入RCM（工程模式是没有问题的），在即将到来的6.0版本，也只是更改了游戏文件的存储方式，变相的防范破解，目前TX1.9版本已经加入了破解。</p><p>正因为破解是基于开机短接进入工程模式的原理，在任意一次关机后，破解就会失效，需要重新进行破解。</p><h1 id="破解后可做什么，有没有什么问题"><a href="#破解后可做什么，有没有什么问题" class="headerlink" title="破解后可做什么，有没有什么问题"></a>破解后可做什么，有没有什么问题</h1><p>Nintendo Switch 的系统本质上可以看作是一个改版的LINUX的操作系统，.通过破解后，编译新的程序，可以Dump你手中的实体卡带游戏，导出存档，甚至可以看小说，听音乐，作为其他游戏主机的模拟器。玩破解游戏只是其中的一个功能。<br>所以，在放入存储卡时候，因为系统格式化的不同，也会存在一次升级的情况，这是由于不同系统对于文件存储分区的逻辑不同导致的。</p><p>扩展阅读：破解后您可以安装一个真正的发行版的Linux系统Lakka，</p><p>着力推荐国内开发者的Lakka系统，这是独立于国外的一个项目，让我们感谢他。<br>最强模拟器系统 lakka修改模拟游戏分辨率和纹理和安装教程<br><a href="https://www.91wii.com/thread-96053-1-1.html" target="_blank" rel="noopener">https://www.91wii.com/thread-96053-1-1.html</a></p><h1 id="关于BAN机"><a href="#关于BAN机" class="headerlink" title="关于BAN机"></a>关于BAN机</h1><p>由于任天堂在联网时会验证游戏文件头（每个游戏的文件头都是唯一的），所以玩破解游戏，修改存档等，都会导致被Ban，目前主要体现为两种，<br>普通BAN：具体的表现为无法联机游戏，无法进Eshop（商店），同时会由错误代码出现，但是目前游戏正常更新（例如更新中文语言）并不受影响。您可以理解为Ban机是限制了网络功能。<br>更为严厉的ban机措施，大家称之为Super Ban，具体的表现为联网后出现错误代码2137-7403，同时主机无法更新，游戏和dlc也无法更新，也就说，任天堂将你的主机序列号加入黑名单，直接断开所有同任天堂的联系。</p><p>您可以破解之后，进行系统备份。但目前已经出现有朋友因为不熟悉备份恢复流程变砖，所以这里不放链接，如果您要做这个事情， 记得“一机一码”，自己的备份文件只能自己用，不能用别人的。同时恢复分区的时候，要留意不要恢复错的文件，一旦误操作，是不可恢复的变砖。</p><p>我更建议，破解后断开网络，等要联网之前，重置主机再联网，可以大概率从正。这个风险较小。</p><h1 id="破解方式"><a href="#破解方式" class="headerlink" title="破解方式"></a>破解方式</h1><p>目前，Nintendo Switch的破解存在两个大的分支。<br>一类是免费的大气层/REI/破解TX安装器等。此类只能支持NSP格式游戏安装。略微复杂<br>一类是收费的TX OS。此类支持卡带DUPM出来的XCI格式，同时支持NSP安装。</p><p>因为代码公开，所以破解方式也变得逐渐多样化，希望您了解具体原理，而不是纠结于具体哪种破解方式，大致来说，论坛中简单热门的就是最好的破解方式。论坛中有不少不错的整合包，您可以任选其一进行安装。</p><p>参考资料: <a href="https://www.91wii.com/thread-93105-1-1.html" target="_blank" rel="noopener">https://www.91wii.com/thread-93105-1-1.html</a></p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/33fa548c/">https://alili.tech/archive/33fa548c/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nintendo-Switch&quot;&gt;&lt;a href=&quot;#Nintendo-Switch&quot; class=&quot;headerlink&quot; title=&quot;Nintendo Switch&quot;&gt;&lt;/a&gt;Nintendo Switch&lt;/h1&gt;&lt;p&gt;Nintendo Switch ，是
      
    
    </summary>
    
    
      <category term="Game" scheme="https://alili.tech/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>使用Eggjs(koa) &amp; web3.js开发你的以太坊Dapp</title>
    <link href="https://alili.tech/archive/69a6fd18/"/>
    <id>https://alili.tech/archive/69a6fd18/</id>
    <published>2018-10-10T11:33:33.000Z</published>
    <updated>2018-10-10T06:33:22.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Eggjs"><a href="#Eggjs" class="headerlink" title="Eggjs"></a>Eggjs</h1><p>Eggjs 是阿里开源的企业级基于Koa2的Node.js框架.<br>eggjs基本上是开箱即用,奉行『约定优于配置』.在日常开发中,用起来非常顺畅.<br>而且生态也比较完善,koa2的插件都可以对接到框架中来.</p><h2 id="Egg-js-目录结构"><a href="#Egg-js-目录结构" class="headerlink" title="Egg.js 目录结构"></a>Egg.js 目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">egg-project</span><br><span class="line">├── package.json</span><br><span class="line">├── app.js (可选)</span><br><span class="line">├── agent.js (可选)</span><br><span class="line">├── app</span><br><span class="line">|   ├── router.js</span><br><span class="line">│   ├── controller</span><br><span class="line">│   |   └── home.js</span><br><span class="line">│   ├── service (可选)</span><br><span class="line">│   |   └── user.js</span><br><span class="line">│   ├── middleware (可选)</span><br><span class="line">│   |   └── response_time.js</span><br><span class="line">│   ├── schedule (可选)</span><br><span class="line">│   |   └── my_task.js</span><br><span class="line">│   ├── public (可选)</span><br><span class="line">│   |   └── reset.css</span><br><span class="line">│   ├── view (可选)</span><br><span class="line">│   |   └── home.tpl</span><br><span class="line">│   └── extend (可选)</span><br><span class="line">│       ├── helper.js (可选)</span><br><span class="line">│       ├── request.js (可选)</span><br><span class="line">│       ├── response.js (可选)</span><br><span class="line">│       ├── context.js (可选)</span><br><span class="line">│       ├── application.js (可选)</span><br><span class="line">│       └── agent.js (可选)</span><br><span class="line">├── config</span><br><span class="line">|   ├── plugin.js</span><br><span class="line">|   ├── config.default.js</span><br><span class="line">│   ├── config.prod.js</span><br><span class="line">|   ├── config.test.js (可选)</span><br><span class="line">|   ├── config.local.js (可选)</span><br><span class="line">|   └── config.unittest.js (可选)</span><br><span class="line">└── <span class="built_in">test</span></span><br><span class="line">    ├── middleware</span><br><span class="line">    |   └── response_time.test.js</span><br><span class="line">    └── controller</span><br><span class="line">        └── home.test.js</span><br></pre></td></tr></table></figure><p>如上，由框架约定的目录：</p><ul><li><code>app/router.js</code> 用于配置 URL 路由规则。</li><li><code>app/controller/**</code> 用于解析用户的输入，处理后返回相应的结果。</li><li><code>app/service/**</code> 用于编写业务逻辑层，可选，建议使用。</li><li><code>app/middleware/**</code> 用于编写中间件，可选。</li><li><code>app/public/**</code> 用于放置静态资源，可选，具体参见内置插件 <a href="https://github.com/eggjs/egg-static" target="_blank" rel="noopener">egg-static</a>。</li><li><code>app/extend/**</code> 用于框架的扩展，可选。</li><li><code>config/config.{env}.js</code> 用于编写配置文件。</li><li><code>config/plugin.js</code> 用于配置需要加载的插件。</li><li><code>test/**</code> 用于单元测试。</li><li><code>app.js</code> 和 <code>agent.js</code> 用于自定义启动时的初始化工作，可选。</li></ul><p>由内置插件约定的目录：</p><ul><li><code>app/public/**</code> 用于放置静态资源，可选，具体参见内置插件 <a href="https://github.com/eggjs/egg-static" target="_blank" rel="noopener">egg-static</a>。</li><li><code>app/schedule/**</code> 用于定时任务，可选。</li></ul><p><strong>若需自定义自己的目录规范，参见 <a href="https://eggjs.org/zh-cn/advanced/loader.html" target="_blank" rel="noopener">Loader API</a></strong></p><ul><li><code>app/view/**</code> 用于放置模板文件，可选，由模板插件约定。</li><li><code>app/model/**</code> 用于放置领域模型，可选，由领域类相关插件约定，如 <a href="https://github.com/eggjs/egg-sequelize" target="_blank" rel="noopener">egg-sequelize</a>。</li></ul><h1 id="web3-js"><a href="#web3-js" class="headerlink" title="web3.js"></a>web3.js</h1><p>为了让你的DAPP能够访问区块链上的数据，一种选择是使用web3.js提供的web3对象。底层实现上，它通过RPC 调用与本地节点通信。web3.js可以与任何暴露了RPC接口的区块链节点连接。</p><h1 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h1><p>在egg.js 自定义启动方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.beforeStart(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; config &#125; = app;</span><br><span class="line">    <span class="keyword">let</span> originWeb3;</span><br><span class="line">    <span class="comment">// web3 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> originWeb3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">"Using web3 detected from external source. If you find that your accounts don't appear or you have 0 MetaCoin, ensure you've configured that source properly. If using MetaMask, see the following link. Feel free to delete this warning. :) http://truffleframework.com/tutorials/truffle-and-metamask"</span>);</span><br><span class="line">      <span class="comment">// Use Mist/MetaMask's provider</span></span><br><span class="line">      originWeb3 = <span class="keyword">new</span> Web3(originWeb3.currentProvider);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`No web3 detected. Falling back to http://<span class="subst">$&#123;config.web3.host&#125;</span>:<span class="subst">$&#123;config.web3.port&#125;</span>. You should remove this fallback when you deploy live, as it\'s inherently insecure. Consider switching to Metamask for development. More info here: http://truffleframework.com/tutorials/truffle-and-metamask`</span>);</span><br><span class="line">      <span class="comment">// fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail)</span></span><br><span class="line">      originWeb3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">`http://<span class="subst">$&#123;config.web3.host&#125;</span>:<span class="subst">$&#123;config.web3.port&#125;</span>`</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把web3js挂载到app下</span></span><br><span class="line">    app.web3 = originWeb3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个上下文,用来调用service的方法</span></span><br><span class="line">    <span class="keyword">const</span> ctx = app.createAnonymousContext();</span><br><span class="line">    app.cities = <span class="keyword">await</span> ctx.service.connection.getAdmin();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="Service层调用智能合约"><a href="#Service层调用智能合约" class="headerlink" title="Service层调用智能合约"></a>Service层调用智能合约</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/service/</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">'egg'</span>).Service;</span><br><span class="line"><span class="keyword">const</span> contract = <span class="built_in">require</span>(<span class="string">'truffle-contract'</span>);</span><br><span class="line"><span class="comment">// 引入只能合约</span></span><br><span class="line"><span class="keyword">const</span> stock_artifact = <span class="built_in">require</span>(<span class="string">'../../build/contracts/Stock.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接合约</span></span><br><span class="line"><span class="keyword">const</span> Stock = contract(stock_artifact);</span><br><span class="line"><span class="keyword">let</span> adminAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meta;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">    <span class="keyword">this</span>.web3 = <span class="keyword">this</span>.app.web3;</span><br><span class="line">  &#125;</span><br><span class="line">  setProvider() &#123;</span><br><span class="line">    Stock.setProvider(<span class="keyword">this</span>.web3.currentProvider);</span><br><span class="line">    <span class="comment">// 解决apply报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> Stock.currentProvider.sendAsync !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      Stock.currentProvider.sendAsync = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stock.currentProvider.send.apply(</span><br><span class="line">          Stock.currentProvider, <span class="built_in">arguments</span></span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getAccounts() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setProvider();</span><br><span class="line">      <span class="comment">// Get the initial account balance so it can be displayed.</span></span><br><span class="line">      <span class="comment">// 使用web3.js 与只能合约交互</span></span><br><span class="line">      <span class="keyword">this</span>.web3.eth.getAccounts(<span class="function"><span class="keyword">function</span>(<span class="params">err, accs</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'There was an error fetching your accounts.'</span>);</span><br><span class="line">          reject(<span class="string">'There was an error fetching your accounts.'</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (accs.length === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"Couldn't get any accounts! Make sure your Ethereum client is configured correctly."</span>);</span><br><span class="line">          reject(<span class="string">"Couldn't get any accounts! Make sure your Ethereum client is configured correctly."</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.accounts = accs;</span><br><span class="line">        resolve(<span class="keyword">this</span>.accounts);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getBalance(account) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setProvider();</span><br><span class="line">      Stock.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">        meta = instance;</span><br><span class="line">        <span class="keyword">return</span> meta.getBalance.call(account, &#123; <span class="attr">from</span>: adminAddress &#125;);</span><br><span class="line">      &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">          shareLotsLength: value[<span class="number">0</span>],</span><br><span class="line">          total: value[<span class="number">1</span>],</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(e);</span><br><span class="line">          reject(<span class="string">'Error 404'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加用户</span></span><br><span class="line">  <span class="keyword">async</span> addMember(address, name, empNo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.adminAddress) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">this</span>.getAdmin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setProvider();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      Stock.deployed().then(<span class="function"><span class="params">instance</span> =&gt;</span> &#123;</span><br><span class="line">        meta = instance;</span><br><span class="line">        <span class="keyword">return</span> meta.addMember(address, name, <span class="built_in">Number</span>(empNo), &#123; <span class="attr">from</span>: adminAddress || <span class="string">'0x0000000000000000000000000000000000000000'</span> &#125;);</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="string">'not found'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; value.logs.length; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> log = value.logs[i];</span><br><span class="line">          <span class="keyword">if</span> (log.event === <span class="string">'addmember'</span>) &#123;</span><br><span class="line">            args = log.args;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(args);</span><br><span class="line">      &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(e);</span><br><span class="line">          reject(<span class="string">'add Member error'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">      ;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取用户</span></span><br><span class="line">  getAdmin() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setProvider();</span><br><span class="line">      Stock.deployed().then(<span class="function"><span class="params">instance</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance.getAdmin.call();</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        adminAddress = value;</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(e);</span><br><span class="line">          reject(<span class="string">'getAdmin error'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ConnectionService;</span><br></pre></td></tr></table></figure><p>完整Demo:  <a href="https://github.com/Fantasy9527/egg-block-chain" target="_blank" rel="noopener">https://github.com/Fantasy9527/egg-block-chain</a></p><h1 id="Demo-使用方法"><a href="#Demo-使用方法" class="headerlink" title="Demo 使用方法"></a>Demo 使用方法</h1><h3 id="全局安装truffle"><a href="#全局安装truffle" class="headerlink" title="全局安装truffle"></a>全局安装truffle</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br></pre></td></tr></table></figure><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转移</span></span><br><span class="line">truffle migrate </span><br><span class="line"></span><br><span class="line"><span class="comment">#编译合约</span></span><br><span class="line">truffle compile</span><br></pre></td></tr></table></figure><h3 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm i</span><br><span class="line">$ npm run dev</span><br><span class="line">$ open http://localhost:7001/</span><br></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br><span class="line">$ npm stop</span><br></pre></td></tr></table></figure><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/69a6fd18/">https://alili.tech/archive/69a6fd18/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Eggjs&quot;&gt;&lt;a href=&quot;#Eggjs&quot; class=&quot;headerlink&quot; title=&quot;Eggjs&quot;&gt;&lt;/a&gt;Eggjs&lt;/h1&gt;&lt;p&gt;Eggjs 是阿里开源的企业级基于Koa2的Node.js框架.&lt;br&gt;eggjs基本上是开箱即用,奉行『约定优于配
      
    
    </summary>
    
    
      <category term="区块链" scheme="https://alili.tech/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Alili Weekly 前端周刊 第一期</title>
    <link href="https://alili.tech/archive/ec9ea187/"/>
    <id>https://alili.tech/archive/ec9ea187/</id>
    <published>2018-10-04T16:00:00.000Z</published>
    <updated>2018-10-12T13:36:43.536Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/github_31.png" alt=""></p><h2 id="用微前端的方式搭建类单页应用"><a href="#用微前端的方式搭建类单页应用" class="headerlink" title="用微前端的方式搭建类单页应用"></a><a href="https://juejin.im/post/5b921b415188255c9031b0c3" target="_blank" rel="noopener">用微前端的方式搭建类单页应用</a></h2><p>本文介绍了“微前端构建类单页应用”在美团 HR 系统中的实践。 </p><p><code>奇舞推荐</code> <code>微前端</code> </p><hr><h2 id="引言·-2018年前端开发工作手册"><a href="#引言·-2018年前端开发工作手册" class="headerlink" title="引言· 2018年前端开发工作手册"></a><a href="https://www.zcfy.cc/article/introduction-front-end-developer-handbook-2018" target="_blank" rel="noopener">引言· 2018年前端开发工作手册</a></h2><p>Introduction什么是前端开发人员?2017年度前端开发回顾。即将在2018的发生前端故事…第一部分：前端实践。前端开发相关职位。前端开发基础知识。前端开发进阶知识。前端程序运行环境一览。在一个团队里前端开发的角色。全栈大神。前… </p><p><code>前端</code> <code>JAVASCRIPT</code> <code>程序员</code> <code>移动</code> <code>API</code> </p><hr><h2 id="JavaScript-Functions详解（包含ES6箭头函数）"><a href="#JavaScript-Functions详解（包含ES6箭头函数）" class="headerlink" title="JavaScript Functions详解（包含ES6箭头函数）"></a><a href="https://www.zcfy.cc/article/javascript-functions" target="_blank" rel="noopener">JavaScript Functions详解（包含ES6箭头函数）</a></h2><p>简介。JavaScript中的所有内容都发生在函数中。函数是一个代码块，可以定义一次并随时运行。函数可以选择接受参数，并返回一个值。JavaScript中的函数是对象，一种特殊的对象：函数对象。另外，函数被称为第一类函数，因为它们可以被赋值… </p><p><code>JAVASCRIPT</code> <code>ECMASCRIPT 6</code> <code>移动</code> </p><hr><h2 id="JavaScript循环和作用域"><a href="#JavaScript循环和作用域" class="headerlink" title="JavaScript循环和作用域"></a><a href="https://www.zcfy.cc/article/javascript-loops-and-scope" target="_blank" rel="noopener">JavaScript循环和作用域</a></h2><p>JavaScript有一个特点，也许会让开发者头痛, 是与循环和作用域相关的.举个例子:它基本是循环了5次，将一个函数添加到operations数组里面。这个函数可打印出循环变量索引值i.运行这些函数后期望的结果应该是:但实际发生的是这样的… </p><p><code>JAVASCRIPT</code> <code>程序员</code> <code>ECMASCRIPT 6</code> </p><hr><h2 id="写给工程师的十条精进原则"><a href="#写给工程师的十条精进原则" class="headerlink" title="写给工程师的十条精进原则"></a><a href="https://juejin.im/post/5b762bace51d45556f41c431" target="_blank" rel="noopener">写给工程师的十条精进原则</a></h2><p>“以原则为中心地工作与生活，让自己与团队变得更加强大。” </p><p><code>奇舞推荐</code> <code>职业</code> </p><hr><h2 id="滚动视差？CSS-不在话下"><a href="#滚动视差？CSS-不在话下" class="headerlink" title="滚动视差？CSS 不在话下"></a><a href="http://www.cnblogs.com/coco1s/p/9453938.html" target="_blank" rel="noopener">滚动视差？CSS 不在话下</a></h2><p>主要介绍 Parallax Scrolling 的几种实现方式。 </p><p><code>奇舞推荐</code> <code>CSS</code> <code>Parallax Scrolling</code> </p><hr><h2 id="深入理解-TypeScript"><a href="#深入理解-TypeScript" class="headerlink" title="深入理解 TypeScript"></a><a href="https://jkchao.github.io/typescript-book-chinese" target="_blank" rel="noopener">深入理解 TypeScript</a></h2><p>《TypeScript Deep Dive》中文翻译版。 </p><p><code>TypeScript</code> </p><hr><h2 id="Webpack-4-配置最佳实践"><a href="#Webpack-4-配置最佳实践" class="headerlink" title="Webpack 4 配置最佳实践"></a><a href="https://github.com/ProtoTeam/blog/blob/master/201806/3.md" target="_blank" rel="noopener">Webpack 4 配置最佳实践</a></h2><p>本文的重点在：Webpack 4 在配置上带来了哪些便利？要迁移需要修改配置文件的哪些内容？之前的 Webpack 配置最佳实践在 Webpack 4 这个版本，还适用吗？ </p><p><code>Webpack</code> </p><hr><h2 id="JavaScript中的this"><a href="#JavaScript中的this" class="headerlink" title="JavaScript中的this"></a><a href="https://www.zcfy.cc/article/this-in-javascript" target="_blank" rel="noopener">JavaScript中的this</a></h2><p>this 在不同的地方被调用有不同的值。不知道这些细节可能会导致很多头疼的问题, 所以你不妨花5分钟的时间来了解一下这些坑。this 在严格模式下。除了在声明的对象内被调用, this 在 严格模式下 永远是 undefined。注意我提到… </p><p><code>JAVASCRIPT</code> <code>浏览器</code> <code>DOM</code> <code>HTML</code> </p><hr><h2 id="在你的下一个Web应用中使用Vue-js的三个理由"><a href="#在你的下一个Web应用中使用Vue-js的三个理由" class="headerlink" title="在你的下一个Web应用中使用Vue.js的三个理由"></a><a href="https://www.zcfy.cc/article/3-reasons-to-use-vue-js-in-your-next-web-project" target="_blank" rel="noopener">在你的下一个Web应用中使用Vue.js的三个理由</a></h2><p>Vue.js是那么地易上手，它在提供了大量开箱即用的功能的同时也提供了良好的性能。请继续阅读以下事例及代码片段以便更加了解Vue.js。选择一个JavaScript框架真是太难了——因为有太多的框架可以供我们使用，并且它们之间的差距并不是很… </p><p><code>VUE.JS</code> <code>JAVASCRIPT</code> <code>移动</code> <code>应用</code> <code>DOM</code> </p><hr><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/ec9ea187/">https://alili.tech/archive/ec9ea187/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/github_31.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;用微前端的方式搭建类单页应用&quot;&gt;&lt;a href=&quot;#用微前端的方式搭建类单页应用&quot; class=&quot;headerlink&quot; title=&quot;用微前端的方式搭建类单页应用&quot;&gt;
      
    
    </summary>
    
    
      <category term="前端周刊" scheme="https://alili.tech/tags/%E5%89%8D%E7%AB%AF%E5%91%A8%E5%88%8A/"/>
    
      <category term="Weekly" scheme="https://alili.tech/tags/Weekly/"/>
    
  </entry>
  
  <entry>
    <title>2018年10月国内浏览器数据统计</title>
    <link href="https://alili.tech/archive/4a50d81d/"/>
    <id>https://alili.tech/archive/4a50d81d/</id>
    <published>2018-09-30T16:00:00.000Z</published>
    <updated>2018-10-06T22:55:46.914Z</updated>
    
    <content type="html"><![CDATA[<div id="echarts178" style="width: 100%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts178'));        // 指定图表的配置项和数据        var option = {"textStyle":{"color":"#fff"},"title":{"text":"2018年10月国内浏览器数据统计","subtext":"浏览器数据分析","x":"center","textStyle":{"color":"#fff"}},"tooltip":{"trigger":"item","formatter":"{a} <br/>{b} : {c} ({d}%)"},"legend":{"type":"scroll","orient":"vertical","right":10,"top":120,"bottom":20,"data":["Chrome","IE 9.0","IE 11.0","2345","QQ","IE 8.0","搜狗高速","Safari","Firefox","其他"],"textStyle":{"color":"#fff"}},"series":[{"name":"浏览器用户比例","type":"pie","radius":"55%","center":["50%","60%"],"data":[{"name":"Chrome","value":47.08},{"name":"IE 9.0","value":7.89},{"name":"IE 11.0","value":5.97},{"name":"2345","value":5.9},{"name":"QQ","value":5.88},{"name":"IE 8.0","value":5.59},{"name":"搜狗高速","value":4.68},{"name":"Safari","value":2.43},{"name":"Firefox","value":2.42},{"name":"其他","value":12.16}],"itemStyle":{"emphasis":{"shadowBlur":10,"shadowOffsetX":0,"shadowColor":"rgba(0, 0, 0, 0.5)"}}}]}        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/4a50d81d/">https://alili.tech/archive/4a50d81d/</a> <p></p><div><h1>相关文章</h1><ul><li><a href="https://alili.tech/archive/c25273ee/">2018年09月国内浏览器数据统计</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;echarts178&quot; style=&quot;width: 100%;height: 400px;margin: 0 auto&quot;&gt;&lt;/div&gt;
&lt;script src=&quot;https://cdn.bootcss.com/echarts/3.8.0/echarts.comm
      
    
    </summary>
    
    
      <category term="Data analysis" scheme="https://alili.tech/tags/Data-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Centos7环境下启动Upsource失败解决办法</title>
    <link href="https://alili.tech/archive/66c1c154/"/>
    <id>https://alili.tech/archive/66c1c154/</id>
    <published>2018-09-29T11:33:33.000Z</published>
    <updated>2018-10-06T23:25:45.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>Centos7环境下启动Upsource的时候出现以下报错,我在Mac上启动upsource的时候一切正常.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Upsource Error] Failed to start JetBrains Upsource 2018.2 due to unexpected exception: Native random generator does not seem to have enough entropy for JetBrains Upsource 2018.2 to start. [Upsource Error] You can fix it by switching to PRNG (with -Djava.security.egd=/dev/zrandom) or by reconfiguring your operation system to provide more random bits.12</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>复制 upsource.jvmoptions.dist ==&gt; upsource.jvmoptions</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="variable">$upsource_path</span>/conf/upsource.jvmoptions.dist <span class="variable">$upsource_path</span>/conf/upsource.jvmoptions</span><br></pre></td></tr></table></figure><ol start="2"><li>编辑 $upsource_path/conf/upsource.jvmoptions文件,最后一行加上:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.egd=/dev/zrandom</span><br></pre></td></tr></table></figure><ol start="3"><li>启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$upsource_path</span>/bin/upsource.sh start</span><br></pre></td></tr></table></figure><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/66c1c154/">https://alili.tech/archive/66c1c154/</a> <p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;报错&quot;&gt;&lt;a href=&quot;#报错&quot; class=&quot;headerlink&quot; title=&quot;报错&quot;&gt;&lt;/a&gt;报错&lt;/h2&gt;&lt;p&gt;Centos7环境下启动Upsource的时候出现以下报错,我在Mac上启动upsource的时候一切正常.&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="Upsource" scheme="https://alili.tech/tags/Upsource/"/>
    
  </entry>
  
  <entry>
    <title>利用ngrok给你的机器打个洞 - 内网穿透</title>
    <link href="https://alili.tech/archive/df8d5e8d/"/>
    <id>https://alili.tech/archive/df8d5e8d/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2018-10-06T23:12:40.101Z</updated>
    
    <content type="html"><![CDATA[<p>我有很多自己的个人代码是跑在家里的服务器中的.一般来说都是自动化的处理我的一些生活问题,与数据收集等相关活动.<br>所以一般没有客户端访问家里服务器的需求.<br>但是很多时候脑子突发奇想.有一些小点子,一些小的bug或者小的优化,代码修改完成之后,有一个部署到需求.<br>因为家里服务器没有一个稳定的外网IP的,外网不能直接连接服务器.<br>所以我们需要 <code>内网穿透</code>.</p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><p>家里用的是小米路由器,小米路由器里面集成了花生壳,理论上是可以做到内网穿透的.无奈的是,一直都没有配置成功过.</p><p>网上找过很多内网穿透的工具:</p><ul><li>花生壳</li><li>NAT</li><li>frp</li><li>ngrok</li><li>localtunnel</li></ul><h2 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h2><p>选择ngrok的原因很简单,配置方便,并且支持tcp协议.<br>支持tcp协议代表,我可以直接在外面用SSH来访问家里的机器.</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol><li>首先你需要去<a href="https://ngrok.com/" target="_blank" rel="noopener">官网</a>注册一个账号</li><li>下载ngrok,并且解压到一个你喜欢的目录下面</li><li>去官网复制你的授权码</li><li>授权ngrok</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrok authtoken 授权码</span><br></pre></td></tr></table></figure><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrok http 8080</span><br></pre></td></tr></table></figure><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrok tcp 22</span><br></pre></td></tr></table></figure><p><img src="https://ngrok.com/static/img/ngrok-demo-static.png" alt=""></p><p>最终你会得到,一个外网可以访问的地址.<br>用这个地址就可以直接访问到你本机的端口了.</p><p>当我们拥有这样一个公网地址之后,我们就可以ssh来控制家里的机器<br>或者使用github的webhook来做一切你想要做的事情.</p><p></p><h1> 本文链接：</h1> <a href="https://alili.tech/archive/df8d5e8d/">https://alili.tech/archive/df8d5e8d/</a> <p></p><div><h1>相关文章</h1><ul><li><a href="https://alili.tech/archive/ef96a5b6/">Network笔记整理 - 网络协议与网络分层</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我有很多自己的个人代码是跑在家里的服务器中的.一般来说都是自动化的处理我的一些生活问题,与数据收集等相关活动.&lt;br&gt;所以一般没有客户端访问家里服务器的需求.&lt;br&gt;但是很多时候脑子突发奇想.有一些小点子,一些小的bug或者小的优化,代码修改完成之后,有一个部署到需求.&lt;b
      
    
    </summary>
    
    
      <category term="Network" scheme="https://alili.tech/tags/Network/"/>
    
  </entry>
  
</feed>
