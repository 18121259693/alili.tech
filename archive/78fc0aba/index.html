<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta itemprop="description" content="$(function(){ var html = &#34;\n\n \n\x3cblockquote\x3e抽象语法树（AST），是一个非常基础而重要的知识点，但国内的文档却几乎一片空白。\x3cp\x3e本文将带大家从底层了解AST,并且通过发布一个小型前端工具，来带大家了解AST的强大功能\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3eJavascript就像一台精妙运作的机器，我们可以用它来完成一切天马行空的构思。\x3c\/p\x3e\n\x3cp\x3e我们对javascript生态了如指掌，却常忽视javascript本身。这台机器，究竟是哪些零部件在支持着它运行？\x3c\/p\x3e\n\x3cp\x3eAST在日常业务中也许很难涉及到，但当你不止于想做一个工程师，而想做工程师的工程师，写出vue、react之类的大型框架，或类似webpack、vue-cli前端自动化的工具，或者有批量修改源码的工程需求，那你必须懂得AST。AST的能力十分强大，且能帮你真正吃透javascript的语言精髓。\x3c\/p\x3e\n\x3cp\x3e事实上，在javascript世界中，你可以认为抽象语法树(AST)是最底层。 再往下，就是关于转换和编译的“黑魔法”领域了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e人生第一次拆解Javascript\x3c\/h2\x3e\n\x3cp\x3e小时候，当我们拿到一个螺丝刀和一台机器，人生中最令人怀念的梦幻时刻便开始了：\x3c\/p\x3e\n\x3cp\x3e我们把机器，拆成一个一个小零件，一个个齿轮与螺钉，用巧妙的机械原理衔接在一起...\x3c\/p\x3e\n\x3cp\x3e当我们把它重新照不同的方式组装起来，这时，机器重新又跑动了起来——世界在你眼中如获新生。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016231515?w=658\x26amp;h=658\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000016231515?w=658\x26amp;h=658\x22 alt=\x22image\x22 title=\x22image\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e通过抽象语法树解析，我们可以像童年时拆解玩具一样，透视Javascript这台机器的运转，并且重新按着你的意愿来组装。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 现在，我们拆解一个简单的add函数\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function add(a, b) {\n return a \x2b b\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n \x3c\/div\x3e\n \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3efunction add(\x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e, b) {\n return \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先，我们拿到的这个语法块，是一个FunctionDeclaration(函数定义)对象。\x3c\/p\x3e\n\x3cp\x3e用力拆开，它成了三块：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e一个id，就是它的名字，即add\x3c\/li\x3e\n\x3cli\x3e两个params，就是它的参数，即[a, b]\x3c\/li\x3e\n\x3cli\x3e一块body，也就是大括号内的一堆东西\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eadd没办法继续拆下去了，它是一个最基础Identifier（标志）对象，用来作为函数的唯一标志，就像人的姓名一样。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n name: \x27add\x27\n type: \x27identifier\x27\n ."><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content=""><meta property="og:site_name" content="Alili"><meta name="generator" content="Hugo 0.51"><title>AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/meslo-LG/styles.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error",function(e){var t=e.target;"img"==t.tagName.toLowerCase()&&(t.style.display="none")},!0)</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/78fc0aba/",
				"appid": "1613049289050283", 
				"title": "AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-11-16T10:31:17"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">Previous post</span> <span id="i-next" class="info" style="display:none">Next post</span> <span id="i-top" class="info" style="display:none">Back to top</span> <span id="i-share" class="info" style="display:none">Share post</span></span><br><div id="share" style="display:none"></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文链接">原文链接</a></li><li><a href="#原文标题">原文标题</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my4"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解</h1><div class="meta"><div class="postdate"><time datetime="2018-10-22" itemprop="datePublished">2018-10-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div>| 2614字<div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="row"><script>$(function(){var s='\n\n                    \n<blockquote>抽象语法树（AST），是一个非常基础而重要的知识点，但国内的文档却几乎一片空白。<p>本文将带大家从底层了解AST,并且通过发布一个小型前端工具，来带大家了解AST的强大功能</p>\n</blockquote>\n<p>Javascript就像一台精妙运作的机器，我们可以用它来完成一切天马行空的构思。</p>\n<p>我们对javascript生态了如指掌，却常忽视javascript本身。这台机器，究竟是哪些零部件在支持着它运行？</p>\n<p>AST在日常业务中也许很难涉及到，但当你不止于想做一个工程师，而想做工程师的工程师，写出vue、react之类的大型框架，或类似webpack、vue-cli前端自动化的工具，或者有批量修改源码的工程需求，那你必须懂得AST。AST的能力十分强大，且能帮你真正吃透javascript的语言精髓。</p>\n<p>事实上，在javascript世界中，你可以认为抽象语法树(AST)是最底层。 再往下，就是关于转换和编译的“黑魔法”领域了。</p>\n<h2 id="articleHeader0">人生第一次拆解Javascript</h2>\n<p>小时候，当我们拿到一个螺丝刀和一台机器，人生中最令人怀念的梦幻时刻便开始了：</p>\n<p>我们把机器，拆成一个一个小零件，一个个齿轮与螺钉，用巧妙的机械原理衔接在一起...</p>\n<p>当我们把它重新照不同的方式组装起来，这时，机器重新又跑动了起来——世界在你眼中如获新生。</p>\n<p><span class="img-wrap"><img src="https://static.alili.tech/img/remote/1460000016231515?w=658&amp;h=658" src="https://static.alili.tech/img/remote/1460000016231515?w=658&amp;h=658" alt="image" title="image" style="cursor: pointer; display: inline;"></span></p>\n<p>通过抽象语法树解析，我们可以像童年时拆解玩具一样，透视Javascript这台机器的运转，并且重新按着你的意愿来组装。</p>\n<p><strong> 现在，我们拆解一个简单的add函数</strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function add(a, b) {\n    return a + b\n}" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stylus"><code>function add(<span class="hljs-selector-tag">a</span>, b) {\n    return <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>\n}</code></pre>\n<p>首先，我们拿到的这个语法块，是一个FunctionDeclaration(函数定义)对象。</p>\n<p>用力拆开，它成了三块：</p>\n<ul>\n<li>一个id，就是它的名字，即add</li>\n<li>两个params，就是它的参数，即[a, b]</li>\n<li>一块body，也就是大括号内的一堆东西</li>\n</ul>\n<p>add没办法继续拆下去了，它是一个最基础Identifier（标志）对象，用来作为函数的唯一标志，就像人的姓名一样。</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="{\n    name: \'add\'\n    type: \'identifier\'\n    ...\n}" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs css"><code>{\n    <span class="hljs-attribute">name</span>: <span class="hljs-string">\'add\'</span>\n    type: <span class="hljs-string">\'identifier\'</span>\n    ...\n}</code></pre>\n<p>params继续拆下去，其实是两个Identifier组成的数组。之后也没办法拆下去了。</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="[\n    {\n        name: \'a\'\n        type: \'identifier\'\n        ...\n    },\n    {\n        name: \'b\'\n        type: \'identifier\'\n        ...\n    }\n]" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs scheme"><code>[\n    {\n        name: <span class="hljs-symbol">\'a</span>\'\n        type: <span class="hljs-symbol">\'identifier</span>\'\n        ...\n    },\n    {\n        name: <span class="hljs-symbol">\'b</span>\'\n        type: <span class="hljs-symbol">\'identifier</span>\'\n        ...\n    }\n]</code></pre>\n<p>接下来，我们继续拆开body<br>我们发现，body其实是一个BlockStatement（块状域）对象，用来表示是<code>{return a + b}</code></p>\n<p>打开Blockstatement，里面藏着一个ReturnStatement（Return域）对象，用来表示<code>return a + b</code></p>\n<p>继续打开ReturnStatement,里面是一个BinaryExpression(二项式)对象，用来表示<code>a + b</code></p>\n<p>继续打开BinaryExpression，它成了三部分，<code>left</code>，<code>operator</code>，<code>right</code></p>\n<ul>\n<li>\n<code>operator</code> 即<code>+</code>\n</li>\n<li>\n<code>left</code> 里面装的，是Identifier对象 <code>a</code>\n</li>\n<li>\n<code>right</code> 里面装的，是Identifer对象 <code>b</code>\n</li>\n</ul>\n<p>就这样，我们把一个简单的add函数拆解完毕，用图表示就是</p>\n<p><span class="img-wrap"><img src="https://static.alili.tech/img/remote/1460000016231998?w=1380&amp;h=910" del-src="https://static.alili.tech/v-5bbf1b3b/global/img/squares.svg" alt="image" title="image" style="cursor: pointer;"></span></p>\n<p>看！抽象语法树(Abstract Syntax Tree)，的确是一种标准的树结构。</p>\n<p>那么，上面我们提到的Identifier、Blockstatement、ReturnStatement、BinaryExpression， 这一个个小部件的说明书去哪查？</p>\n<p><strong>请查看 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects" rel="nofollow noreferrer" target="_blank">AST对象文档</a></strong></p>\n<h3 id="articleHeader1">送给你的AST螺丝刀：recast</h3>\n<p>输入命令：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="npm i recast -S" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stata"><code style="word-break: break-word; white-space: initial;">npm i <span class="hljs-keyword">recast</span> -<span class="hljs-built_in">S</span></code></pre>\n<p>你即可获得一把操纵语法树的螺丝刀</p>\n<p>接下来，你可以在任意js文件下操纵这把螺丝刀，我们新建一个parse.js示意：</p>\n<p><strong>parse.js</strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 给你一把&quot;螺丝刀&quot;——recast\nconst recast = require(&quot;recast&quot;);\n\n// 你的&quot;机器&quot;——一段代码\n// 我们使用了很奇怪格式的代码，想测试是否能维持代码结构\nconst code =\n  `\n  function add(a, b) {\n    return a +\n      // 有什么奇怪的东西混进来了\n      b\n  }\n  `\n// 用螺丝刀解析机器\nconst ast = recast.parse(code);\n\n// ast可以处理很巨大的代码文件\n// 但我们现在只需要代码块的第一个body，即add函数\nconst add  = ast.program.body[0]\n\nconsole.log(add)" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stata"><code><span class="hljs-comment">// 给你一把"螺丝刀"——recast</span>\n<span class="hljs-keyword">const</span> <span class="hljs-keyword">recast</span> = require(<span class="hljs-string">"recast"</span>);\n\n<span class="hljs-comment">// 你的"机器"——一段代码</span>\n<span class="hljs-comment">// 我们使用了很奇怪格式的代码，想测试是否能维持代码结构</span>\n<span class="hljs-keyword">const</span> code =\n  `\n  function add(a, b) {\n    <span class="hljs-keyword">return</span> a +\n      <span class="hljs-comment">// 有什么奇怪的东西混进来了</span>\n      b\n  }\n  `\n<span class="hljs-comment">// 用螺丝刀解析机器</span>\n<span class="hljs-keyword">const</span> ast = <span class="hljs-keyword">recast</span>.<span class="hljs-keyword">parse</span>(code);\n\n<span class="hljs-comment">// ast可以处理很巨大的代码文件</span>\n<span class="hljs-comment">// 但我们现在只需要代码块的第一个body，即add函数</span>\n<span class="hljs-keyword">const</span> add  = ast.<span class="hljs-keyword">program</span>.body[0]\n\nconsole.<span class="hljs-built_in">log</span>(add)</code></pre>\n<p>输入<code>node parse.js</code>你可以查看到add函数的结构，与之前所述一致，通过<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects" rel="nofollow noreferrer" target="_blank">AST对象文档</a>可查到它的具体属性：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="FunctionDeclaration{\n    type: \'FunctionDeclaration\',\n    id: ...\n    params: ...\n    body: ...\n}" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs lasso"><code>FunctionDeclaration{\n    <span class="hljs-keyword">type</span>: <span class="hljs-string">\'FunctionDeclaration\'</span>,\n    id: <span class="hljs-params">...</span>\n    <span class="hljs-keyword">params</span>: <span class="hljs-params">...</span>\n    body: <span class="hljs-params">...</span>\n}</code></pre>\n<p>你也可以继续使用console.log透视它的更内层，如：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="console.log(add.params[0])" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs css"><code style="word-break: break-word; white-space: initial;"><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">add</span><span class="hljs-selector-class">.params</span><span class="hljs-selector-attr">[0]</span>)</code></pre>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="console.log(add.body.body[0].argument.left)" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs css"><code style="word-break: break-word; white-space: initial;"><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">add</span><span class="hljs-selector-class">.body</span><span class="hljs-selector-class">.body</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.argument</span><span class="hljs-selector-class">.left</span>)</code></pre>\n<h2 id="articleHeader2">recast.types.builders 制作模具</h2>\n<p>一个机器，你只会拆开重装，不算本事。</p>\n<p>拆开了，还能改装，才算上得了台面。</p>\n<p>recast.types.builders里面提供了不少“模具”，让你可以轻松地拼接成新的机器。</p>\n<p>最简单的例子，我们想把之前的<code>function add(a, b){...}</code>声明，改成匿名函数式声明<code>const add = function(a ,b){...}</code></p>\n<p>如何改装？</p>\n<p>第一步，我们创建一个VariableDeclaration变量声明对象，声明头为const， 内容为一个即将创建的VariableDeclarator对象。</p>\n<p>第二步，创建一个VariableDeclarator，放置add.id在左边， 右边是将创建的FunctionDeclaration对象</p>\n<p>第三步，我们创建一个FunctionDeclaration，如前所述的三个组件，id params body中，因为是匿名函数id设为空，params使用add.params，body使用add.body。</p>\n<p>这样，就创建好了<code>const add = function(){}</code>的AST对象。</p>\n<p>在之前的parse.js代码之后，加入以下代码</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 引入变量声明，变量符号，函数声明三种“模具”\nconst {variableDeclaration, variableDeclarator, functionExpression} = recast.types.builders\n\n// 将准备好的组件置入模具，并组装回原来的ast对象。\nast.program.body[0] = variableDeclaration(&quot;const&quot;, [\n  variableDeclarator(add.id, functionExpression(\n    null, // Anonymize the function expression.\n    add.params,\n    add.body\n  ))\n]);\n\n//将AST对象重新转回可以阅读的代码\nconst output = recast.print(ast).code;\n\nconsole.log(output)" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs processing"><code><span class="hljs-comment">// 引入变量声明，变量符号，函数声明三种“模具”</span>\n<span class="hljs-keyword">const</span> {variableDeclaration, variableDeclarator, functionExpression} = recast.types.builders\n\n<span class="hljs-comment">// 将准备好的组件置入模具，并组装回原来的ast对象。</span>\nast.program.body[<span class="hljs-number">0</span>] = variableDeclaration(<span class="hljs-string">"const"</span>, [\n  variableDeclarator(<span class="hljs-built_in">add</span>.id, functionExpression(\n    <span class="hljs-keyword">null</span>, <span class="hljs-comment">// Anonymize the function expression.</span>\n    <span class="hljs-built_in">add</span>.params,\n    <span class="hljs-built_in">add</span>.body\n  ))\n]);\n\n<span class="hljs-comment">//将AST对象重新转回可以阅读的代码</span>\n<span class="hljs-keyword">const</span> output = recast.<span class="hljs-built_in">print</span>(ast).code;\n\nconsole.<span class="hljs-built_in">log</span>(output)</code></pre>\n<p>可以看到，我们打印出了</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const add = function(a, b) {\n  return a +\n    // 有什么奇怪的东西混进来了\n    b\n};\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs actionscript"><code><span class="hljs-keyword">const</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{\n  <span class="hljs-keyword">return</span> a +\n    <span class="hljs-comment">// 有什么奇怪的东西混进来了</span>\n    b\n};\n</code></pre>\n<p>最后一行</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const output = recast.print(ast).code;" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs gauss"><code style="word-break: break-word; white-space: initial;">const <span class="hljs-keyword">output</span> = recast.<span class="hljs-keyword">print</span>(ast).<span class="hljs-built_in">code</span>;</code></pre>\n<p>其实是recast.parse的逆向过程，具体公式为</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="recast.print(recast.parse(source)).code === source" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stata"><code style="word-break: break-word; white-space: initial;"><span class="hljs-keyword">recast</span>.<span class="hljs-keyword">print</span>(<span class="hljs-keyword">recast</span>.<span class="hljs-keyword">parse</span>(source)).code === source</code></pre>\n<p>打印出来还保留着“原装”的函数内容，连注释都没有变。</p>\n<p>我们其实也可以打印出美化格式的代码段：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const output = recast.prettyPrint(ast, { tabWidth: 2 }).code" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs gauss"><code style="word-break: break-word; white-space: initial;">const <span class="hljs-keyword">output</span> = recast.prettyPrint(ast, { tabWidth: <span class="hljs-number">2</span> }).<span class="hljs-built_in">code</span></code></pre>\n<p>输出为</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="const add = function(a, b) {\n  return a + b;\n};\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs oxygene"><code><span class="hljs-keyword">const</span> <span class="hljs-keyword">add</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> <span class="hljs-comment">{\n  return a + b;\n}</span>;</span>\n</code></pre>\n<blockquote>现在，你是不是已经产生了“我可以通过AST树生成任何js代码”的幻觉？<p>我郑重告诉你，这不是幻觉。</p>\n</blockquote>\n<h2 id="articleHeader3">实战进阶：命令行修改js文件</h2>\n<p>除了parse/print/builder以外，Recast的三项主要功能：</p>\n<ul>\n<li>run: 通过命令行读取js文件，并转化成ast以供处理。</li>\n<li>tnt： 通过assert()和check()，可以验证ast对象的类型。</li>\n<li>visit: 遍历ast树，获取有效的AST对象并进行更改。</li>\n</ul>\n<p>我们通过一个系列小务来学习全部的recast工具库：</p>\n<p>创建一个用来示例文件，假设是demo.js</p>\n<p><strong>demo.js</strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function add(a, b) {\n  return a + b\n}\n\nfunction sub(a, b) {\n  return a - b\n}\n\nfunction commonDivision(a, b) {\n  while (b !== 0) {\n    if (a > b) {\n      a = sub(a, b)\n    } else {\n      b = sub(b, a)\n    }\n  }\n  return a\n}" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stylus"><code>function add(<span class="hljs-selector-tag">a</span>, b) {\n  return <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>\n}\n\nfunction sub(<span class="hljs-selector-tag">a</span>, b) {\n  return <span class="hljs-selector-tag">a</span> - <span class="hljs-selector-tag">b</span>\n}\n\nfunction commonDivision(<span class="hljs-selector-tag">a</span>, b) {\n  while (<span class="hljs-selector-tag">b</span> !== <span class="hljs-number">0</span>) {\n    <span class="hljs-keyword">if</span> (<span class="hljs-selector-tag">a</span> &gt; b) {\n      <span class="hljs-selector-tag">a</span> = sub(<span class="hljs-selector-tag">a</span>, b)\n    } <span class="hljs-keyword">else</span> {\n      <span class="hljs-selector-tag">b</span> = sub(<span class="hljs-selector-tag">b</span>, a)\n    }\n  }\n  return <span class="hljs-selector-tag">a</span>\n}</code></pre>\n<h3 id="articleHeader4">recast.run —— 命令行文件读取</h3>\n<p>新建一个名为<code>read.js</code>的文件，写入<br><strong>read.js</strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="recast.run( function(ast, printSource){\n    printSource(ast)\n})" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs actionscript"><code>recast.run( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ast, printSource)</span></span>{\n    printSource(ast)\n})</code></pre>\n<p>命令行输入</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="node read demo.js" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs crmsh"><code style="word-break: break-word; white-space: initial;"><span class="hljs-keyword">node</span> <span class="hljs-title">read</span> demo.js</code></pre>\n<p>我们查以看到js文件内容打印在了控制台上。</p>\n<p>我们可以知道，<code>node read</code>可以读取<code>demo.js</code>文件，并将demo.js内容转化为ast对象。</p>\n<p>同时它还提供了一个<code>printSource</code>函数，随时可以将ast的内容转换回源码，以方便调试。</p>\n<h3 id="articleHeader5">recast.visit —— AST节点遍历</h3>\n<p><strong>read.js</strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#!/usr/bin/env node\nconst recast  = require(\'recast\')\n\nrecast.run(function(ast, printSource) {\n  recast.visit(ast, {\n      visitExpressionStatement: function({node}) {\n        console.log(node)\n        return false\n      }\n    });\n});" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-meta">#!/usr/bin/env node</span>\n<span class="hljs-keyword">const</span> recast  = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'recast\'</span>)\n\nrecast.run(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ast, printSource</span>) </span>{\n  recast.visit(ast, {\n      <span class="hljs-attr">visitExpressionStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{node}</span>) </span>{\n        <span class="hljs-built_in">console</span>.log(node)\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n      }\n    });\n});</code></pre>\n<p>recast.visit将AST对象内的节点进行逐个遍历。</p>\n<p><strong>注意</strong></p>\n<ul>\n<li>你想操作函数声明，就使用visitFunctionDelaration遍历，想操作赋值表达式，就使用visitExpressionStatement。 只要在 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects" rel="nofollow noreferrer" target="_blank">AST对象文档</a>中定义的对象，在前面加visit，即可遍历。</li>\n<li>通过node可以取到AST对象</li>\n<li>每个遍历函数后必须加上return false，或者选择以下写法，否则报错：</li>\n</ul>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#!/usr/bin/env node\nconst recast  = require(\'recast\')\n\nrecast.run(function(ast, printSource) {\n  recast.visit(ast, {\n      visitExpressionStatement: function(path) {\n        const node = path.node\n        printSource(node)\n        this.traverse(path)\n      }\n    })\n});" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-meta">#!/usr/bin/env node</span>\n<span class="hljs-keyword">const</span> recast  = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'recast\'</span>)\n\nrecast.run(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ast, printSource</span>) </span>{\n  recast.visit(ast, {\n      <span class="hljs-attr">visitExpressionStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{\n        <span class="hljs-keyword">const</span> node = path.node\n        printSource(node)\n        <span class="hljs-keyword">this</span>.traverse(path)\n      }\n    })\n});</code></pre>\n<p>调试时，如果你想输出AST对象，可以<code>console.log(node)</code></p>\n<p>如果你想输出AST对象对应的源码，可以<code>printSource(node)</code></p>\n<p>命令行输入`<br>node read demo.js`进行测试。</p>\n<blockquote>\n<code>#!/usr/bin/env node</code> 在所有使用<code>recast.run()</code>的文件顶部都需要加入这一行，它的意义我们最后再讨论。</blockquote>\n<h3 id="articleHeader6">TNT —— 判断AST对象类型</h3>\n<p>TNT，即recast.types.namedTypes，就像它的名字一样火爆，它用来判断AST对象是否为指定的类型。</p>\n<p>TNT.Node.assert()，就像在机器里埋好的炸药，当机器不能完好运转时（类型不匹配），就炸毁机器(报错退出)</p>\n<p>TNT.Node.check()，则可以判断类型是否一致，并输出False和True</p>\n<p>上述Node可以替换成任意AST对象，例如TNT.ExpressionStatement.check(),TNT.FunctionDeclaration.assert()</p>\n<p><strong>read.js</strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#!/usr/bin/env node\nconst recast = require(&quot;recast&quot;);\nconst TNT = recast.types.namedTypes\n\nrecast.run(function(ast, printSource) {\n  recast.visit(ast, {\n      visitExpressionStatement: function(path) {\n        const node = path.value\n        // 判断是否为ExpressionStatement，正确则输出一行字。\n        if(TNT.ExpressionStatement.check(node)){\n          console.log(\'这是一个ExpressionStatement\')\n        }\n        this.traverse(path);\n      }\n    });\n});" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-meta">#!/usr/bin/env node</span>\n<span class="hljs-keyword">const</span> recast = <span class="hljs-built_in">require</span>(<span class="hljs-string">"recast"</span>);\n<span class="hljs-keyword">const</span> TNT = recast.types.namedTypes\n\nrecast.run(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ast, printSource</span>) </span>{\n  recast.visit(ast, {\n      <span class="hljs-attr">visitExpressionStatement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{\n        <span class="hljs-keyword">const</span> node = path.value\n        <span class="hljs-comment">// 判断是否为ExpressionStatement，正确则输出一行字。</span>\n        <span class="hljs-keyword">if</span>(TNT.ExpressionStatement.check(node)){\n          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'这是一个ExpressionStatement\'</span>)\n        }\n        <span class="hljs-keyword">this</span>.traverse(path);\n      }\n    });\n});</code></pre>\n<p><strong>read.js</strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#!/usr/bin/env node\nconst recast = require(&quot;recast&quot;);\nconst TNT = recast.types.namedTypes\n\nrecast.run(function(ast, printSource) {\n  recast.visit(ast, {\n      visitExpressionStatement: function(path) {\n        const node = path.node\n        // 判断是否为ExpressionStatement，正确不输出，错误则全局报错\n        TNT.ExpressionStatement.assert(node)\n        this.traverse(path);\n      }\n    });\n});" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs d"><code><span class="hljs-meta">#!/usr/bin/env node</span>\n<span class="hljs-keyword">const</span> recast = require(<span class="hljs-string">"recast"</span>);\n<span class="hljs-keyword">const</span> TNT = recast.types.namedTypes\n\nrecast.run(<span class="hljs-built_in">function</span>(ast, printSource) {\n  recast.visit(ast, {\n      visitExpressionStatement: <span class="hljs-built_in">function</span>(path) {\n        <span class="hljs-keyword">const</span> node = path.node\n        <span class="hljs-comment">// 判断是否为ExpressionStatement，正确不输出，错误则全局报错</span>\n        TNT.ExpressionStatement.<span class="hljs-keyword">assert</span>(node)\n        <span class="hljs-keyword">this</span>.traverse(path);\n      }\n    });\n});</code></pre>\n<p>命令行输入`<br>node read demo.js`进行测试。</p>\n<h3 id="articleHeader7">实战：用AST修改源码，导出全部方法</h3>\n<p>exportific.js</p>\n<p>现在，我们希望将demo中的function全部</p>\n<p>我们想让这个文件中的函数改写成能够全部导出的形式，例如</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function add (a, b) {\n    return a + b\n}" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stylus"><code>function add (<span class="hljs-selector-tag">a</span>, b) {\n    return <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>\n}</code></pre>\n<p>想改变为</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="exports.add = (a, b) => {\n  return a + b\n}" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stylus"><code>exports<span class="hljs-selector-class">.add</span> = (<span class="hljs-selector-tag">a</span>, b) =&gt; {\n  return <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>\n}</code></pre>\n<p>除了使用fs.read读取文件、正则匹配替换文本、fs.write写入文件这种笨拙的方式外，我们可以==用AST优雅地解决问题==。</p>\n<p>查询<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects" rel="nofollow noreferrer" target="_blank">AST对象文档</a></p>\n<h4>首先，我们先用builders凭空实现一个键头函数</h4>\n<p><strong>exportific.js</strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#!/usr/bin/env node\nconst recast = require(&quot;recast&quot;);\nconst {\n  identifier:id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression,\n  blockStatement\n} = recast.types.builders\n\nrecast.run(function(ast, printSource) {\n  // 一个块级域 {}\n  console.log(\'\\n\\nstep1:\')\n  printSource(blockStatement([]))\n\n  // 一个键头函数 ()=>{}\n  console.log(\'\\n\\nstep2:\')\n  printSource(arrowFunctionExpression([],blockStatement([])))\n\n  // add赋值为键头函数  add = ()=>{}\n  console.log(\'\\n\\nstep3:\')\n  printSource(assignmentExpression(\'=\',id(\'add\'),arrowFunctionExpression([],blockStatement([]))))\n\n  // exports.add赋值为键头函数  exports.add = ()=>{}\n  console.log(\'\\n\\nstep4:\')\n  printSource(expressionStatement(assignmentExpression(\'=\',memberExpression(id(\'exports\'),id(\'add\')),\n    arrowFunctionExpression([],blockStatement([])))))\n});" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-meta">#!/usr/bin/env node</span>\n<span class="hljs-keyword">const</span> recast = <span class="hljs-built_in">require</span>(<span class="hljs-string">"recast"</span>);\n<span class="hljs-keyword">const</span> {\n  <span class="hljs-attr">identifier</span>:id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression,\n  blockStatement\n} = recast.types.builders\n\nrecast.run(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ast, printSource</span>) </span>{\n  <span class="hljs-comment">// 一个块级域 {}</span>\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'\\n\\nstep1:\'</span>)\n  printSource(blockStatement([]))\n\n  <span class="hljs-comment">// 一个键头函数 ()=&gt;{}</span>\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'\\n\\nstep2:\'</span>)\n  printSource(arrowFunctionExpression([],blockStatement([])))\n\n  <span class="hljs-comment">// add赋值为键头函数  add = ()=&gt;{}</span>\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'\\n\\nstep3:\'</span>)\n  printSource(assignmentExpression(<span class="hljs-string">\'=\'</span>,id(<span class="hljs-string">\'add\'</span>),arrowFunctionExpression([],blockStatement([]))))\n\n  <span class="hljs-comment">// exports.add赋值为键头函数  exports.add = ()=&gt;{}</span>\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'\\n\\nstep4:\'</span>)\n  printSource(expressionStatement(assignmentExpression(<span class="hljs-string">\'=\'</span>,memberExpression(id(<span class="hljs-string">\'exports\'</span>),id(<span class="hljs-string">\'add\'</span>)),\n    arrowFunctionExpression([],blockStatement([])))))\n});</code></pre>\n<p>上面写了我们一步一步推断出<code>exports.add = ()=&gt;{}</code>的过程，从而得到具体的AST结构体。</p>\n<p>使用<code>node exportific demo.js</code>运行可查看结果。</p>\n<p>接下来，只需要在获得的最终的表达式中，把id(\'add\')替换成遍历得到的函数名，把参数替换成遍历得到的函数参数，把blockStatement([])替换为遍历得到的函数块级作用域，就成功地改写了所有函数！</p>\n<p>另外，我们需要注意，在commonDivision函数内，引用了sub函数，应改写成exports.sub</p>\n<p><strong>exportific.js</strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#!/usr/bin/env node\nconst recast = require(&quot;recast&quot;);\nconst {\n  identifier: id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression\n} = recast.types.builders\n\nrecast.run(function (ast, printSource) {\n  // 用来保存遍历到的全部函数名\n  let funcIds = []\n  recast.types.visit(ast, {\n    // 遍历所有的函数定义\n    visitFunctionDeclaration(path) {\n      //获取遍历到的函数名、参数、块级域\n      const node = path.node\n      const funcName = node.id\n      const params = node.params\n      const body = node.body\n\n      // 保存函数名\n      funcIds.push(funcName.name)\n      // 这是上一步推导出来的ast结构体\n      const rep = expressionStatement(assignmentExpression(\'=\', memberExpression(id(\'exports\'), funcName),\n        arrowFunctionExpression(params, body)))\n      // 将原来函数的ast结构体，替换成推导ast结构体\n      path.replace(rep)\n      // 停止遍历\n      return false\n    }\n  })\n\n\n  recast.types.visit(ast, {\n    // 遍历所有的函数调用\n    visitCallExpression(path){\n      const node = path.node;\n      // 如果函数调用出现在函数定义中，则修改ast结构\n      if (funcIds.includes(node.callee.name)) {\n        node.callee = memberExpression(id(\'exports\'), node.callee)\n      }\n      // 停止遍历\n      return false\n    }\n  })\n  // 打印修改后的ast源码\n  printSource(ast)\n})" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs crmsh"><code><span class="hljs-comment">#!/usr/bin/env node</span>\nconst recast = require(<span class="hljs-string">"recast"</span>);\nconst {\n  identifier: id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression\n} = recast.types.builders\n\nrecast.run(function (ast, printSource) {\n  // 用来保存遍历到的全部函数名\n  let funcIds = []\n  recast.types.visit(ast, {\n    // 遍历所有的函数定义\n    visitFunctionDeclaration(path) {\n      //获取遍历到的函数名、参数、块级域\n      const <span class="hljs-keyword">node</span> <span class="hljs-title">= path</span>.node\n      const funcName = <span class="hljs-keyword">node</span>.<span class="hljs-title">id</span>\n      const <span class="hljs-keyword">params</span> = <span class="hljs-keyword">node</span>.<span class="hljs-title">params</span>\n      const body = <span class="hljs-keyword">node</span>.<span class="hljs-title">body</span>\n\n      // 保存函数名\n      funcIds.push(funcName.name)\n      // 这是上一步推导出来的ast结构体\n      const rep = expressionStatement(assignmentExpression(\'=\', memberExpression(id(\'exports\'), funcName),\n        arrowFunctionExpression(<span class="hljs-keyword">params</span>, body)))\n      // 将原来函数的ast结构体，替换成推导ast结构体\n      path.replace(rep)\n      // 停止遍历\n      return <span class="hljs-literal">false</span>\n    }\n  })\n\n\n  recast.types.visit(ast, {\n    // 遍历所有的函数调用\n    visitCallExpression(path){\n      const <span class="hljs-keyword">node</span> <span class="hljs-title">= path</span>.node;\n      // 如果函数调用出现在函数定义中，则修改ast结构\n      if (funcIds.includes(<span class="hljs-keyword">node</span>.<span class="hljs-title">callee</span>.name)) {\n        <span class="hljs-keyword">node</span>.<span class="hljs-title">callee</span> = memberExpression(id(\'exports\'), <span class="hljs-keyword">node</span>.<span class="hljs-title">callee</span>)\n      }\n      // 停止遍历\n      return <span class="hljs-literal">false</span>\n    }\n  })\n  // 打印修改后的ast源码\n  printSource(ast)\n})</code></pre>\n<h3 id="articleHeader8">一步到位，发一个最简单的exportific前端工具</h3>\n<p>上面讲了那么多，仍然只体现在理论阶段。</p>\n<p>但通过简单的改写，就能通过recast制作成一个名为exportific的源码编辑工具。</p>\n<p>以下代码添加作了两个小改动</p>\n<ol>\n<li>添加说明书--help，以及添加了--rewrite模式，可以直接覆盖文件或默认为导出*.export.js文件。</li>\n<li>将之前代码最后的 printSource(ast)替换成  writeASTFile(ast,filename,rewriteMode)</li>\n</ol>\n<p><strong>exportific.js</strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#!/usr/bin/env node\nconst recast = require(&quot;recast&quot;);\nconst {\n  identifier: id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression\n} = recast.types.builders\n\nconst fs = require(\'fs\')\nconst path = require(\'path\')\n// 截取参数\nconst options = process.argv.slice(2)\n\n//如果没有参数，或提供了-h 或--help选项，则打印帮助\nif(options.length===0 || options.includes(\'-h\') || options.includes(\'--help\')){\n  console.log(`\n    采用commonjs规则，将.js文件内所有函数修改为导出形式。\n\n    选项： -r  或 --rewrite 可直接覆盖原有文件\n    `)\n  process.exit(0)\n}\n\n// 只要有-r 或--rewrite参数，则rewriteMode为true\nlet rewriteMode = options.includes(\'-r\') || options.includes(\'--rewrite\')\n\n// 获取文件名\nconst clearFileArg = options.filter((item)=>{\n  return ![\'-r\',\'--rewrite\',\'-h\',\'--help\'].includes(item)\n})\n\n// 只处理一个文件\nlet filename = clearFileArg[0]\n\nconst writeASTFile = function(ast, filename, rewriteMode){\n  const newCode = recast.print(ast).code\n  if(!rewriteMode){\n    // 非覆盖模式下，将新文件写入*.export.js下\n    filename = filename.split(\'.\').slice(0,-1).concat([\'export\',\'js\']).join(\'.\')\n  }\n  // 将新代码写入文件\n  fs.writeFileSync(path.join(process.cwd(),filename),newCode)\n}\n\n\nrecast.run(function (ast, printSource) {\n  let funcIds = []\n  recast.types.visit(ast, {\n    visitFunctionDeclaration(path) {\n      //获取遍历到的函数名、参数、块级域\n      const node = path.node\n      const funcName = node.id\n      const params = node.params\n      const body = node.body\n\n      funcIds.push(funcName.name)\n      const rep = expressionStatement(assignmentExpression(\'=\', memberExpression(id(\'exports\'), funcName),\n        arrowFunctionExpression(params, body)))\n      path.replace(rep)\n      return false\n    }\n  })\n\n\n  recast.types.visit(ast, {\n    visitCallExpression(path){\n      const node = path.node;\n      if (funcIds.includes(node.callee.name)) {\n        node.callee = memberExpression(id(\'exports\'), node.callee)\n      }\n      return false\n    }\n  })\n\n  writeASTFile(ast,filename,rewriteMode)\n})" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-meta">#!/usr/bin/env node</span>\n<span class="hljs-keyword">const</span> recast = <span class="hljs-built_in">require</span>(<span class="hljs-string">"recast"</span>);\n<span class="hljs-keyword">const</span> {\n  <span class="hljs-attr">identifier</span>: id,\n  expressionStatement,\n  memberExpression,\n  assignmentExpression,\n  arrowFunctionExpression\n} = recast.types.builders\n\n<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>)\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>)\n<span class="hljs-comment">// 截取参数</span>\n<span class="hljs-keyword">const</span> options = process.argv.slice(<span class="hljs-number">2</span>)\n\n<span class="hljs-comment">//如果没有参数，或提供了-h 或--help选项，则打印帮助</span>\n<span class="hljs-keyword">if</span>(options.length===<span class="hljs-number">0</span> || options.includes(<span class="hljs-string">\'-h\'</span>) || options.includes(<span class="hljs-string">\'--help\'</span>)){\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\n    采用commonjs规则，将.js文件内所有函数修改为导出形式。\n\n    选项： -r  或 --rewrite 可直接覆盖原有文件\n    `</span>)\n  process.exit(<span class="hljs-number">0</span>)\n}\n\n<span class="hljs-comment">// 只要有-r 或--rewrite参数，则rewriteMode为true</span>\n<span class="hljs-keyword">let</span> rewriteMode = options.includes(<span class="hljs-string">\'-r\'</span>) || options.includes(<span class="hljs-string">\'--rewrite\'</span>)\n\n<span class="hljs-comment">// 获取文件名</span>\n<span class="hljs-keyword">const</span> clearFileArg = options.filter(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>{\n  <span class="hljs-keyword">return</span> ![<span class="hljs-string">\'-r\'</span>,<span class="hljs-string">\'--rewrite\'</span>,<span class="hljs-string">\'-h\'</span>,<span class="hljs-string">\'--help\'</span>].includes(item)\n})\n\n<span class="hljs-comment">// 只处理一个文件</span>\n<span class="hljs-keyword">let</span> filename = clearFileArg[<span class="hljs-number">0</span>]\n\n<span class="hljs-keyword">const</span> writeASTFile = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ast, filename, rewriteMode</span>)</span>{\n  <span class="hljs-keyword">const</span> newCode = recast.print(ast).code\n  <span class="hljs-keyword">if</span>(!rewriteMode){\n    <span class="hljs-comment">// 非覆盖模式下，将新文件写入*.export.js下</span>\n    filename = filename.split(<span class="hljs-string">\'.\'</span>).slice(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>).concat([<span class="hljs-string">\'export\'</span>,<span class="hljs-string">\'js\'</span>]).join(<span class="hljs-string">\'.\'</span>)\n  }\n  <span class="hljs-comment">// 将新代码写入文件</span>\n  fs.writeFileSync(path.join(process.cwd(),filename),newCode)\n}\n\n\nrecast.run(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ast, printSource</span>) </span>{\n  <span class="hljs-keyword">let</span> funcIds = []\n  recast.types.visit(ast, {\n    visitFunctionDeclaration(path) {\n      <span class="hljs-comment">//获取遍历到的函数名、参数、块级域</span>\n      <span class="hljs-keyword">const</span> node = path.node\n      <span class="hljs-keyword">const</span> funcName = node.id\n      <span class="hljs-keyword">const</span> params = node.params\n      <span class="hljs-keyword">const</span> body = node.body\n\n      funcIds.push(funcName.name)\n      <span class="hljs-keyword">const</span> rep = expressionStatement(assignmentExpression(<span class="hljs-string">\'=\'</span>, memberExpression(id(<span class="hljs-string">\'exports\'</span>), funcName),\n        arrowFunctionExpression(params, body)))\n      path.replace(rep)\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n    }\n  })\n\n\n  recast.types.visit(ast, {\n    visitCallExpression(path){\n      <span class="hljs-keyword">const</span> node = path.node;\n      <span class="hljs-keyword">if</span> (funcIds.includes(node.callee.name)) {\n        node.callee = memberExpression(id(<span class="hljs-string">\'exports\'</span>), node.callee)\n      }\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>\n    }\n  })\n\n  writeASTFile(ast,filename,rewriteMode)\n})</code></pre>\n<p>现在尝试一下</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="node exportific demo.js" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs crmsh"><code style="word-break: break-word; white-space: initial;"><span class="hljs-keyword">node</span> <span class="hljs-title">exportific</span> demo.js</code></pre>\n<p>已经可以在当前目录下找到源码变更后的<code>demo.export.js</code>文件了。</p>\n<h3 id="articleHeader9">npm发包</h3>\n<p>编辑一下package.json文件</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="{\n  &quot;name&quot;: &quot;exportific&quot;,\n  &quot;version&quot;: &quot;0.0.1&quot;,\n  &quot;description&quot;: &quot;改写源码中的函数为可exports.XXX形式&quot;,\n  &quot;main&quot;: &quot;exportific.js&quot;,\n  &quot;bin&quot;: {\n    &quot;exportific&quot;: &quot;./exportific.js&quot;\n  },\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;wanthering&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: {\n    &quot;recast&quot;: &quot;^0.15.3&quot;\n  }\n}" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs json"><code>{\n  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"exportific"</span>,\n  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.1"</span>,\n  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"改写源码中的函数为可exports.XXX形式"</span>,\n  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"exportific.js"</span>,\n  <span class="hljs-attr">"bin"</span>: {\n    <span class="hljs-attr">"exportific"</span>: <span class="hljs-string">"./exportific.js"</span>\n  },\n  <span class="hljs-attr">"keywords"</span>: [],\n  <span class="hljs-attr">"author"</span>: <span class="hljs-string">"wanthering"</span>,\n  <span class="hljs-attr">"license"</span>: <span class="hljs-string">"ISC"</span>,\n  <span class="hljs-attr">"dependencies"</span>: {\n    <span class="hljs-attr">"recast"</span>: <span class="hljs-string">"^0.15.3"</span>\n  }\n}</code></pre>\n<p>注意bin选项，它的意思是将全局命令<code>exportific</code>指向当前目录下的<code>exportific.js</code></p>\n<p>这时，输入<code>npm link</code> 就在本地生成了一个<code>exportific</code>命令。</p>\n<p>之后，只要哪个js文件想导出来使用，就<code>exportific XXX.js</code>一下。</p>\n<p>这是在本地的玩法，想和大家一起分享这个前端小工具，只需要发布npm包就行了。</p>\n<p>同时，一定要注意exportific.js文件头有</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="#!/usr/bin/env node" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs d"><code style="word-break: break-word; white-space: initial;"><span class="hljs-meta">#!/usr/bin/env node</span></code></pre>\n<p>否则在使用时将报错。</p>\n<h4>接下来，正式发布npm包！</h4>\n<p>如果你已经有了npm 帐号，请使用<code>npm login</code>登录</p>\n<p>如果你还没有npm帐号 <a href="https://www.npmjs.com/signup" rel="nofollow noreferrer" target="_blank">https://www.npmjs.com/signup</a> 非常简单就可以注册npm</p>\n<p>然后，输入<br><code>npm publish</code></p>\n<p>没有任何繁琐步骤，丝毫审核都没有，你就发布了一个实用的前端小工具exportific 。任何人都可以通过</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="npm i exportific -g" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stylus"><code style="word-break: break-word; white-space: initial;">npm <span class="hljs-selector-tag">i</span> exportific -g</code></pre>\n<p>全局安装这一个插件。</p>\n<p>提示：==在试验教程时，请不要和我的包重名，修改一下发包名称。==</p>\n<h3 id="articleHeader10">结语</h3>\n<p>我们对javascript再熟悉不过，但透过AST的视角，最普通的js语句，却焕发出精心动魄的美感。你可以通过它批量构建任何javascript代码！</p>\n<p>童年时，这个世界充满了新奇的玩具，再普通的东西在你眼中都如同至宝。如今，计算机语言就是你手中的大玩具，一段段AST对象的拆分组装，构建出我们所生活的网络世界。</p>\n<p>所以不得不说软件工程师是一个幸福的工作，你心中住的仍然是那个午后的少年，永远有无数新奇等你发现，永远有无数梦想等你构建。</p>\n<p>github地址：<a href="https://github.com/wanthering/exportific" rel="nofollow noreferrer" target="_blank">https://github.com/wanthering...</a></p>\n<p><span class="img-wrap"><img src="https://static.alili.tech/img/remote/1460000016231517?w=658&amp;h=893" src="https://static.alili.tech/img/remote/1460000016231517?w=658&amp;h=893" alt="image" title="image" style="cursor: pointer; display: inline;"></span></p>\n\n                \n';s=(s=(s=(s=s.replace(/"{/g,"{")).replace(/{"/g,"{")).replace(/"}/g,"}")).replace(/}"/g,"}"),$("#row").html(s)})</script></div><h1 id="版权声明">版权声明</h1><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， 原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000016231512">https://segmentfault.com/a/1190000016231512</a></p><h2 id="原文标题">原文标题</h2><p>AST抽象语法树——最基础的javascript重点知识，99%的人根本不了解</p><h2>本文链接：</h2><a href="https://alili.tech/archive/78fc0aba/" target="_blank">https://alili.tech/archive/78fc0aba/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({el:".blog-post-comments",app_id:"ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz",app_key:"hLhtmd4tT0qJbyO2SgQ8odya",placeholder:"说点什么?",avatar:"retro",notify:!0,verify:!0})</script><ul id="more-post-list" class="archive readmore"><h3>推荐阅读</h3><li><a href="/archive/vi32h2qgdt/">JavaScript点击事件——美女合集<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/h1hfkoy4as/">Web UI 自动化测试技术选型<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/2ehenm5fx2r/">【基础】固定列宽的表格及示例演示<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/bp751dpaao6/">移动端开发单位——rem，动态使用<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/w0ea6x92n7j/">预告：Javascript全栈开发的系列文章<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/nh5d5ddjtjs/">CORS 跨域携带 Cookie 发送请求<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/32ufjbf3p3i/">ES6深入浅出 Generator<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/tgareq08se/">H5移动端开发<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/kuarhdceuz/">JS面试理论题<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/82gahy2bcol/">JavaScript ES6功能概述（ECMAScript 6和ES2015 &#43;）<aside class="dates">2018-11-16</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Hosted by <a href="https://pages.coding.me" style="font-weight:700" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a target="_blank" href="http://github.com/Fantasy9527" rel="external nofollow noopener noreferrer">Github</a></li></ul></nav></div><p>Copyright © 2018 <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></p></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/js/main.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var d="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?05520debdbedd780ba345d83b7d5e6f4":"https://jspassport.ssl.qhimg.com/11.0.1.js?05520debdbedd780ba345d83b7d5e6f4";document.write('<script src="'+d+'" id="sozz"><\/script>')}()</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>