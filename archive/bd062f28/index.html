<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="$(function(){ var html = &#34;\n\n \x3cp\x3e传统方式中，许多人使用本地存储，来管理通过客户端验证生成的tokens。一个大问题是如何有更好的方式，来管理验证tokens，从而允许我们来存储更大的用户信息。\x3c\/p\x3e\n\x3cp\x3e这就是\x3ca href=\x22https:\/\/vuex.vuejs.org\x22\x3eVuex\x3c"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="使用Vuex解决Vue中的身份验证"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="$(function(){ var html = &#34;\n\n \x3cp\x3e传统方式中，许多人使用本地存储，来管理通过客户端验证生成的tokens。一个大问题是如何有更好的方式，来管理验证tokens，从而允许我们来存储更大的用户信息。\x3c\/p\x3e\n\x3cp\x3e这就是\x3ca href=\x22https:\/\/vuex.vuejs.org\x22\x3eVuex\x3c"><meta property="og:site_name" content="Alili"><title>使用Vuex解决Vue中的身份验证 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/meslo-LG/styles.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad()</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error",function(e){var t=e.target;"img"==t.tagName.toLowerCase()&&(t.style.display="none")},!0)</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bd062f28/",
				"appid": "1613049289050283", 
				"title": "使用Vuex解决Vue中的身份验证 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-18T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/e14944ab/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" href="https://alili.tech/archive/28b3438b/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">Previous post</span> <span id="i-next" class="info" style="display:none">Next post</span> <span id="i-top" class="info" style="display:none">Back to top</span> <span id="i-share" class="info" style="display:none">Share post</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbd062f28%2f&text=%e4%bd%bf%e7%94%a8Vuex%e8%a7%a3%e5%86%b3Vue%e4%b8%ad%e7%9a%84%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbd062f28%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbd062f28%2f&text=%e4%bd%bf%e7%94%a8Vuex%e8%a7%a3%e5%86%b3Vue%e4%b8%ad%e7%9a%84%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbd062f28%2f&title=%e4%bd%bf%e7%94%a8Vuex%e8%a7%a3%e5%86%b3Vue%e4%b8%ad%e7%9a%84%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbd062f28%2f&is_video=false&description=%e4%bd%bf%e7%94%a8Vuex%e8%a7%a3%e5%86%b3Vue%e4%b8%ad%e7%9a%84%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bd%bf%e7%94%a8Vuex%e8%a7%a3%e5%86%b3Vue%e4%b8%ad%e7%9a%84%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbd062f28%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbd062f28%2f&title=%e4%bd%bf%e7%94%a8Vuex%e8%a7%a3%e5%86%b3Vue%e4%b8%ad%e7%9a%84%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbd062f28%2f&title=%e4%bd%bf%e7%94%a8Vuex%e8%a7%a3%e5%86%b3Vue%e4%b8%ad%e7%9a%84%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbd062f28%2f&title=%e4%bd%bf%e7%94%a8Vuex%e8%a7%a3%e5%86%b3Vue%e4%b8%ad%e7%9a%84%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbd062f28%2f&title=%e4%bd%bf%e7%94%a8Vuex%e8%a7%a3%e5%86%b3Vue%e4%b8%ad%e7%9a%84%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">使用Vuex解决Vue中的身份验证</h1><div class="meta"><div class="postdate"><time datetime="2018-10-18" itemprop="datePublished">2018-10-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div>| 1204字<div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="row"><script>$(function(){var s='\n\n            <p>传统方式中，许多人使用本地存储，来管理通过客户端验证生成的tokens。一个大问题是如何有更好的方式，来管理验证tokens，从而允许我们来存储更大的用户信息。</p>\n<p>这就是<a href="https://vuex.vuejs.org">Vuex</a>的作用。 Vuex为<a href="https://vuejs.org">Vue.js</a>应用管理状态.。对于应用中所有的组件来说，它被当做中央存储，并用规则确保状态只能以可预见的方式改变。</p>\n<p>对于经常检查本地存储来说，听起来是个更好的选择？让我们一起来探索下吧。</p>\n<h2>建立应用模块</h2>\n<p>对于这个项目，我们想创建一个使用vuex和<a href="https://router.vuejs.org/">vue-router</a>的vue应用。我们会使用vue cli 3.0 来创建一个vue项目，并从选项中选择路由和vuex。</p>\n<p>执行下面的命令开始创建:</p>\n<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vue create vue-auth</span>\n\n</code></pre><p>按照对话框的提示，添加必要的信息，并选择我们需要的选项，完成安装。</p>\n<p>下一步, 安装<a href="https://github.com/axios/axios">axios</a>:</p>\n<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm install axios --save</span>\n\n</code></pre><h3>配置Axios</h3>\n<p>我们在许多组件中都需要用到axios。让我们在全局整体来配置它，这样当我们需要它的时候，不用每次都去引入。</p>\n<p>打开 <code>./src/main.js</code> 文件，并且添加下面:</p>\n<pre><code class="hljs clean">[...]\n<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">\'./store\'</span>\n<span class="hljs-keyword">import</span> Axios <span class="hljs-keyword">from</span> <span class="hljs-string">\'axios\'</span>\n\nVue.prototype.$http = Axios;\nconst token = localStorage.getItem(<span class="hljs-string">\'token\'</span>)\n<span class="hljs-keyword">if</span> (token) {\n  Vue.prototype.$http.defaults.headers.common[<span class="hljs-string">\'Authorization\'</span>] = token\n}\n[...]\n\n</code></pre><p>现在，当我们想在组件内使用axios时, 我们可以用<code>this.$http</code> ，这样相当于直接是axios。我们也可以在axios头部给自己的token, 设置<code>身份验证</code>，这样如果token是必需的，我们的请求将处于控制中。在这种方式下，当我们想要发送请求时，任何时候都不用设置token。</p>\n<p>相关课程: <a href="https://bit.ly/2gCILn1">Vue创建一个网上商店</a></p>\n<p>完成之后，让我们使用服务器来处理身份验证。</p>\n<h2>创建身份验证服务</h2>\n<p>我已经写过关于这个，在我解释如何用vue-router来解决身份验证时。仔细看看<a href="https://scotch.io/tutorials/vue-authentication-and-route-handling-using-vue-router#toc-setup-nodejs-server">Setup Node.js Server</a> 这个章节。</p>\n<h2>创建组件</h2>\n<h3>登录组件</h3>\n<p>创建<code>Login.vue</code> 在 <code>./src/components</code> 目录下。 之后, 给登录页面添加模板:</p>\n<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n   <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"login"</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">"login"</span>&gt;</span>\n     <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Sign in<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n     <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">required</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Name"</span>/&gt;</span>\n     <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Password<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">required</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Password"</span>/&gt;</span>\n     <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>\n     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n   <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>\n <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n</code></pre><p>当你做完之后, 添加data属性，将其绑定到HTML表单中：</p>\n<pre><code class="hljs xml">[...]\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    data(){\n      <span class="hljs-keyword">return</span> {\n        <span class="hljs-attr">email</span> : <span class="hljs-string">""</span>,\n        <span class="hljs-attr">password</span> : <span class="hljs-string">""</span>\n      }\n    },\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n</code></pre><p>现在, 让我们给登录添加方法：</p>\n<pre><code class="hljs xml">[...]\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    [...]\n    methods: {\n      <span class="hljs-attr">login</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n        <span class="hljs-keyword">let</span> email = <span class="hljs-keyword">this</span>.email \n        <span class="hljs-keyword">let</span> password = <span class="hljs-keyword">this</span>.password\n        <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">\'login\'</span>, { email, password })\n       .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">\'/\'</span>))\n       .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err))\n      }\n    }\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n</code></pre><p>我们正在使用vuex的action — <code>login</code> 来解决身份验证。我们可以在将actions细化到回调里面，这样就可以在自己的组件里面做一些很酷的事情了。</p>\n<h3>注册组件</h3>\n<p>跟login组件类似，那我们给注册用户弄一个了。在组件目录里面创建<code>Register.vue</code> ，并将下面的添加进去：</p>\n<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>Register<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">"register"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"name"</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">required</span> <span class="hljs-attr">autofocus</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\n      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"email"</span> &gt;</span>E-Mail Address<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">required</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\n      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"password"</span>&gt;</span>Password<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">required</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\n      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"password-confirm"</span>&gt;</span>Confirm Password<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"password-confirm"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"password_confirmation"</span> <span class="hljs-attr">required</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n\n      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Register<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n</code></pre><p>让我们定义一下这些将绑定到表单里面的data属性:</p>\n<pre><code class="hljs xml">[...]\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    data(){\n      <span class="hljs-keyword">return</span> {\n        <span class="hljs-attr">name</span> : <span class="hljs-string">""</span>,\n        <span class="hljs-attr">email</span> : <span class="hljs-string">""</span>,\n        <span class="hljs-attr">password</span> : <span class="hljs-string">""</span>,\n        <span class="hljs-attr">password_confirmation</span> : <span class="hljs-string">""</span>,\n        <span class="hljs-attr">is_admin</span> : <span class="hljs-literal">null</span>\n      }\n    },\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n</code></pre><p>现在，让我们添加方法进去：</p>\n<pre><code class="hljs xml">[...]\n<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    [...]\n    methods: {\n      <span class="hljs-attr">register</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n        <span class="hljs-keyword">let</span> data = {\n          <span class="hljs-attr">name</span>: <span class="hljs-keyword">this</span>.name,\n          <span class="hljs-attr">email</span>: <span class="hljs-keyword">this</span>.email,\n          <span class="hljs-attr">password</span>: <span class="hljs-keyword">this</span>.password,\n          <span class="hljs-attr">is_admin</span>: <span class="hljs-keyword">this</span>.is_admin\n        }\n        <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">\'register\'</span>, data)\n       .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">\'/\'</span>))\n       .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err))\n      }\n    }\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n</code></pre><h3>安全组件</h3>\n<p>让我们创建一个普通的组件，它在用户通过验证后会显示。文件命名为<code>Secure.vue</code>，并添加下面的进去：</p>\n<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This page is protected by auth<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n</code></pre><h3>更新App组件</h3>\n<p>打开<code>./src/App.vue</code> 文件，并添加下面的进去:</p>\n<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"nav"</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |\n      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/about"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"isLoggedIn"</span>&gt;</span> | <span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"logout"</span>&gt;</span>Logout<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n</code></pre><p>如果用户登录进去后，你能看到关联的<code>Logout</code>了 吗？很好。</p>\n<p>现在，让我们给logout添加逻辑。</p>\n<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-attr">computed</span> : {\n      <span class="hljs-attr">isLoggedIn</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$store.getters.isLoggedIn}\n    },\n    <span class="hljs-attr">methods</span>: {\n      <span class="hljs-attr">logout</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n        <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">\'logout\'</span>)\n        .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n          <span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">\'/login\'</span>)\n        })\n      }\n    },\n  }\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n\n</code></pre><p>当用户点击退出按钮时，我们其实在做两件事 — 计算用户验证的状态和分发vuex store里面的退出事件。在退出之后，我们利用 <code>this.$router.push(\'/login\')</code>，切换用户到 <code>login</code>页面。当然你可以改变任何你想让用户跳转的地方。</p>\n<p>就是这样了。让我们用vuex构建权限模块。</p>\n<h2>Vuex权限模块</h2>\n<p>如果你读过以前的<a href="https://scotch.io/tutorials/vue-authentication-and-route-handling-using-vue-router#toc-setup-nodejs-server"><strong>Setup Node.js Server</strong></a> **部分, 你应该注意到我们需要在本地存储用户权限token，同时，当用户被授予权限后，我们随时需要重新得到token以及用户信息。</p>\n<p>首先, 让我们给vuex创建 <code>store.js</code>文件:</p>\n<pre><code class="hljs xquery"><span class="hljs-keyword">import</span> Vue from <span class="hljs-string">\'vue\'</span>\n<span class="hljs-keyword">import</span> Vuex from <span class="hljs-string">\'vuex\'</span>\n<span class="hljs-keyword">import</span> axios from <span class="hljs-string">\'axios\'</span>\n\nVue.use(Vuex)\n\nexport <span class="hljs-keyword">default</span> new Vuex.Store({\n  state: {\n    status: <span class="hljs-string">\'\'</span>,\n    token: localStorage.getItem(<span class="hljs-string">\'token\'</span>) || <span class="hljs-string">\'\'</span>,\n    user : {}\n  },\n  mutations: {\n\n  },\n  actions: {\n\n  },\n  getters : {\n\n  }\n})\n\n</code></pre><p>如果你注意到，我们同时引入了vue,vuex和axios，之后让vue使用vuex，这是因为它是很重要的一步。</p>\n<p>我们已经定义了state的属性。现在vuex的state能够支持验证状态， <code>jwt</code> token以及用户信息。</p>\n<h3>创建Vuex登录事件</h3>\n<p>Vuex actions里面主要是提交更改到vuex的store里面。我们将创建一个<code>login</code> 的action，它将使用服务器对用户进行身份验证，并向vuex存储提交用户凭据。打开<code>./src/store.js</code>文件，并添加下面到actions对象中：</p>\n<pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">login</span><span class="hljs-params">({commit}, user)</span></span>{\n    return new Promise((resolve, reject) =&gt; {\n      commit(<span class="hljs-string">\'auth_request\'</span>)\n      axios({url: <span class="hljs-string">\'http://localhost:3000/login\'</span>, data: user, method: <span class="hljs-string">\'POST\'</span> })\n      .then(resp =&gt; {\n        const token = resp<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.token</span>\n        const user = resp<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.user</span>\n        localStorage.setItem(<span class="hljs-string">\'token\'</span>, token)\n        axios<span class="hljs-selector-class">.defaults</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.common</span>[<span class="hljs-string">\'Authorization\'</span>] = token\n        commit(<span class="hljs-string">\'auth_success\'</span>, token, user)\n        resolve(resp)\n      })\n      .catch(err =&gt; {\n        commit(<span class="hljs-string">\'auth_error\'</span>)\n        localStorage.removeItem(<span class="hljs-string">\'token\'</span>)\n        reject(err)\n      })\n    })\n},\n\n</code></pre><p>登录action通过vuex <code>commit</code>验证，我们将用它进行触发更改。vuex store里面能记录这些更改的变化。</p>\n<p>我们正在调用服务器的登录路径并返回必要的数据。我们在本地存储token，之后通过<code>auth_success</code>来更新存储用户信息和token。在这一点上，我们也在头部设置了<code>axios</code> 。</p>\n<blockquote>\n<p>我们可以在vuex store中存储token，但是如果用户离开我们的应用，所有在vuex里面的存储都将消失。为了确保用户在有效时间内不用再重复登录，我们只能将token进行本地存储。</p>\n<p>重要的是你知道这些是如何工作的，这样你就能决定你到底想要实现什么。</p>\n</blockquote>\n<p>我们返回一个promise，这样我们能在用户登录完成后，做出响应。</p>\n<h3>创建Vuex<code>注册</code>事件</h3>\n<p>像 <code>login</code> 事件, the <code>register</code> 事件是同一种工作方式。在相同的文件中，添加下面的到actions对象里面:</p>\n<pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">register</span><span class="hljs-params">({commit}, user)</span></span>{\n  return new Promise((resolve, reject) =&gt; {\n    commit(<span class="hljs-string">\'auth_request\'</span>)\n    axios({url: <span class="hljs-string">\'http://localhost:3000/register\'</span>, data: user, method: <span class="hljs-string">\'POST\'</span> })\n    .then(resp =&gt; {\n      const token = resp<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.token</span>\n      const user = resp<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.user</span>\n      localStorage.setItem(<span class="hljs-string">\'token\'</span>, token)\n      axios<span class="hljs-selector-class">.defaults</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.common</span>[<span class="hljs-string">\'Authorization\'</span>] = token\n      commit(<span class="hljs-string">\'auth_success\'</span>, token, user)\n      resolve(resp)\n    })\n    .catch(err =&gt; {\n      commit(<span class="hljs-string">\'auth_error\'</span>, err)\n      localStorage.removeItem(<span class="hljs-string">\'token\'</span>)\n      reject(err)\n    })\n  })\n},\n\n</code></pre><p>它与<code>login</code> 事件工作方式很像,。称之为有共同的mutators的 <code>login</code> 和<code>register</code> ，具有相同的目标——让用户进入系统。</p>\n<h3>创建Vuex<code>退出</code>事件</h3>\n<p>我们希望用户能够退出系统，同时，我们希望销毁上一次验证的会话数据。在同一个<code>actions</code>对象中，添加下面：</p>\n<pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">logout</span><span class="hljs-params">({commit})</span></span>{\n  return new Promise((resolve, reject) =&gt; {\n    commit(<span class="hljs-string">\'logout\'</span>)\n    localStorage.removeItem(<span class="hljs-string">\'token\'</span>)\n    delete axios<span class="hljs-selector-class">.defaults</span><span class="hljs-selector-class">.headers</span><span class="hljs-selector-class">.common</span>[<span class="hljs-string">\'Authorization\'</span>]\n    resolve()\n  })\n}\n\n</code></pre><p>现在，当用户点击退出时，我们将移除之前在 <code>axios</code>头部设置的<code>jwt</code> token 。他们现在将无法执行需要token的事务。</p>\n<h3>创建Mutations</h3>\n<p>像我之前提到的，mutators是被用来改变vuex store的状态。让我们在应用中给用过的mutators定义。在mutators对象中，添加下面的：</p>\n<pre><code class="hljs pf">mutations: {\n  auth_request(<span class="hljs-keyword">state</span>){\n    <span class="hljs-keyword">state</span>.status = \'loading\'\n  },\n  auth_success(<span class="hljs-keyword">state</span>, token, <span class="hljs-keyword">user</span>){\n    <span class="hljs-keyword">state</span>.status = \'success\'\n    <span class="hljs-keyword">state</span>.token = token\n    <span class="hljs-keyword">state</span>.<span class="hljs-keyword">user</span> = <span class="hljs-keyword">user</span>\n  },\n  auth_error(<span class="hljs-keyword">state</span>){\n    <span class="hljs-keyword">state</span>.status = \'error\'\n  },\n  logout(<span class="hljs-keyword">state</span>){\n    <span class="hljs-keyword">state</span>.status = \'\'\n    <span class="hljs-keyword">state</span>.token = \'\'\n  },\n},\n\n</code></pre><h3>创建Getters</h3>\n<p>我们使用getter来获取vuex状态中的属性值。在这种情况下，getter的作用是将应用程序数据与应用程序逻辑分离，并确保我们不会泄露敏感信息。</p>\n<p>添加下面的到<code>getters</code> 对象中:</p>\n<pre><code class="hljs pf">getters : {\n  isLoggedIn: <span class="hljs-keyword">state</span> =&gt; !!<span class="hljs-keyword">state</span>.token,\n  authStatus: <span class="hljs-keyword">state</span> =&gt; <span class="hljs-keyword">state</span>.status,\n}\n\n</code></pre><p>你会同意我的观点，这是一种更简洁的访问存储数据的方式☺️.</p>\n<h2>在Auth后面隐藏页面</h2>\n<p>这篇文章的整个目的是实现身份验证，让没有权限的用户看不到某些页面。为了实现这个，我们需要知道用户想要访问的页面，以及当用户被授权时，我们有一定的方法来检验它。我们同时需要一定的方式，如果某些页面，授权或者未授权的用户可以单独或者同时访问的。这些都是很重要的考虑条件，幸运地是，我们可以通过vue-router来说实现。</p>\n<h3>定义路由给授权和未授权的页面</h3>\n<p>打开 <code>./src/router.js</code> 文件，并引入我们需要的这些:</p>\n<pre><code class="hljs clean"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">\'vue\'</span>\n<span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">\'vue-router\'</span>\n<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">\'./store.js\'</span>\n<span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">\'./views/Home.vue\'</span>\n<span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">\'./views/About.vue\'</span>\n<span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">\'./components/Login.vue\'</span>\n<span class="hljs-keyword">import</span> Secure <span class="hljs-keyword">from</span> <span class="hljs-string">\'./components/Secure.vue\'</span>\n<span class="hljs-keyword">import</span> Register <span class="hljs-keyword">from</span> <span class="hljs-string">\'./components/Register.vue\'</span>\n\nVue.use(Router)\n\n</code></pre><p>正如你看到的这样，我们已经引入vue,vue-router和我们创建的vuex。我们同时还引入了定义的所有组件，并设置vue中使用路由。</p>\n<p>让我们定义路由:</p>\n<pre><code class="hljs xl">[...]\nlet router = new Router({\n  mode: <span class="hljs-string">\'history\'</span>,\n  routes: [\n    {\n      <span class="hljs-built_in">path</span>: <span class="hljs-string">\'/\'</span>,\n      <span class="hljs-keyword">name</span>: <span class="hljs-string">\'home\'</span>,\n      component: Home\n    },\n    {\n      <span class="hljs-built_in">path</span>: <span class="hljs-string">\'/login\'</span>,\n      <span class="hljs-keyword">name</span>: <span class="hljs-string">\'login\'</span>,\n      component: Login\n    },\n    {\n      <span class="hljs-built_in">path</span>: <span class="hljs-string">\'/register\'</span>,\n      <span class="hljs-keyword">name</span>: <span class="hljs-string">\'register\'</span>,\n      component: Register\n    },\n    {\n      <span class="hljs-built_in">path</span>: <span class="hljs-string">\'/secure\'</span>,\n      <span class="hljs-keyword">name</span>: <span class="hljs-string">\'secure\'</span>,\n      component: Secure,\n      meta: { \n        requiresAuth: <span class="hljs-literal">true</span>\n      }\n    },\n    {\n      <span class="hljs-built_in">path</span>: <span class="hljs-string">\'/about\'</span>,\n      <span class="hljs-keyword">name</span>: <span class="hljs-string">\'about\'</span>,\n      component: About\n    }\n  ]\n})\n\nexport default router\n\n</code></pre><p>我们路由的定义是很普遍的。对于需要权限验证的路由，我们需要增加额外的数据，确保当用户访问它时，我们可以识别它。这是添加到路由定义中的元属性的本质。如果你想问<strong>_”我可以添加更过的数据给</strong>元数据<strong>并使用它吗?”</strong>，我很坚定的告诉你，这是绝对的😁。</p>\n<h3>解决未授权访问示例</h3>\n<p>我们有自己的路由定义。现在，让我们检验未授权访问并采取行动。在 <code>router.js</code>文件中，添加下面的在 <code>export default router</code>之前：</p>\n<pre><code class="hljs moonscript">router.beforeEach(<span class="hljs-function"><span class="hljs-params">(to, <span class="hljs-keyword">from</span>, <span class="hljs-built_in">next</span>)</span> =&gt;</span> {\n  <span class="hljs-keyword">if</span>(to.matched.some(record =&gt; record.meta.requiresAuth)) {\n    <span class="hljs-keyword">if</span> (store.getters.isLoggedIn) {\n      <span class="hljs-built_in">next</span>()\n      <span class="hljs-keyword">return</span>\n    }\n    <span class="hljs-built_in">next</span>(<span class="hljs-string">\'/login\'</span>) \n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-built_in">next</span>() \n  }\n})\n\n</code></pre><p>从这篇文章，通过使用vue router来进行身份验证，你可以回想一下我们这里有一个非常复杂的机制，它变得非常大，变得非常混乱。vuex已经帮我们简化了它，我们可以继续给路由添加任何条件。在我们的vuex存储中，我们可以定义操作来检查这些条件并获取返回它们的值。</p>\n<h3>解决Token过期示例</h3>\n<p>因为我们在本地存储token,它可以一直保留着。这意味着无论何时，我们打开自己的应用，它可以自动的验证用户，即使token已经过期失效。最多的情况是，我们的请求会因为无效token而持续失败。这对于用户是个不好的体验。</p>\n<p>现在, 打开<code>./src/App.vue</code> 文件并在script里面，添加下面的：</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n  [...]\n  created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">this</span>.$http.interceptors.response.use(<span class="hljs-literal">undefined</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{\n      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{\n        <span class="hljs-keyword">if</span> (err.status === <span class="hljs-number">401</span> &amp;&amp; err.config &amp;&amp; !err.config.__isRetryRequest) {\n          <span class="hljs-keyword">this</span>.$store.dispatch(logout)\n        }\n        <span class="hljs-keyword">throw</span> err;\n      });\n    });\n  }\n}\n\n</code></pre><p>我们截获axios请求，已确定是否获取到<code>401未授权</code>响应。如果这么做，我们分发 <code>logout</code> 事件，那么用户获得退出应用。这会让用户跳转到之前设计的 <code>login</code>页面，这样他们可以再次登录。</p>\n<p>我赞同这样会提升用户体验 ☺️.</p>\n<h2>结束</h2>\n<p>从以前的文章来看，您可以看到，基于vuex的引入，我们目前的应用程序发生了重大变化。现在，我们不依赖于一直检查token，不管到哪里都有混乱的条件。我们可以简单地使用vuex存储来管理权限，并且只需使用几行代码检查应用程序中的状态。</p>\n<p>我希望这可以帮助您建立更好的应用。</p>\n\n          \n';s=(s=(s=(s=s.replace(/"{/g,"{")).replace(/{"/g,"{")).replace(/"}/g,"}")).replace(/}"/g,"}"),$("#row").html(s)})</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/handling-authentication-in-vue-using-vuex">https://www.zcfy.cc/article/handling-authentication-in-vue-using-vuex</a> 原文标题: 使用Vuex解决Vue中的身份验证 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/bd062f28/" target="_blank">https://alili.tech/archive/bd062f28/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({el:".blog-post-comments",app_id:"ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz",app_key:"hLhtmd4tT0qJbyO2SgQ8odya",placeholder:"说点什么?",avatar:"retro",notify:!0,verify:!0})</script><ul id="more-post-list" class="archive readmore"><h3>推荐阅读</h3><li><a href="/archive/vi32h2qgdt/">JavaScript点击事件——美女合集<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/h1hfkoy4as/">Web UI 自动化测试技术选型<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/2ehenm5fx2r/">【基础】固定列宽的表格及示例演示<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/bp751dpaao6/">移动端开发单位——rem，动态使用<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/w0ea6x92n7j/">预告：Javascript全栈开发的系列文章<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/nh5d5ddjtjs/">CORS 跨域携带 Cookie 发送请求<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/32ufjbf3p3i/">ES6深入浅出 Generator<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/tgareq08se/">H5移动端开发<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/kuarhdceuz/">JS面试理论题<aside class="dates">2018-11-16</aside></a></li><li><a href="/archive/82gahy2bcol/">JavaScript ES6功能概述（ECMAScript 6和ES2015 &#43;）<aside class="dates">2018-11-16</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2018 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/js/main.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var d="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?05520debdbedd780ba345d83b7d5e6f4":"https://jspassport.ssl.qhimg.com/11.0.1.js?05520debdbedd780ba345d83b7d5e6f4";document.write('<script src="'+d+'" id="sozz"><\/script>')}()</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>