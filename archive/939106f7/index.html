<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="$(function(){ var html = &#34;\n\n \n\x3cp\x3e我是一名刚毕业的程序媛，面试的岗位是前端开发工程师，从17年初找实习开始，先后面试了50多家公司，加上123面，总共经历了上百场面试，其中包括百度，腾讯，阿里，滴滴，网易，美团等等，也面了一些中小公司的社招。\x3c\/p\x3e\n\x3cp\x3e总结一下面试遇到的问题，希望对大家助，本文很长很长很长（省略n个"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="总结了17年初到18年初百场前端面试的面试经验(含答案)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="$(function(){ var html = &#34;\n\n \n\x3cp\x3e我是一名刚毕业的程序媛，面试的岗位是前端开发工程师，从17年初找实习开始，先后面试了50多家公司，加上123面，总共经历了上百场面试，其中包括百度，腾讯，阿里，滴滴，网易，美团等等，也面了一些中小公司的社招。\x3c\/p\x3e\n\x3cp\x3e总结一下面试遇到的问题，希望对大家助，本文很长很长很长（省略n个"><meta property="og:site_name" content="Alili"><title>总结了17年初到18年初百场前端面试的面试经验(含答案) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/meslo-LG/styles.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad()</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error",function(e){var t=e.target;"img"==t.tagName.toLowerCase()&&(t.style.display="none")},!0)</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/939106f7/",
				"appid": "1613049289050283", 
				"title": "总结了17年初到18年初百场前端面试的面试经验(含答案) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-23T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/1e5cc6f0/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" href="https://alili.tech/archive/1d8dd1aa/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">Previous post</span> <span id="i-next" class="info" style="display:none">Next post</span> <span id="i-top" class="info" style="display:none">Back to top</span> <span id="i-share" class="info" style="display:none">Share post</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f939106f7%2f&text=%e6%80%bb%e7%bb%93%e4%ba%8617%e5%b9%b4%e5%88%9d%e5%88%b018%e5%b9%b4%e5%88%9d%e7%99%be%e5%9c%ba%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9a%84%e9%9d%a2%e8%af%95%e7%bb%8f%e9%aa%8c%28%e5%90%ab%e7%ad%94%e6%a1%88%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f939106f7%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f939106f7%2f&text=%e6%80%bb%e7%bb%93%e4%ba%8617%e5%b9%b4%e5%88%9d%e5%88%b018%e5%b9%b4%e5%88%9d%e7%99%be%e5%9c%ba%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9a%84%e9%9d%a2%e8%af%95%e7%bb%8f%e9%aa%8c%28%e5%90%ab%e7%ad%94%e6%a1%88%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f939106f7%2f&title=%e6%80%bb%e7%bb%93%e4%ba%8617%e5%b9%b4%e5%88%9d%e5%88%b018%e5%b9%b4%e5%88%9d%e7%99%be%e5%9c%ba%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9a%84%e9%9d%a2%e8%af%95%e7%bb%8f%e9%aa%8c%28%e5%90%ab%e7%ad%94%e6%a1%88%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f939106f7%2f&is_video=false&description=%e6%80%bb%e7%bb%93%e4%ba%8617%e5%b9%b4%e5%88%9d%e5%88%b018%e5%b9%b4%e5%88%9d%e7%99%be%e5%9c%ba%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9a%84%e9%9d%a2%e8%af%95%e7%bb%8f%e9%aa%8c%28%e5%90%ab%e7%ad%94%e6%a1%88%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%80%bb%e7%bb%93%e4%ba%8617%e5%b9%b4%e5%88%9d%e5%88%b018%e5%b9%b4%e5%88%9d%e7%99%be%e5%9c%ba%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9a%84%e9%9d%a2%e8%af%95%e7%bb%8f%e9%aa%8c%28%e5%90%ab%e7%ad%94%e6%a1%88%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f939106f7%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f939106f7%2f&title=%e6%80%bb%e7%bb%93%e4%ba%8617%e5%b9%b4%e5%88%9d%e5%88%b018%e5%b9%b4%e5%88%9d%e7%99%be%e5%9c%ba%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9a%84%e9%9d%a2%e8%af%95%e7%bb%8f%e9%aa%8c%28%e5%90%ab%e7%ad%94%e6%a1%88%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f939106f7%2f&title=%e6%80%bb%e7%bb%93%e4%ba%8617%e5%b9%b4%e5%88%9d%e5%88%b018%e5%b9%b4%e5%88%9d%e7%99%be%e5%9c%ba%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9a%84%e9%9d%a2%e8%af%95%e7%bb%8f%e9%aa%8c%28%e5%90%ab%e7%ad%94%e6%a1%88%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f939106f7%2f&title=%e6%80%bb%e7%bb%93%e4%ba%8617%e5%b9%b4%e5%88%9d%e5%88%b018%e5%b9%b4%e5%88%9d%e7%99%be%e5%9c%ba%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9a%84%e9%9d%a2%e8%af%95%e7%bb%8f%e9%aa%8c%28%e5%90%ab%e7%ad%94%e6%a1%88%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f939106f7%2f&title=%e6%80%bb%e7%bb%93%e4%ba%8617%e5%b9%b4%e5%88%9d%e5%88%b018%e5%b9%b4%e5%88%9d%e7%99%be%e5%9c%ba%e5%89%8d%e7%ab%af%e9%9d%a2%e8%af%95%e7%9a%84%e9%9d%a2%e8%af%95%e7%bb%8f%e9%aa%8c%28%e5%90%ab%e7%ad%94%e6%a1%88%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文链接">原文链接</a></li><li><a href="#原文标题">原文标题</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">总结了17年初到18年初百场前端面试的面试经验(含答案)</h1><div class="meta"><div class="postdate"><time datetime="2018-10-23" itemprop="datePublished">2018-10-23</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div>| 3308字<div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><script>$(function(){var s='\n\n                    \n<p>我是一名刚毕业的程序媛，面试的岗位是前端开发工程师，从17年初找实习开始，先后面试了50多家公司，加上123面，总共经历了上百场面试，其中包括百度，腾讯，阿里，滴滴，网易，美团等等，也面了一些中小公司的社招。</p>\n<p>总结一下面试遇到的问题，希望对大家助，本文很长很长很长（省略n个很长），但是看完的话，确实可以加深前端基础知识的理解，原文链接可以跳转(如果对您有帮助，请帮我点个star，定时更新)：</p>\n<p>同时我的博客地址是：<a href="https://github.com/forthealllight/blog" rel="nofollow noreferrer" target="_blank">https://github.com/forthealll...</a> 会定时更新一些学习心得，也欢迎star和fork</p>\n<h2 id="articleHeader0"><span style="font-weight:normal;">🌱</span> 文章列表</h2>\n<ul>\n<li><a href="https://github.com/forthealllight/blog/issues/15" rel="nofollow noreferrer" target="_blank">前端面试总结——基础javascript篇</a></li>\n<li><a href="https://github.com/forthealllight/blog/issues/18" rel="nofollow noreferrer" target="_blank">前端面试总结——进阶javascript篇</a></li>\n<li><a href="https://github.com/forthealllight/blog/issues/19" rel="nofollow noreferrer" target="_blank">前端面试总结——http、html和浏览器篇</a></li>\n<li><a href="https://github.com/forthealllight/blog/issues/20" rel="nofollow noreferrer" target="_blank">前端面试总结——css篇</a></li>\n</ul>\n<h2 id="articleHeader1">一、基础javascript篇</h2>\n<h3 id="articleHeader2">1. get请求传参长度的误区</h3>\n<p><strong><em>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。</em></strong></p>\n<p>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p>\n<ul>\n<li>HTTP 协议 未规定 GET 和POST的长度限制</li>\n<li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li>\n<li>不同的浏览器和WEB服务器，限制的最大长度不一样</li>\n<li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li>\n</ul>\n<h3 id="articleHeader3">2. 补充get和post请求在缓存方面的区别</h3>\n<p>post/get的请求区别，具体不再赘述。</p>\n<p>补充补充一个get和post在缓存方面的区别：</p>\n<ul>\n<li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li>\n<li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li>\n</ul>\n<h3 id="articleHeader4">3. 闭包</h3>\n<p>一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。</p>\n<h3 id="articleHeader5">4. 类的创建和继承</h3>\n<p>（1）类的创建（es5）：new一个function，在这个function的prototype里面增加属性和方法。</p>\n<p>下面来创建一个Animal类：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 定义一个动物类\nfunction Animal (name) {\n  // 属性\n  this.name = name || \'Animal\';\n  // 实例方法\n  this.sleep = function(){\n    console.log(this.name + \'正在睡觉！\');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function(food) {\n  console.log(this.name + \'正在吃：\' + food);\n};\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-comment">// 定义一个动物类</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span> (<span class="hljs-params">name</span>) </span>{\n  <span class="hljs-comment">// 属性</span>\n  <span class="hljs-keyword">this</span>.name = name || <span class="hljs-string">\'Animal\'</span>;\n  <span class="hljs-comment">// 实例方法</span>\n  <span class="hljs-keyword">this</span>.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">\'正在睡觉！\'</span>);\n  }\n}\n<span class="hljs-comment">// 原型方法</span>\nAnimal.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">food</span>) </span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">\'正在吃：\'</span> + food);\n};\n</code></pre>\n<p>这样就生成了一个Animal类，实力化生成对象后，有方法和属性。</p>\n<p>（2）类的继承——原型链继承</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="--原型链继承\nfunction Cat(){ }\nCat.prototype = new Animal();\nCat.prototype.name = \'cat\';\n//　Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.eat(\'fish\'));\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); //true \nconsole.log(cat instanceof Cat); //true\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stata"><code>--原型链继承\nfunction <span class="hljs-keyword">Cat</span>(){ }\n<span class="hljs-keyword">Cat</span>.prototype = new Animal();\n<span class="hljs-keyword">Cat</span>.prototype.name = \'<span class="hljs-keyword">cat</span>\';\n<span class="hljs-comment">//　Test Code</span>\n<span class="hljs-keyword">var</span> <span class="hljs-keyword">cat</span> = new <span class="hljs-keyword">Cat</span>();\nconsole.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span>.name);\nconsole.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span>.eat(\'fish\'));\nconsole.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span>.<span class="hljs-keyword">sleep</span>());\nconsole.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span> instanceof Animal); <span class="hljs-comment">//true </span>\nconsole.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span> instanceof <span class="hljs-keyword">Cat</span>); <span class="hljs-comment">//true</span>\n</code></pre>\n<ul>\n<li>介绍：在这里我们可以看到new了一个空对象,这个空对象指向Animal并且Cat.prototype指向了这个空对象，这种就是基于原型链的继承。</li>\n<li>特点：基于原型链，既是父类的实例，也是子类的实例</li>\n<li>缺点：无法实现多继承</li>\n</ul>\n<p>（3）构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Cat(name){\n  Animal.call(this);\n  this.name = name || \'Tom\';\n}\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>{\n  Animal.call(<span class="hljs-keyword">this</span>);\n  <span class="hljs-keyword">this</span>.name = name || <span class="hljs-string">\'Tom\'</span>;\n}\n<span class="hljs-comment">// Test Code</span>\n<span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();\n<span class="hljs-built_in">console</span>.log(cat.name);\n<span class="hljs-built_in">console</span>.log(cat.sleep());\n<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// false</span>\n<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// true</span>\n</code></pre>\n<ul>\n<li>特点：可以实现多继承</li>\n<li>缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。</li>\n</ul>\n<p>（4）实例继承和拷贝继承</p>\n<p>实例继承：为父类实例添加新特性，作为子类实例返回</p>\n<p>拷贝继承：拷贝父类元素上的属性和方法</p>\n<p>上述两个实用性不强，不一一举例。</p>\n<p>（5）组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Cat(name){\n  Animal.call(this);\n  this.name = name || \'Tom\';\n}\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stata"><code>function <span class="hljs-keyword">Cat</span>(name){\n  Animal.call(this);\n  this.name = name || \'Tom\';\n}\n<span class="hljs-keyword">Cat</span>.prototype = new Animal();\n<span class="hljs-keyword">Cat</span>.prototype.constructor = <span class="hljs-keyword">Cat</span>;\n<span class="hljs-comment">// Test Code</span>\n<span class="hljs-keyword">var</span> <span class="hljs-keyword">cat</span> = new <span class="hljs-keyword">Cat</span>();\nconsole.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span>.name);\nconsole.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span>.<span class="hljs-keyword">sleep</span>());\nconsole.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span> instanceof Animal); <span class="hljs-comment">// true</span>\nconsole.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span> instanceof <span class="hljs-keyword">Cat</span>); <span class="hljs-comment">// true</span>\n</code></pre>\n<ul>\n<li>特点：可以继承实例属性/方法，也可以继承原型属性/方法</li>\n<li>缺点：调用了两次父类构造函数，生成了两份实例</li>\n</ul>\n<p>（6）寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Cat(name){\n  Animal.call(this);\n  this.name = name || \'Tom\';\n}\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>{\n  Animal.call(<span class="hljs-keyword">this</span>);\n  <span class="hljs-keyword">this</span>.name = name || <span class="hljs-string">\'Tom\'</span>;\n}\n(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-comment">// 创建一个没有实例方法的类</span>\n  <span class="hljs-keyword">var</span> Super = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};\n  Super.prototype = Animal.prototype;\n  <span class="hljs-comment">//将实例作为子类的原型</span>\n  Cat.prototype = <span class="hljs-keyword">new</span> Super();\n})();\n<span class="hljs-comment">// Test Code</span>\n<span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();\n<span class="hljs-built_in">console</span>.log(cat.name);\n<span class="hljs-built_in">console</span>.log(cat.sleep());\n<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true</span>\n<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">//true</span>\n</code></pre>\n<ul><li>较为推荐</li></ul>\n<h3 id="articleHeader6">5. 如何解决异步回调地狱</h3>\n<p>promise、generator、async/await</p>\n<h3 id="articleHeader7">6. 说说前端中的事件流</h3>\n<p>HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。</p>\n<p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。</p>\n<ul>\n<li>事件捕获阶段</li>\n<li>处于目标阶段</li>\n<li>事件冒泡阶段</li>\n</ul>\n<p><strong>addEventListener</strong>：<strong>addEventListener</strong> 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</p>\n<p><strong>IE只支持事件冒泡</strong>。</p>\n<h3 id="articleHeader8">7. 如何让事件先冒泡后捕获</h3>\n<p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p>\n<h3 id="articleHeader9">8. 事件委托</h3>\n<ul>\n<li>简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</li>\n<li>举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</li>\n<li>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</li>\n</ul>\n<h3 id="articleHeader10">9. 图片的懒加载和预加载</h3>\n<ul>\n<li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</li>\n<li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</li>\n</ul>\n<p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。<br>懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>\n<h3 id="articleHeader11">10. mouseover和mouseenter的区别</h3>\n<ul>\n<li>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</li>\n<li>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</li>\n</ul>\n<h3 id="articleHeader12">11. js的new操作符做了哪些事情</h3>\n<p>new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。</p>\n<h3 id="articleHeader13">12.改变函数内部this指针的指向函数（bind，apply，call的区别）</h3>\n<ul>\n<li>通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2...这种形式。</li>\n<li>通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。</li>\n</ul>\n<h3 id="articleHeader14">13. js的各种位置，比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？</h3>\n<ul>\n<li>clientHeight：表示的是可视区域的高度，不包含border和滚动条</li>\n<li>offsetHeight：表示可视区域的高度，包含了border和滚动条</li>\n<li>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。</li>\n<li>clientTop：表示边框border的厚度，在未指定的情况下一般为0</li>\n<li>scrollTop：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高度。</li>\n</ul>\n<h3 id="articleHeader15">14. js拖拽功能的实现</h3>\n<ul><li>首先是三个事件，分别是mousedown，mousemove，mouseup</li></ul>\n<p>当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。</p>\n<ul>\n<li>clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，移动的举例应该是：<p><strong>鼠标移动时候的坐标-鼠标按下去时候的坐标。</strong></p>\n<p>也就是说定位信息为： </p>\n<p>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.</p>\n</li>\n<li>还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的left<br>   以及top等等值。</li>\n</ul>\n<p>补充：也可以通过html5的拖放（Drag 和 drop）来实现</p>\n<h2 id="articleHeader16">二、进阶javascript篇</h2>\n<h3 id="articleHeader17">1.自己实现一个bind函数</h3>\n<p><strong><em>原理：通过apply或者call方法来实现。</em></strong></p>\n<h4>(1)初始版本</h4>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Function.prototype.bind=function(obj,arg){\n  var arg=Array.prototype.slice.call(arguments,1);\n  var context=this;\n  return function(newArg){\n    arg=arg.concat(Array.prototype.slice.call(newArg));\n    return context.apply(obj,arg);\n  }\n}" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs haxe"><code>Function.prototype.bind=<span class="hljs-function"><span class="hljs-keyword">function</span></span>(obj,arg){\n  <span class="hljs-keyword">var</span> arg=<span class="hljs-keyword">Array</span>.prototype.slice.call(arguments,<span class="hljs-number">1</span>);\n  <span class="hljs-keyword">var</span> context=<span class="hljs-built_in">this</span>;\n  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span>(<span class="hljs-keyword">new</span><span class="hljs-type">Arg</span>){\n    arg=arg.concat(<span class="hljs-keyword">Array</span>.prototype.slice.call(<span class="hljs-keyword">new</span><span class="hljs-type">Arg</span>));\n    <span class="hljs-keyword">return</span> context.apply(obj,arg);\n  }\n}</code></pre>\n<h4>(2) 考虑到原型链</h4>\n<p><strong><em>为什么要考虑？因为在new 一个bind过生成的新函数的时候，必须的条件是要继承原函数的原型</em></strong></p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Function.prototype.bind=function(obj,arg){\n  var arg=Array.prototype.slice.call(arguments,1);\n  var context=this;\n  var bound=function(newArg){\n    arg=arg.concat(Array.prototype.slice.call(newArg));\n    return context.apply(obj,arg);\n  }\n  var F=function(){}\n  //这里需要一个寄生组合继承\n  F.prototype=context.prototype;\n  bound.prototype=new F();\n  return bound;\n}\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs haxe"><code>Function.prototype.bind=<span class="hljs-function"><span class="hljs-keyword">function</span></span>(obj,arg){\n  <span class="hljs-keyword">var</span> arg=<span class="hljs-keyword">Array</span>.prototype.slice.call(arguments,<span class="hljs-number">1</span>);\n  <span class="hljs-keyword">var</span> context=<span class="hljs-built_in">this</span>;\n  <span class="hljs-keyword">var</span> bound=<span class="hljs-function"><span class="hljs-keyword">function</span></span>(<span class="hljs-keyword">new</span><span class="hljs-type">Arg</span>){\n    arg=arg.concat(<span class="hljs-keyword">Array</span>.prototype.slice.call(<span class="hljs-keyword">new</span><span class="hljs-type">Arg</span>));\n    <span class="hljs-keyword">return</span> context.apply(obj,arg);\n  }\n  <span class="hljs-keyword">var</span> F=<span class="hljs-function"><span class="hljs-keyword">function</span></span>(){}\n  <span class="hljs-comment">//这里需要一个寄生组合继承</span>\n  F.prototype=context.prototype;\n  bound.prototype=<span class="hljs-keyword">new</span> <span class="hljs-type">F</span>();\n  <span class="hljs-keyword">return</span> bound;\n}\n</code></pre>\n<h3 id="articleHeader18">2.用setTimeout来实现setInterval</h3>\n<h4>(1)用setTimeout()方法来模拟setInterval()与setInterval()之间的什么区别？</h4>\n<p>首先来看setInterval的缺陷，使用setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个问题在于：如果定时器代码在代码再次添加到队列之前还没完成执行，结果就会导致定时器代码连续运行好几次。而之间没有间隔。不过幸运的是：javascript引擎足够聪明，能够避免这个问题。当且仅当没有该定时器的如何代码实例时，才会将定时器代码添加到队列中。这确保了定时器代码加入队列中最小的时间间隔为指定时间。</p>\n<p>这种重复定时器的规则有两个问题：<strong><em>1.某些间隔会被跳过 2.多个定时器的代码执行时间可能会比预期小。</em></strong></p>\n<p>下面举例子说明： </p>\n<p>假设，某个onclick事件处理程序使用啦setInterval()来设置了一个200ms的重复定时器。如果事件处理程序花了300ms多一点的时间完成。</p>\n<p>&lt;img width="626" alt="2018-07-10 11 36 43" src="<a href="https://user-gold-cdn.xitu.io/2018/7/10/1648412f2eb805ec?w=1252&amp;amp" rel="nofollow noreferrer" target="_blank">https://user-gold-cdn.xitu.io...</a>;h=498&amp;f=png&amp;s=326047"&gt;</p>\n<p>这个例子中的第一个定时器是在205ms处添加到队列中，但是要过300ms才能执行。在405ms又添加了一个副本。在一个间隔，605ms处，第一个定时器代码还在执行中，而且队列中已经有了一个定时器实例，结果是605ms的定时器代码不会添加到队列中。结果是在5ms处添加的定时器代码执行结束后，405处的代码立即执行。</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function say(){\n  //something\n  setTimeout(say,200);\n}\nsetTimeout(say,200)\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs actionscript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>{\n  <span class="hljs-comment">//something</span>\n  setTimeout(say,<span class="hljs-number">200</span>);\n}\nsetTimeout(say,<span class="hljs-number">200</span>)\n</code></pre>\n<p>或者</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="setTimeout(function(){\n   //do something\n   setTimeout(arguments.callee,200);\n},200);\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n   <span class="hljs-comment">//do something</span>\n   setTimeout(<span class="hljs-built_in">arguments</span>.callee,<span class="hljs-number">200</span>);\n},<span class="hljs-number">200</span>);\n</code></pre>\n<h3 id="articleHeader19">3.js怎么控制一次加载一张图片，加载完后再加载下一张</h3>\n<h4>(1)方法1</h4>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<script type=&quot;text/javascript&quot;>\nvar obj=new Image();\nobj.src=&quot;http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg&quot;;\nobj.onload=function(){\nalert(\'图片的宽度为：\'+obj.width+\'；图片的高度为：\'+obj.height);\ndocument.getElementById(&quot;mypic&quot;).innnerHTML=&quot;<img src=\'&quot;+this.src+&quot;\' />&quot;;\n}\n<\/script>\n<div id=&quot;mypic&quot;>onloading……</div>\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">var</span> obj=<span class="hljs-keyword">new</span> Image();\nobj.src=<span class="hljs-string">"http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg"</span>;\nobj.onload=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\nalert(<span class="hljs-string">\'图片的宽度为：\'</span>+obj.width+<span class="hljs-string">\'；图片的高度为：\'</span>+obj.height);\n<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"mypic"</span>).innnerHTML=<span class="hljs-string">"&lt;img src=\'"</span>+<span class="hljs-keyword">this</span>.src+<span class="hljs-string">"\' /&gt;"</span>;\n}\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mypic"</span>&gt;</span>onloading……<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<h4>(2)方法2</h4>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<script type=&quot;text/javascript&quot;>\nvar obj=new Image();\nobj.src=&quot;http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg&quot;;\nobj.onreadystatechange=function(){\nif(this.readyState==&quot;complete&quot;){\nalert(\'图片的宽度为：\'+obj.width+\'；图片的高度为：\'+obj.height);\ndocument.getElementById(&quot;mypic&quot;).innnerHTML=&quot;<img src=\'&quot;+this.src+&quot;\' />&quot;;\n}\n}\n<\/script>\n<div id=&quot;mypic&quot;>onloading……</div>\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">\n<span class="hljs-keyword">var</span> obj=<span class="hljs-keyword">new</span> Image();\nobj.src=<span class="hljs-string">"http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg"</span>;\nobj.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n<span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.readyState==<span class="hljs-string">"complete"</span>){\nalert(<span class="hljs-string">\'图片的宽度为：\'</span>+obj.width+<span class="hljs-string">\'；图片的高度为：\'</span>+obj.height);\n<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"mypic"</span>).innnerHTML=<span class="hljs-string">"&lt;img src=\'"</span>+<span class="hljs-keyword">this</span>.src+<span class="hljs-string">"\' /&gt;"</span>;\n}\n}\n</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mypic"</span>&gt;</span>onloading……<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<h3 id="articleHeader20">3.代码的执行顺序</h3>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="setTimeout(function(){console.log(1)},0);\nnew Promise(function(resolve,reject){\n   console.log(2);\n   resolve();\n}).then(function(){console.log(3)\n}).then(function(){console.log(4)});\n\nprocess.nextTick(function(){console.log(5)});\n\nconsole.log(6);\n//输出2,6,5,3,4,1\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)},<span class="hljs-number">0</span>);\n<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>{\n   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);\n   resolve();\n}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)\n}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)});\n\nprocess.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)});\n\n<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);\n<span class="hljs-comment">//输出2,6,5,3,4,1</span>\n</code></pre>\n<p>为什么呢？具体请参考我的文章：[<br>从promise、process.nextTick、setTimeout出发，谈谈Event Loop中的Job queue](<a href="https://github.com/forthealllight/blog/issues/5)" rel="nofollow noreferrer" target="_blank">https://github.com/forthealll...</a></p>\n<h3 id="articleHeader21">4.如何实现sleep的效果（es5或者es6）</h3>\n<h4>(1)while循环的方式</h4>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function sleep(ms){\n   var start=Date.now(),expire=start+ms;\n   while(Date.now()<expire);\n   console.log(\'1111\');\n   return;\n}\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>)</span>{\n   <span class="hljs-keyword">var</span> start=<span class="hljs-built_in">Date</span>.now(),expire=start+ms;\n   <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Date</span>.now()&lt;expire);\n   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'1111\'</span>);\n   <span class="hljs-keyword">return</span>;\n}\n</code></pre>\n<p>执行sleep(1000)之后，休眠了1000ms之后输出了1111。上述循环的方式缺点很明显，容易造成死循环。</p>\n<h3 id="articleHeader22">(2)通过promise来实现</h3>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function sleep(ms){\n  var temple=new Promise(\n  (resolve)=>{\n  console.log(111);setTimeout(resolve,ms)\n  });\n  return temple\n}\nsleep(500).then(function(){\n   //console.log(222)\n})\n//先输出了111，延迟500ms后输出222\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>)</span>{\n  <span class="hljs-keyword">var</span> temple=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(\n  <span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>{\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);setTimeout(resolve,ms)\n  });\n  <span class="hljs-keyword">return</span> temple\n}\nsleep(<span class="hljs-number">500</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n   <span class="hljs-comment">//console.log(222)</span>\n})\n<span class="hljs-comment">//先输出了111，延迟500ms后输出222</span>\n</code></pre>\n<h3 id="articleHeader23">(3)通过async封装</h3>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function sleep(ms){\n  return new Promise((resolve)=>setTimeout(resolve,ms));\n}\nasync function test(){\n  var temple=await sleep(1000);\n  console.log(1111)\n  return temple\n}\ntest();\n//延迟1000ms输出了1111\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>)</span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>setTimeout(resolve,ms));\n}\n<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">var</span> temple=<span class="hljs-keyword">await</span> sleep(<span class="hljs-number">1000</span>);\n  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1111</span>)\n  <span class="hljs-keyword">return</span> temple\n}\ntest();\n<span class="hljs-comment">//延迟1000ms输出了1111</span>\n</code></pre>\n<h4>(4).通过generate来实现</h4>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function* sleep(ms){\n   yield new Promise(function(resolve,reject){\n             console.log(111);\n             setTimeout(resolve,ms);\n        })  \n}\nsleep(500).next().value.then(function(){console.log(2222)})\n\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>)</span>{\n   <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>{\n             <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);\n             setTimeout(resolve,ms);\n        })  \n}\nsleep(<span class="hljs-number">500</span>).next().value.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2222</span>)})\n\n</code></pre>\n<h3 id="articleHeader24">5.简单的实现一个promise</h3>\n<p>首先明确什么是promiseA+规范，参考规范的地址：</p>\n<p><a href="https://promisesaplus.com/" rel="nofollow noreferrer" target="_blank">primiseA+规范</a></p>\n<p>如何实现一个promise，参考我的文章：</p>\n<p><a href="https://github.com/forthealllight/blog/issues/4" rel="nofollow noreferrer" target="_blank">实现一个完美符合Promise/A+规范的Promise</a></p>\n<p>一般不会问的很详细，只要能写出上述文章中的v1.0版本的简单promise即可。</p>\n<h3 id="articleHeader25">6.Function.__proto__(getPrototypeOf)是什么？</h3>\n<p>获取一个对象的原型，在chrome中可以通过__proto__的形式，或者在ES6中可以通过Object.getPrototypeOf的形式。</p>\n<p>那么Function.proto是什么么？也就是说Function由什么对象继承而来，我们来做如下判别。</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Function.__proto__==Object.prototype //false\nFunction.__proto__==Function.prototype//true\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs monkey"><code><span class="hljs-function"><span class="hljs-keyword">Function</span>.<span class="hljs-title">__proto__</span>=</span>=Object.prototype //<span class="hljs-literal">false</span>\n<span class="hljs-function"><span class="hljs-keyword">Function</span>.<span class="hljs-title">__proto__</span>=</span>=<span class="hljs-function"><span class="hljs-keyword">Function</span>.<span class="hljs-title">prototype</span>//<span class="hljs-title">true</span></span>\n</code></pre>\n<p>我们发现Function的原型也是Function。</p>\n<p>我们用图可以来明确这个关系：</p>\n<p>&lt;img width="646" alt="2018-07-10 2 38 27" src="<a href="https://user-gold-cdn.xitu.io/2018/7/10/1648412f2ed72c1d?w=1292&amp;amp" rel="nofollow noreferrer" target="_blank">https://user-gold-cdn.xitu.io...</a>;h=1028&amp;f=png&amp;s=183106"&gt;</p>\n<h3 id="articleHeader26">7.实现js中所有对象的深度克隆（包装对象，Date对象，正则对象）</h3>\n<p>通过递归可以简单实现对象的深度克隆，但是这种方法不管是ES6还是ES5实现，都有同样的缺陷，就是只能实现特定的object的深度复制（比如数组和函数），不能实现包装对象Number，String ， Boolean，以及Date对象，RegExp对象的复制。</p>\n<h4>(1)前文的方法</h4>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function deepClone(obj){\n    var newObj= obj instanceof Array?[]:{};\n    for(var i in obj){\n       newObj[i]=typeof obj[i]==\'object\'?  \n       deepClone(obj[i]):obj[i];    \n    }\n    return newObj;\n}\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs haxe"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span></span>(obj){\n    <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>= obj instanceof <span class="hljs-keyword">Array</span>?[]:<span class="hljs-type"></span>{};\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> obj){\n       <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>[i]=typeof obj[i]==<span class="hljs-string">\'object\'</span>?  \n       deepClone(obj[i]):<span class="hljs-type">obj</span>[i];    \n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>;\n}\n</code></pre>\n<p>这种方法可以实现一般对象和数组对象的克隆，比如：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var arr=[1,2,3];\nvar newArr=deepClone(arr);\n// newArr->[1,2,3]\n\nvar obj={\n   x:1,\n   y:2\n}\nvar newObj=deepClone(obj);\n// newObj={x:1,y:2}\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs haxe"><code><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];\n<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>=deepClone(arr);\n<span class="hljs-comment">// newArr-&gt;[1,2,3]</span>\n\n<span class="hljs-keyword">var</span> obj={\n   x:<span class="hljs-type">1</span>,\n   y:<span class="hljs-type">2</span>\n}\n<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>=deepClone(obj);\n<span class="hljs-comment">// newObj={x:1,y:2}</span>\n</code></pre>\n<p>但是不能实现例如包装对象Number,String,Boolean,以及正则对象RegExp和Date对象的克隆，比如：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//Number包装对象\nvar num=new Number(1);\ntypeof num // &quot;object&quot;\n\nvar newNum=deepClone(num);\n//newNum ->  {} 空对象\n\n//String包装对象\nvar str=new String(&quot;hello&quot;);\ntypeof str //&quot;object&quot;\n\nvar newStr=deepClone(str);\n//newStr->  {0:\'h\',1:\'e\',2:\'l\',3:\'l\',4:\'o\'};\n\n//Boolean包装对象\nvar bol=new Boolean(true);\ntypeof bol //&quot;object&quot;\n\nvar newBol=deepClone(bol);\n// newBol ->{} 空对象\n\n....\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs haxe"><code><span class="hljs-comment">//Number包装对象</span>\n<span class="hljs-keyword">var</span> num=<span class="hljs-keyword">new</span> <span class="hljs-type">Number</span>(<span class="hljs-number">1</span>);\ntypeof num <span class="hljs-comment">// "object"</span>\n\n<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Num</span>=deepClone(num);\n<span class="hljs-comment">//newNum -&gt;  {} 空对象</span>\n\n<span class="hljs-comment">//String包装对象</span>\n<span class="hljs-keyword">var</span> str=<span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(<span class="hljs-string">"hello"</span>);\ntypeof str <span class="hljs-comment">//"object"</span>\n\n<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Str</span>=deepClone(str);\n<span class="hljs-comment">//newStr-&gt;  {0:\'h\',1:\'e\',2:\'l\',3:\'l\',4:\'o\'};</span>\n\n<span class="hljs-comment">//Boolean包装对象</span>\n<span class="hljs-keyword">var</span> bol=<span class="hljs-keyword">new</span> <span class="hljs-type">Boolean</span>(<span class="hljs-literal">true</span>);\ntypeof bol <span class="hljs-comment">//"object"</span>\n\n<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Bol</span>=deepClone(bol);\n<span class="hljs-comment">// newBol -&gt;{} 空对象</span>\n\n....\n</code></pre>\n<h4>(2)valueof()函数</h4>\n<p>所有对象都有valueOf方法，valueOf方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valueOf()方法只是简单返回这个对象本身。</p>\n<p>对于原始值或者包装类：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function baseClone(base){\n return base.valueOf();\n}\n\n//Number\nvar num=new Number(1);\nvar newNum=baseClone(num);\n//newNum->1\n\n//String\nvar str=new String(\'hello\');\nvar newStr=baseClone(str);\n// newStr->&quot;hello&quot;\n\n//Boolean\nvar bol=new Boolean(true);\nvar newBol=baseClone(bol);\n//newBol-> true\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs haxe"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseClone</span></span>(base){\n <span class="hljs-keyword">return</span> base.valueOf();\n}\n\n<span class="hljs-comment">//Number</span>\n<span class="hljs-keyword">var</span> num=<span class="hljs-keyword">new</span> <span class="hljs-type">Number</span>(<span class="hljs-number">1</span>);\n<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Num</span>=baseClone(num);\n<span class="hljs-comment">//newNum-&gt;1</span>\n\n<span class="hljs-comment">//String</span>\n<span class="hljs-keyword">var</span> str=<span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(<span class="hljs-string">\'hello\'</span>);\n<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Str</span>=baseClone(str);\n<span class="hljs-comment">// newStr-&gt;"hello"</span>\n\n<span class="hljs-comment">//Boolean</span>\n<span class="hljs-keyword">var</span> bol=<span class="hljs-keyword">new</span> <span class="hljs-type">Boolean</span>(<span class="hljs-literal">true</span>);\n<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Bol</span>=baseClone(bol);\n<span class="hljs-comment">//newBol-&gt; true</span>\n</code></pre>\n<p>其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说，</p>\n<p>这里用valueOf实现，语法上比较符合规范。</p>\n<p>对于Date类型：</p>\n<p>因为valueOf方法，日期类定义的valueOf()方法会返回它的一个内部表示：1970年1月1日以来的毫秒数.因此我们可以在Date的原型上定义克隆的方法：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Date.prototype.clone=function(){\n  return new Date(this.valueOf());\n}\n\nvar date=new Date(\'2010\');\nvar newDate=date.clone();\n// newDate->  Fri Jan 01 2010 08:00:00 GMT+0800 \n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs qml"><code><span class="hljs-built_in">Date</span>.prototype.clone=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">this</span>.valueOf());\n}\n\n<span class="hljs-built_in">var</span> <span class="hljs-built_in">date</span>=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">\'2010\'</span>);\n<span class="hljs-built_in">var</span> newDate=<span class="hljs-built_in">date</span>.clone();\n<span class="hljs-comment">// newDate-&gt;  Fri Jan 01 2010 08:00:00 GMT+0800 </span>\n</code></pre>\n<p>对于正则对象RegExp：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="RegExp.prototype.clone = function() {\nvar pattern = this.valueOf();\nvar flags = \'\';\nflags += pattern.global ? \'g\' : \'\';\nflags += pattern.ignoreCase ? \'i\' : \'\';\nflags += pattern.multiline ? \'m\' : \'\';\nreturn new RegExp(pattern.source, flags);\n};\n\nvar reg=new RegExp(\'/111/\');\nvar newReg=reg.clone();\n//newReg->  /\\/111\\//\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-built_in">RegExp</span>.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n<span class="hljs-keyword">var</span> pattern = <span class="hljs-keyword">this</span>.valueOf();\n<span class="hljs-keyword">var</span> flags = <span class="hljs-string">\'\'</span>;\nflags += pattern.global ? <span class="hljs-string">\'g\'</span> : <span class="hljs-string">\'\'</span>;\nflags += pattern.ignoreCase ? <span class="hljs-string">\'i\'</span> : <span class="hljs-string">\'\'</span>;\nflags += pattern.multiline ? <span class="hljs-string">\'m\'</span> : <span class="hljs-string">\'\'</span>;\n<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(pattern.source, flags);\n};\n\n<span class="hljs-keyword">var</span> reg=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">\'/111/\'</span>);\n<span class="hljs-keyword">var</span> newReg=reg.clone();\n<span class="hljs-comment">//newReg-&gt;  /\\/111\\//</span>\n</code></pre>\n<h3 id="articleHeader27">8.简单实现Node的Events模块</h3>\n<p>简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p>\n<p>node中的Events模块就是通过观察者模式来实现的：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var events=require(\'events\');\nvar eventEmitter=new events.EventEmitter();\neventEmitter.on(\'say\',function(name){\n    console.log(\'Hello\',name);\n})\neventEmitter.emit(\'say\',\'Jony yu\');\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> events=<span class="hljs-built_in">require</span>(<span class="hljs-string">\'events\'</span>);\n<span class="hljs-keyword">var</span> eventEmitter=<span class="hljs-keyword">new</span> events.EventEmitter();\neventEmitter.on(<span class="hljs-string">\'say\'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Hello\'</span>,name);\n})\neventEmitter.emit(<span class="hljs-string">\'say\'</span>,<span class="hljs-string">\'Jony yu\'</span>);\n</code></pre>\n<p>这样，eventEmitter发出say事件，通过On接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个Events模块的EventEmitter。</p>\n<h4>(1)实现简单的Event模块的emit和on方法</h4>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Events(){\nthis.on=function(eventName,callBack){\n  if(!this.handles){\n    this.handles={};\n  }\n  if(!this.handles[eventName]){\n    this.handles[eventName]=[];\n  }\n  this.handles[eventName].push(callBack);\n}\nthis.emit=function(eventName,obj){\n   if(this.handles[eventName]){\n     for(var i=0;o<this.handles[eventName].length;i++){\n       this.handles[eventName][i](obj);\n     }\n   }\n}\nreturn this;\n}\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs kotlin"><code>function Events(){\n<span class="hljs-keyword">this</span>.on=function(eventName,callBack){\n  <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.handles){\n    <span class="hljs-keyword">this</span>.handles={};\n  }\n  <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.handles[eventName]){\n    <span class="hljs-keyword">this</span>.handles[eventName]=[];\n  }\n  <span class="hljs-keyword">this</span>.handles[eventName].push(callBack);\n}\n<span class="hljs-keyword">this</span>.emit=function(eventName,obj){\n   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.handles[eventName]){\n     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;o&lt;<span class="hljs-keyword">this</span>.handles[eventName].length;i++){\n       <span class="hljs-keyword">this</span>.handles[eventName][i](obj);\n     }\n   }\n}\n<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;\n}\n</code></pre>\n<p>这样我们就定义了Events，现在我们可以开始来调用：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=" var events=new Events();\n events.on(\'say\',function(name){\n    console.log(\'Hello\',nama)\n });\n events.emit(\'say\',\'Jony yu\');\n //结果就是通过emit调用之后，输出了Jony yu\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code> <span class="hljs-keyword">var</span> events=<span class="hljs-keyword">new</span> Events();\n events.on(<span class="hljs-string">\'say\'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Hello\'</span>,nama)\n });\n events.emit(<span class="hljs-string">\'say\'</span>,<span class="hljs-string">\'Jony yu\'</span>);\n <span class="hljs-comment">//结果就是通过emit调用之后，输出了Jony yu</span>\n</code></pre>\n<h4>(2)每个对象是独立的</h4>\n<p>因为是通过new的方式，每次生成的对象都是不相同的，因此：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var event1=new Events();\nvar event2=new Events();\nevent1.on(\'say\',function(){\n    console.log(\'Jony event1\');\n});\nevent2.on(\'say\',function(){\n    console.log(\'Jony event2\');\n})\nevent1.emit(\'say\');\nevent2.emit(\'say\');\n//event1、event2之间的事件监听互相不影响\n//输出结果为\'Jony event1\' \'Jony event2\'\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> event1=<span class="hljs-keyword">new</span> Events();\n<span class="hljs-keyword">var</span> event2=<span class="hljs-keyword">new</span> Events();\nevent1.on(<span class="hljs-string">\'say\'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Jony event1\'</span>);\n});\nevent2.on(<span class="hljs-string">\'say\'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Jony event2\'</span>);\n})\nevent1.emit(<span class="hljs-string">\'say\'</span>);\nevent2.emit(<span class="hljs-string">\'say\'</span>);\n<span class="hljs-comment">//event1、event2之间的事件监听互相不影响</span>\n<span class="hljs-comment">//输出结果为\'Jony event1\' \'Jony event2\'</span>\n</code></pre>\n<h3 id="articleHeader28">9.箭头函数中this指向举例</h3>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var a=11;\nfunction test2(){\n  this.a=22;\n  let b=()=>{console.log(this.a)}\n  b();\n}\nvar x=new test2();\n//输出22\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> a=<span class="hljs-number">11</span>;\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span>(<span class="hljs-params"></span>)</span>{\n  <span class="hljs-keyword">this</span>.a=<span class="hljs-number">22</span>;\n  <span class="hljs-keyword">let</span> b=<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)}\n  b();\n}\n<span class="hljs-keyword">var</span> x=<span class="hljs-keyword">new</span> test2();\n<span class="hljs-comment">//输出22</span>\n</code></pre>\n<p>定义时绑定。</p>\n<h2 id="articleHeader29">三、http、html和浏览器篇</h2>\n<h3 id="articleHeader30">1.http和https</h3>\n<p><strong><em>https的SSL加密是在传输层实现的。</em></strong></p>\n<h4>(1)http和https的基本概念</h4>\n<p>http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>\n<p>https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>\n<p>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p>\n<h4>(2)http和https的区别？</h4>\n<p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。<br>主要的区别如下：</p>\n<ul>\n<li>Https协议需要ca证书，费用较高。</li>\n<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>\n<li>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443</li>\n<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>\n</ul>\n<h4>(3)https协议的工作原理</h4>\n<p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p>\n<ul>\n<li>客户使用https url访问服务器，则要求web 服务器建立ssl链接。</li>\n<li>web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</li>\n<li>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</li>\n<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>\n<li>web服务器通过自己的私钥解密出会话密钥。</li>\n<li>web服务器通过会话密钥加密与客户端之间的通信。</li>\n</ul>\n<h4>(4)https协议的优点</h4>\n<ul>\n<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>\n<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>\n<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>\n<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>\n</ul>\n<h4>(5)https协议的缺点</h4>\n<ul>\n<li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li>\n<li>https缓存不如http高效，会增加数据开销。</li>\n<li>SSL证书也需要钱，功能越强大的证书费用越高。</li>\n<li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li>\n</ul>\n<h3 id="articleHeader31">2.tcp三次握手，一句话概括</h3>\n<p><strong><em>客户端和服务端都需要直到各自可收发，因此需要三次握手。</em></strong></p>\n<p>简化三次握手：</p>\n<p>&lt;img width="487" alt="2018-07-10 3 42 11" src="<a href="https://user-gold-cdn.xitu.io/2018/7/10/16484133eee33c76?w=974&amp;amp" rel="nofollow noreferrer" target="_blank">https://user-gold-cdn.xitu.io...</a>;h=1038&amp;f=png&amp;s=94703"&gt;</p>\n<p>从图片可以得到三次握手可以简化为：C发起请求连接S确认，也发起连接C确认我们再看看每次握手的作用：第一次握手：S只可以确认 自己可以接受C发送的报文段第二次握手：C可以确认 S收到了自己发送的报文段，并且可以确认 自己可以接受S发送的报文段第三次握手：S可以确认 C收到了自己发送的报文段</p>\n<h3 id="articleHeader32">3.TCP和UDP的区别</h3>\n<p>（1）TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。</p>\n<p>（2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。</p>\n<p>（3）TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。</p>\n<p>（4）TCP只能是1对1的，UDP支持1对1,1对多。</p>\n<p>（5）TCP的首部较大为20字节，而UDP只有8字节。</p>\n<p>（6）TCP是面向连接的可靠性传输，而UDP是不可靠的。</p>\n<h3 id="articleHeader33">4.WebSocket的实现和应用</h3>\n<h4>(1)什么是WebSocket?</h4>\n<p>WebSocket是HTML5中的协议，支持持久连续，http协议不支持持久性连接。Http1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个</p>\n<h4>(2)WebSocket是什么样的协议，具体有什么优点？</h4>\n<ul>\n<li>HTTP的生命周期通过Request来界定，也就是Request一个Response，那么在Http1.0协议中，这次Http请求就结束了。在Http1.1中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个Http连接中，可以发送多个Request，接收多个Response。但是必须记住，在Http中一个Request只能对应有一个Response，而且这个Response是被动的，不能主动发起。</li>\n<li>WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。</li>\n</ul>\n<p>基本请求如下：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="GET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\nOrigin: http://example.com\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs http"><code><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> HTTP/1.1\n<span class="hljs-attribute">Host</span>: server.example.com\n<span class="hljs-attribute">Upgrade</span>: websocket\n<span class="hljs-attribute">Connection</span>: Upgrade\n<span class="hljs-attribute">Sec-WebSocket-Key</span>: x3JJHMbDL1EzLkh9GBhXDw==\n<span class="hljs-attribute">Sec-WebSocket-Protocol</span>: chat, superchat\n<span class="hljs-attribute">Sec-WebSocket-Version</span>: 13\n<span class="hljs-attribute">Origin</span>: http://example.com\n</code></pre>\n<p>多了下面2个属性：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Upgrade:webSocket\nConnection:Upgrade\n告诉服务器发送的是websocket\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs avrasm"><code><span class="hljs-symbol">Upgrade:</span>webSocket\n<span class="hljs-symbol">Connection:</span>Upgrade\n告诉服务器发送的是websocket\n<span class="hljs-keyword">Sec</span>-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\n<span class="hljs-keyword">Sec</span>-WebSocket-Protocol: chat, superchat\n<span class="hljs-keyword">Sec</span>-WebSocket-Version: <span class="hljs-number">13</span>\n</code></pre>\n<h3 id="articleHeader34">5.HTTP请求的方式，HEAD方式</h3>\n<ul>\n<li>head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头</li>\n<li>options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。</li>\n</ul>\n<h3 id="articleHeader35">6.一个图片url访问后直接下载怎样实现？</h3>\n<p>请求的返回头里面，用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为的参数。</p>\n<p>下载的情况下：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  1. x-oss-object-type:\n         Normal\n  2. x-oss-request-id:\n         598D5ED34F29D01FE2925F41\n  3. x-oss-storage-class:\n         Standard\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs kotlin"><code>  <span class="hljs-number">1.</span> x-oss-<span class="hljs-keyword">object</span>-type:\n         Normal\n  <span class="hljs-number">2.</span> x-oss-request-id:\n         <span class="hljs-number">598</span>D5ED34F29D01FE2925F41\n  <span class="hljs-number">3.</span> x-oss-storage-<span class="hljs-class"><span class="hljs-keyword">class</span>:\n         <span class="hljs-type">Standard</span></span>\n</code></pre>\n<h3 id="articleHeader36">7.web Quality （无障碍）</h3>\n<p>能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。<br>残障人士指的是那些带有残疾或者身体不健康的用户。</p>\n<p>使用alt属性：</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<img src=&quot;person.jpg&quot;  alt=&quot;this is a person&quot;/>\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs stylus"><code>&lt;<span class="hljs-selector-tag">img</span> src=<span class="hljs-string">"person.jpg"</span>  alt=<span class="hljs-string">"this is a person"</span>/&gt;\n</code></pre>\n<p>有时候浏览器会无法显示图像。具体的原因有：</p>\n<ul>\n<li>用户关闭了图像显示</li>\n<li>浏览器是不支持图形显示的迷你浏览器</li>\n<li>浏览器是语音浏览器（供盲人和弱视人群使用）</li>\n</ul>\n<p>如果您使用了 alt 属性，那么浏览器至少可以显示或读出有关图像的描述。</p>\n<h3 id="articleHeader37">8.几个很实用的BOM属性对象方法?</h3>\n<p>什么是Bom? Bom是浏览器对象。有哪些常用的Bom属性呢？</p>\n<h4>(1)location对象</h4>\n<p>location.href-- 返回或设置当前文档的URL<br>location.search -- 返回URL中的查询字符串部分。例如 <a href="http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu" rel="nofollow noreferrer" target="_blank">http://www.dreamdu.com/dreamd...</a> 返回包括(?)后面的内容?id=5&amp;name=dreamdu<br>location.hash -- 返回URL#后面的内容，如果没有#，返回空<br>location.host -- 返回URL中的域名部分，例如www.dreamdu.com<br>location.hostname -- 返回URL中的主域名部分，例如dreamdu.com<br>location.pathname -- 返回URL的域名后的部分。例如 <a href="http://www.dreamdu.com/xhtml/" rel="nofollow noreferrer" target="_blank">http://www.dreamdu.com/xhtml/</a> 返回/xhtml/<br>location.port -- 返回URL中的端口部分。例如 <a href="http://www.dreamdu.com" rel="nofollow noreferrer" target="_blank">http://www.dreamdu.com</a>:8080/xhtml/ 返回8080<br>location.protocol -- 返回URL中的协议部分。例如 <a href="http://www.dreamdu.com" rel="nofollow noreferrer" target="_blank">http://www.dreamdu.com</a>:8080/xhtml/ 返回(//)前面的内容http:<br>location.assign -- 设置当前文档的URL<br>location.replace() -- 设置当前文档的URL，并且在history对象的地址列表中移除这个URL location.replace(url);<br>location.reload() -- 重载当前页面</p>\n<h4>(2)history对象</h4>\n<p>history.go() -- 前进或后退指定的页面数 history.go(num);<br>history.back() -- 后退一页<br>history.forward() -- 前进一页</p>\n<h4>(3)Navigator对象</h4>\n<p>navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)<br>navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie</p>\n<h3 id="articleHeader38">9.HTML5  drag api</h3>\n<ul>\n<li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。</li>\n<li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li>\n<li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li>\n<li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li>\n<li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li>\n<li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li>\n<li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</li>\n</ul>\n<h3 id="articleHeader39">10.http2.0</h3>\n<p>首先补充一下，http和https的区别，相比于http,https是基于ssl加密的http协议<br>简要概括：http2.0是基于1999年发布的http1.0之后的首次更新。</p>\n<ul>\n<li>提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0）</li>\n<li>允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</li>\n<li>二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</li>\n<li>首部压缩</li>\n<li>服务器端推送</li>\n</ul>\n<h3 id="articleHeader40">11.补充400和401、403状态码</h3>\n<h4>(1)400状态码：请求无效</h4>\n<p>产生原因：</p>\n<ul>\n<li>前端提交数据的字段名称和字段类型与后台的实体没有保持一致</li>\n<li>前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。</li>\n</ul>\n<p>解决方法：</p>\n<ul>\n<li>对照字段的名称，保持一致性</li>\n<li>将obj对象通过JSON.stringify实现序列化</li>\n</ul>\n<h4>(2)401状态码：当前请求需要用户验证</h4>\n<h4>(3)403状态码：服务器已经得到请求，但是拒绝执行</h4>\n<h3 id="articleHeader41">12.fetch发送2次请求的原因</h3>\n<p><strong><em>fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？</em></strong></p>\n<p>原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。</p>\n<h3 id="articleHeader42">13.Cookie、sessionStorage、localStorage的区别</h3>\n<p>共同点：都是保存在浏览器端，并且是同源的</p>\n<ul>\n<li>Cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）</li>\n<li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）</li>\n<li>localStorage：localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</li>\n</ul>\n<p>补充说明一下cookie的作用：</p>\n<ul>\n<li>保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。</li>\n<li>跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便</li>\n<li>定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</li>\n</ul>\n<h3 id="articleHeader43">14.web worker</h3>\n<p>在HTML页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker是运行在后台的js，独立于其他脚本，不会影响页面你的性能。并且通过postMessage将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>\n<p>如何创建web worker：</p>\n<ul>\n<li>检测浏览器对于web worker的支持性</li>\n<li>创建web worker文件（js，回传函数等）</li>\n<li>创建web worker对象</li>\n</ul>\n<h3 id="articleHeader44">15.对HTML语义化标签的理解</h3>\n<p>HTML5语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如nav表示导航条，类似的还有article、header、footer等等标签。</p>\n<h3 id="articleHeader45">16.iframe是什么？有什么缺点？</h3>\n<p>定义：iframe元素会创建包含另一个文档的内联框架<br>提示：可以将提示文字放在&lt;iframe&gt;&lt;/iframe&gt;之间，来提示某些不支持iframe的浏览器</p>\n<p>缺点：</p>\n<ul>\n<li>会阻塞主页面的onload事件</li>\n<li>搜索引擎无法解读这种页面，不利于SEO</li>\n<li>iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。</li>\n</ul>\n<h3 id="articleHeader46">17.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3>\n<p>Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。</p>\n<ul>\n<li>严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。</li>\n<li>混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。</li>\n</ul>\n<h3 id="articleHeader47">18.Cookie如何防范XSS攻击</h3>\n<p>XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：</p>\n<ul>\n<li>httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。</li>\n<li>secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。</li>\n</ul>\n<p>结果应该是这样的：Set-Cookie=&lt;cookie-value&gt;.....</p>\n<h3 id="articleHeader48">19.Cookie和session的区别</h3>\n<p>HTTP是一个无状态协议，因此Cookie的最大的作用就是存储sessionId用来唯一标识用户</p>\n<h3 id="articleHeader49">20. 一句话概括RESTFUL</h3>\n<p><strong><em>就是用URL定位资源，用HTTP描述操作</em></strong></p>\n<h3 id="articleHeader50">21.讲讲viewport和移动端布局</h3>\n<p>可以参考我的这篇文章：</p>\n<p><a href="https://github.com/forthealllight/blog/issues/13" rel="nofollow noreferrer" target="_blank">响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh）</a></p>\n<h3 id="articleHeader51">22. click在ios上有300ms延迟，原因及如何解决？</h3>\n<h4>(1)粗暴型，禁用缩放</h4>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=" <meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;> \n\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs applescript"><code> &lt;meta <span class="hljs-built_in">name</span>=<span class="hljs-string">"viewport"</span> content=<span class="hljs-string">"width=device-width, user-scalable=no"</span>&gt; \n\n</code></pre>\n<h4>(2)利用FastClick，其原理是：</h4>\n<p>检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉</p>\n<h2 id="articleHeader52">四、css篇</h2>\n<h3 id="articleHeader53">1.css盒模型</h3>\n<p>简介：就是用来装页面上的元素的矩形区域。CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型。</p>\n<p>border-sizing(有3个值哦)：border-box,padding-box,content-box.</p>\n<ul><li>标准盒子模型：</li></ul>\n<p>&lt;img width="624" alt="2018-07-10 4 24 03" src="<a href="https://user-gold-cdn.xitu.io/2018/7/10/1648419a623a69db?w=1248&amp;amp" rel="nofollow noreferrer" target="_blank">https://user-gold-cdn.xitu.io...</a>;h=686&amp;f=png&amp;s=963248"&gt;</p>\n<ul><li>IE盒子模型：</li></ul>\n<p>&lt;img width="620" alt="2018-07-10 4 24 12" src="<a href="https://user-gold-cdn.xitu.io/2018/7/10/1648419a6d29fa5e?w=1240&amp;amp" rel="nofollow noreferrer" target="_blank">https://user-gold-cdn.xitu.io...</a>;h=656&amp;f=png&amp;s=1023920"&gt;</p>\n<p>区别：从图中我们可以看出，这两种盒子模型最主要的区别就是width的包含范围，在标准的盒子模型中，width指content部分的宽度，在IE盒子模型中，width表示content+padding+border这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异：</p>\n<p>标准盒子模型的盒子宽度：左右border+左右padding+width<br>IE盒子模型的盒子宽度：width</p>\n<p>在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box表示的是IE盒子模型</p>\n<p>最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右padding+width</p>\n<p>也很好理解性记忆，包含什么，width就从什么开始算起。</p>\n<h3 id="articleHeader54">2.画一条0.5px的线</h3>\n<ul>\n<li>采用meta viewport的方式<p>&lt;meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /&gt;</p>\n</li>\n<li>采用 border-image的方式</li>\n<li>采用transform: scale()的方式</li>\n</ul>\n<h3 id="articleHeader55">3.link标签和import标签的区别</h3>\n<ul>\n<li>link属于html标签，而@import是css提供的</li>\n<li>页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。</li>\n<li>link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。</li>\n<li>link方式样式的权重高于@import的。</li>\n</ul>\n<h3 id="articleHeader56">4.transition和animation的区别</h3>\n<p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。</p>\n<h3 id="articleHeader57">5.Flex布局</h3>\n<p>文章链接：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" rel="nofollow noreferrer" target="_blank">http://www.ruanyifeng.com/blo...</a>（语法篇）<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" rel="nofollow noreferrer" target="_blank">http://www.ruanyifeng.com/blo...</a>（实例篇）</p>\n<p>Flex是Flexible Box的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。<br>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>\n<p>简单的分为容器属性和元素属性<br>容器的属性：</p>\n<ul><li>flex-direction：决定主轴的方向（即子item的排列方法）</li></ul>\n<p>.box {<br>  flex-direction: row | row-reverse | column | column-reverse;<br>}</p>\n<ul><li>flex-wrap：决定换行规则</li></ul>\n<p>.box{<br>  flex-wrap: nowrap | wrap | wrap-reverse;<br>}</p>\n<ul><li>flex-flow：</li></ul>\n<p>.box {<br>  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;<br>}</p>\n<ul>\n<li>justify-content：对其方式，水平主轴对齐方式</li>\n<li>align-items：对齐方式，竖直轴线方向</li>\n</ul>\n<p>项目的属性（元素的属性）：</p>\n<ul>\n<li>order属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为0</li>\n<li>flex-grow属性：定义项目的放大比例，即使存在空间，也不会放大</li>\n<li>flex-shrink属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个item的flow-shrink为0，则为不缩小</li>\n<li>flex-basis属性：定义了在分配多余的空间，项目占据的空间。</li>\n<li>flex：是flex-grow和flex-shrink、flex-basis的简写，默认值为0 1 auto。</li>\n<li>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items，默认属性为auto，表示继承父元素的align-items</li>\n</ul>\n<p>比如说，用flex实现圣杯布局</p>\n<h3 id="articleHeader58">6.BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）</h3>\n<p>直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。</p>\n<ul>\n<li>BFC区域不会与float box重叠</li>\n<li>BFC是页面上的一个独立容器，子元素不会影响到外面</li>\n<li>计算BFC的高度时，浮动元素也会参与计算</li>\n</ul>\n<p>那些元素会生成BFC：</p>\n<ul>\n<li>根元素</li>\n<li>float不为none的元素</li>\n<li>position为fixed和absolute的元素</li>\n<li>display为inline-block、table-cell、table-caption，flex，inline-flex的元素</li>\n<li>overflow不为visible的元素</li>\n</ul>\n<h3 id="articleHeader59">7.垂直居中的方法</h3>\n<h3 id="articleHeader60">(1)margin:auto法</h3>\n<p>css:</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="div{\n  width: 400px;\n  height: 400px;\n  position: relative;\n  border: 1px solid #465468;\n }\n img{\n      position: absolute;\n      margin: auto;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n }\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs css"><code><span class="hljs-selector-tag">div</span>{\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;\n  <span class="hljs-attribute">position</span>: relative;\n  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#465468</span>;\n }\n <span class="hljs-selector-tag">img</span>{\n      <span class="hljs-attribute">position</span>: absolute;\n      <span class="hljs-attribute">margin</span>: auto;\n      <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;\n      <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;\n      <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;\n      <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;\n }\n</code></pre>\n<p>html:</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<div>\n <img src=&quot;mm.jpg&quot;>\n</div>\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"mm.jpg"</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n</code></pre>\n<p>定位为上下左右为0，margin：0可以实现脱离文档流的居中.</p>\n<h4>(2)margin负值法</h4>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=".container{\n  width: 500px;\n  height: 400px;\n  border: 2px solid #379;\n  position: relative;\n}\n.inner{\n  width: 480px;\n  height: 380px;\n  background-color: #746;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  margin-top: -190px; /*height的一半*/\n  margin-left: -240px; /*width的一半*/\n }\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs css"><code><span class="hljs-selector-class">.container</span>{\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;\n  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#379</span>;\n  <span class="hljs-attribute">position</span>: relative;\n}\n<span class="hljs-selector-class">.inner</span>{\n  <span class="hljs-attribute">width</span>: <span class="hljs-number">480px</span>;\n  <span class="hljs-attribute">height</span>: <span class="hljs-number">380px</span>;\n  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#746</span>;\n  <span class="hljs-attribute">position</span>: absolute;\n  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;\n  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;\n  <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">190px</span>; <span class="hljs-comment">/*height的一半*/</span>\n  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">240px</span>; <span class="hljs-comment">/*width的一半*/</span>\n }\n</code></pre>\n<p>补充：其实这里也可以将marin-top和margin-left负值替换成，<br>transform：translateX(-50%)和transform：translateY(-50%)</p>\n<h4>(3)table-cell（未脱离文档流的）</h4>\n<p>设置父元素的display:table-cell,并且vertical-align:middle，这样子元素可以实现垂直居中。</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="css:\ndiv{\n    width: 300px;\n    height: 300px;\n    border: 3px solid #555;\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\nimg{\n    vertical-align: middle;\n}\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs css"><code><span class="hljs-selector-tag">css</span>:\n<span class="hljs-selector-tag">div</span>{\n    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;\n    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;\n    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#555</span>;\n    <span class="hljs-attribute">display</span>: table-cell;\n    <span class="hljs-attribute">vertical-align</span>: middle;\n    <span class="hljs-attribute">text-align</span>: center;\n}\n<span class="hljs-selector-tag">img</span>{\n    <span class="hljs-attribute">vertical-align</span>: middle;\n}\n</code></pre>\n<h4>(4)利用flex</h4>\n<p>将父元素设置为display:flex，并且设置align-items:center;justify-content:center;</p>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="css:\n.container{\n      width: 300px;\n      height: 200px;\n      border: 3px solid #546461;\n      display: -webkit-flex;\n      display: flex;\n      -webkit-align-items: center;\n      align-items: center;\n      -webkit-justify-content: center;\n      justify-content: center;\n }\n .inner{\n      border: 3px solid #458761;\n      padding: 20px;\n }\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs css"><code><span class="hljs-selector-tag">css</span>:\n<span class="hljs-selector-class">.container</span>{\n      <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;\n      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;\n      <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#546461</span>;\n      <span class="hljs-attribute">display</span>: -webkit-flex;\n      <span class="hljs-attribute">display</span>: flex;\n      <span class="hljs-attribute">-webkit-align-items</span>: center;\n      <span class="hljs-attribute">align-items</span>: center;\n      <span class="hljs-attribute">-webkit-justify-content</span>: center;\n      <span class="hljs-attribute">justify-content</span>: center;\n }\n <span class="hljs-selector-class">.inner</span>{\n      <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#458761</span>;\n      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;\n }\n</code></pre>\n<h3 id="articleHeader61">8.关于js动画和css3动画的差异性</h3>\n<p>渲染线程分为main thread和compositor thread，如果css动画只改变transform和opacity，这时整个CSS动画得以在compositor trhead完成（而js动画则会在main thread执行，然后出发compositor thread进行下一步操作），特别注意的是如果改变transform和opacity是不会layout或者paint的。<br>区别：</p>\n<ul>\n<li>功能涵盖面，js比css大</li>\n<li>实现/重构难度不一，CSS3比js更加简单，性能跳优方向固定</li>\n<li>对帧速表现不好的低版本浏览器，css3可以做到自然降级</li>\n<li>css动画有天然事件支持</li>\n<li>css3有兼容性问题</li>\n</ul>\n<h3 id="articleHeader62">9.块元素和行元素</h3>\n<p>块元素：独占一行，并且有自动填满父元素，可以设置margin和pading以及高度和宽度<br>行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失<br>效。</p>\n<h3 id="articleHeader63">10.多行元素的文本省略号</h3>\n<div class="widget-codetool" style="display:none;">\n      <div class="widget-codetool--inner">\n      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>\n      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=" display: -webkit-box\n-webkit-box-orient:vertical\n-web-line-clamp:3\noverflow:hidden\n" title="" data-original-title="复制"></span>\n      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>\n      </div>\n      </div><pre class="hljs haml"><code> display: -webkit-box\n-<span class="ruby">webkit-box-<span class="hljs-symbol">orient:</span>vertical\n</span>-<span class="ruby">web-line-<span class="hljs-symbol">clamp:</span><span class="hljs-number">3</span>\n</span>overflow:hidden\n</code></pre>\n<h3 id="articleHeader64">11.visibility=hidden, opacity=0，display:none</h3>\n<p>opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</p>\n<h3 id="articleHeader65">12.双边距重叠问题（外边距折叠）</h3>\n<p>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠</p>\n<p>折叠的结果为：</p>\n<p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。<br>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。<br>两个外边距一正一负时，折叠结果是两者的相加的和。</p>\n\n                \n';s=(s=(s=(s=s.replace(/"{/g,"{")).replace(/{"/g,"{")).replace(/"}/g,"}")).replace(/}"/g,"}"),$("#raw").html(s)})</script></div><h1 id="版权声明">版权声明</h1><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000015591521">https://segmentfault.com/a/1190000015591521</a></p><h2 id="原文标题">原文标题</h2><p>总结了17年初到18年初百场前端面试的面试经验(含答案)</p><h2>本文链接：</h2><a href="https://alili.tech/archive/939106f7/" target="_blank">https://alili.tech/archive/939106f7/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({el:".blog-post-comments",app_id:"ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz",app_key:"hLhtmd4tT0qJbyO2SgQ8odya",placeholder:"说点什么?",avatar:"retro",notify:!0,verify:!0})</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/0xh05yxhj3yq/">Hugo博客百度SEO终极优化,熊掌号自动推送<aside class="dates">2018-11-17</aside></a></li><li><a href="/archive/lr0s1xtpgxs/">2019届校招前端面试题整理——HTML、CSS篇<aside class="dates">2018-11-17</aside></a></li><li><a href="/archive/xsxx36ma529/">Angular.js和Vue.js 深度对比<aside class="dates">2018-11-17</aside></a></li><li><a href="/archive/wfhn0n13w7/">ES6<aside class="dates">2018-11-17</aside></a></li><li><a href="/archive/lmtzdca0eps/">ES6指北【3】——5000字长文带你彻底搞懂ES6模块<aside class="dates">2018-11-17</aside></a></li><li><a href="/archive/2mx5rjtfr1v/">Flex实现九宫格<aside class="dates">2018-11-17</aside></a></li><li><a href="/archive/0xox5kszyufn/">JS 中的offset、scroll、client总结<aside class="dates">2018-11-17</aside></a></li><li><a href="/archive/zr267wmwtoe/">Set &amp; Map：新生的数据集合及其弱引用衍生<aside class="dates">2018-11-17</aside></a></li><li><a href="/archive/7axnyt5p2ju/">angular6.x中ngTemplateOutlet指令的使用<aside class="dates">2018-11-17</aside></a></li><li><a href="/archive/k1xtdpwyqls/">koa源码阅读[2]-koa-router<aside class="dates">2018-11-17</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2018 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){if("alili.tech"===location.host){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?05520debdbedd780ba345d83b7d5e6f4":"https://jspassport.ssl.qhimg.com/11.0.1.js?05520debdbedd780ba345d83b7d5e6f4";document.write('<script src="'+t+'" id="sozz"><\/script>')}}()</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>