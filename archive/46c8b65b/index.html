<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta itemprop="description" content="$(function(){ var html = &#34;\n\n \x3ch1\x3e\x3ca href=\x22#javascript-路由器\x22\x3e\x3c\/a\x3eJavaScript 路由器\x3c\/h1\x3e\n\x3cp\x3e构建单页面应用（SPA）有许多的框架\/库，但是我希望它们能少一些。我有一个解决方案，我想共享给大家。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRouter\x3c\/span\x3e \x3c\/span\x3e{\n \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.routes = []\n }\n\n handle(pattern, handler) {\n \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.routes.push({ pattern, handler })\n }\n\n exec(pathname) {\n \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e route \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.routes) {\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e route.pattern === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e) {\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (route.pattern === pathname) {\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e route.handler()\n }\n } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (route."><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 路由器"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content=""><meta property="og:site_name" content="Alili"><meta name="generator" content="Hugo 0.51"><title>JavaScript 路由器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/meslo-LG/styles.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error",function(e){var t=e.target;"img"==t.tagName.toLowerCase()&&(t.style.display="none")},!0)</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/46c8b65b/",
				"appid": "1613049289050283", 
				"title": "JavaScript 路由器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-11-16T07:21:32"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">Previous post</span> <span id="i-next" class="info" style="display:none">Next post</span> <span id="i-top" class="info" style="display:none">Back to top</span> <span id="i-share" class="info" style="display:none">Share post</span></span><br><div id="share" style="display:none"></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my4"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 路由器</h1><div class="meta"><div class="postdate"><time datetime="2018-10-21" itemprop="datePublished">2018-10-21</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div>| 575字 | 3 min<div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="row"><script>$(function(){var s='\n\n            <h1><a href="#javascript-路由器"></a>JavaScript 路由器</h1>\n<p>构建单页面应用（SPA）有许多的框架/库，但是我希望它们能少一些。我有一个解决方案，我想共享给大家。</p>\n<pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Router</span> </span>{\n    <span class="hljs-keyword">constructor</span>() {\n        <span class="hljs-keyword">this</span>.routes = []\n    }\n\n    handle(pattern, handler) {\n        <span class="hljs-keyword">this</span>.routes.push({ pattern, handler })\n    }\n\n    exec(pathname) {\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> route <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.routes) {\n            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> route.pattern === <span class="hljs-string">\'string\'</span>) {\n                <span class="hljs-keyword">if</span> (route.pattern === pathname) {\n                    <span class="hljs-keyword">return</span> route.handler()\n                }\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (route.pattern <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) {\n                <span class="hljs-keyword">const</span> result = pathname.match(route.pattern)\n                <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">null</span>) {\n                    <span class="hljs-keyword">const</span> params = result.slice(<span class="hljs-number">1</span>).map(<span class="hljs-built_in">decodeURIComponent</span>)\n                    <span class="hljs-keyword">return</span> route.handler(...params)\n                }\n            }\n        }\n    }\n}\n<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router()\n\nrouter.handle(<span class="hljs-string">\'/\'</span>, homePage)\nrouter.handle(<span class="hljs-regexp">/^\\/users\\/([^\\/]+)$/</span>, userPage)\nrouter.handle(<span class="hljs-regexp">/^\\//</span>, notFoundPage)\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">homePage</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'home page\'</span>\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userPage</span>(<span class="hljs-params">username</span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${username}</span>\'s page`</span>\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notFoundPage</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-string">\'not found page\'</span>\n}\n\n<span class="hljs-built_in">console</span>.log(router.exec(<span class="hljs-string">\'/\'</span>)) <span class="hljs-comment">// home page</span>\n<span class="hljs-built_in">console</span>.log(router.exec(<span class="hljs-string">\'/users/john\'</span>)) <span class="hljs-comment">// john\'s page</span>\n<span class="hljs-built_in">console</span>.log(router.exec(<span class="hljs-string">\'/foo\'</span>)) <span class="hljs-comment">// not found page</span>\n\n</code></pre><p>使用它你可以为一个 URL 模式添加处理程序。这个模式可能是一个简单的字符串或一个正则表达式。使用一个字符串将精确匹配它，但是如果使用一个正则表达式将允许你做一些更复杂的事情，比如，从用户页面上看到的 URL 中获取其中的一部分，或者匹配任何没有找到页面的 URL。</p>\n<p>我将详细解释这个 <code>exec</code> 方法 … 正如我前面说的，URL 模式既有可能是一个字符串，也有可能是一个正则表达式，因此，我首先来检查它是否是一个字符串。如果模式与给定的路径名相同，它返回运行处理程序。如果是一个正则表达式，我们与给定的路径名进行匹配。如果匹配成功，它将获取的参数传递给处理程序，并返回运行这个处理程序。</p>\n<h3><a href="#工作示例"></a>工作示例</h3>\n<p>那个例子正好记录到了控制台。我们尝试将它整合到一个页面，看看它是什么样的。</p>\n<pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Router Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"shortcut icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"data:,"</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/main.js"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/users/john_doe"</span>&gt;</span>Profile<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>\n <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>\n <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n\n</code></pre><p>这是 <code>index.html</code>。对于单页面应用程序来说，你必须在服务器侧做一个特别的工作，因为所有未知的路径都将返回这个 <code>index.html</code>。在开发时，我们使用了一个 npm 工具调用了 <a href="https://npm.im/serve">serve</a>。这个工具去提供静态内容。使用标志 <code>-s</code>/<code>--single</code>，你可以提供单页面应用程序。</p>\n<p>使用 <a href="https://nodejs.org/">Node.js</a> 和安装的 npm（它与 Node 一起安装），运行：</p>\n<pre><code class="hljs stylus">npm <span class="hljs-selector-tag">i</span> -g serve\nserve -s\n\n</code></pre><p>那个 HTML 文件将脚本 <code>main.js</code> 加载为一个模块。在我们渲染的相关页面中，它有一个简单的 <code>&lt;header&gt;</code> 和一个 <code>&lt;main&gt;</code> 元素。</p>\n<p>在 <code>main.js</code> 文件中：</p>\n<pre><code class="hljs dart"><span class="hljs-keyword">const</span> main = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">\'main\'</span>)\n<span class="hljs-keyword">const</span> result = router.exec(location.pathname)\nmain.innerHTML = result\n\n</code></pre><p>我们调用传递了当前路径名为参数的 <code>router.exec()</code>，然后将 <code>result</code> 设置为 <code>main</code> 元素的 HTML。</p>\n<p>如果你访问 <code>localhost</code> 并运行它，你将看到它能够正常工作，但不是预期中的来自一个单页面应用程序。当你点击链接时，单页面应用程序将不会被刷新。</p>\n<p>我们将在每个点击的链接的锚点上附加事件监听器，防止出现缺省行为，并做出正确的渲染。因为一个单页面应用程序是一个动态的东西，你预期要创建的锚点链接是动态的，因此要添加事件监听器，我使用的是一个叫 <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_delegation">事件委托</a> 的方法。</p>\n<p>我给整个文档附加一个点击事件监听器，然后去检查在锚点上（或内部）是否有点击事件。</p>\n<p>在 <code>Router</code> 类中，我有一个注册回调的方法，在我们每次点击一个链接或者一个 <code>popstate</code> 事件发生时，这个方法将被运行。每次你使用浏览器的返回或者前进按钮时，<code>popstate</code> 事件将被发送。</p>\n<p>为了方便其见，我们给回调传递与 <code>router.exec(location.pathname)</code> 相同的参数。</p>\n<pre><code class="hljs typescript"><span class="hljs-keyword">class</span> Router {\n    <span class="hljs-comment">// ...</span>\n    install(callback) {\n        <span class="hljs-keyword">const</span> execCallback = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n            callback(<span class="hljs-keyword">this</span>.exec(location.pathname))\n        }\n\n        <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">\'click\'</span>, <span class="hljs-function"><span class="hljs-params">ev</span> =&gt;</span> {\n            <span class="hljs-keyword">if</span> (ev.defaultPrevented\n                || ev.button !== <span class="hljs-number">0</span>\n                || ev.ctrlKey\n                || ev.shiftKey\n                || ev.altKey\n                || ev.metaKey) {\n                <span class="hljs-keyword">return</span>\n            }\n\n            <span class="hljs-keyword">const</span> a = ev.target.closest(<span class="hljs-string">\'a\'</span>)\n\n            <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">null</span>\n                || (a.target !== <span class="hljs-string">\'\'</span> &amp;&amp; a.target !== <span class="hljs-string">\'_self\'</span>)\n                || a.hostname !== location.hostname) {\n                <span class="hljs-keyword">return</span>\n            }\n\n            ev.preventDefault()\n\n            <span class="hljs-keyword">if</span> (a.href !== location.href) {\n                history.pushState(history.state, <span class="hljs-built_in">document</span>.title, a.href)\n                execCallback()\n            }\n        })\n\n        addEventListener(<span class="hljs-string">\'popstate\'</span>, execCallback)\n        execCallback()\n    }\n}\n\n</code></pre><p>对于链接的点击事件，除调用了回调之外，我们还使用 <code>history.pushState()</code> 去更新 URL。</p>\n<p>我们将前面的 <code>main</code> 元素中的渲染移动到 <code>install</code> 回调中。</p>\n<pre><code class="hljs javascript">router.install(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {\n main.innerHTML = result\n})\n\n</code></pre><h4><a href="#dom"></a>DOM</h4>\n<p>你传递给路由器的这些处理程序并不需要返回一个字符串。如果你需要更多的东西，你可以返回实际的 DOM。如：</p>\n<pre><code class="hljs coffeescript">const homeTmpl = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">\'template\'</span>)\nhomeTmpl.innerHTML = `<span class="javascript">\n &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"container"</span>&gt;\n <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>\n &lt;<span class="hljs-regexp">/div&gt;\n</span></span>`\n\nfunction homePage() {\n const page = homeTmpl.content.cloneNode(<span class="hljs-literal">true</span>)\n <span class="hljs-regexp">//</span> You can <span class="hljs-keyword">do</span> `<span class="javascript"><span class="hljs-regexp">page.querySelector()</span></span>` here...\n <span class="hljs-keyword">return</span> page\n}\n\n\n</code></pre><p>现在，在 <code>install</code> 回调中，你可以去检查 <code>result</code> 是一个 <code>string</code> 还是一个 <code>Node</code>。</p>\n<pre><code class="hljs javascript">router.install(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">\'string\'</span>) {\n        main.innerHTML = result\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> Node) {\n        main.innerHTML = <span class="hljs-string">\'\'</span>\n        main.appendChild(result)\n    }\n})\n\n</code></pre><p>这些就是基本的功能。我希望将它共享出来，因为我将在下篇文章中使用到这个路由器。</p>\n<p>我已经以一个 <a href="https://www.npmjs.com/package/@nicolasparada/router">npm 包</a> 的形式将它发布了。</p>\n<hr>\n<p>via: <a href="https://nicolasparada.netlify.com/posts/js-router/">https://nicolasparada.netlify.com/posts/js-router/</a></p>\n<p>作者：<a href="https://nicolasparada.netlify.com/">Nicolás Parada</a> 选题：<a href="https://github.com/lujun9972">lujun9972</a> 译者：<a href="https://github.com/qhwdw">qhwdw</a> 校对：<a href="https://github.com/wxy">wxy</a></p>\n<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>\n\n          \n';s=(s=(s=(s=s.replace(/"{/g,"{")).replace(/{"/g,"{")).replace(/"}/g,"}")).replace(/}"/g,"}"),$("#row").html(s)})</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/javascript-router">https://www.zcfy.cc/article/javascript-router</a> 原文标题: JavaScript 路由器 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， 原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/46c8b65b/" target="_blank">https://alili.tech/archive/46c8b65b/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({el:".blog-post-comments",app_id:"ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz",app_key:"hLhtmd4tT0qJbyO2SgQ8odya",placeholder:"说点什么?",avatar:"retro",notify:!0,verify:!0})</script></section></div><footer id="footer"><div class="footer-left">Hosted by <a href="https://pages.coding.me" style="font-weight:700" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a target="_blank" href="http://github.com/Fantasy9527" rel="external nofollow noopener noreferrer">Github</a></li></ul></nav></div><p>Copyright © 2018 <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></p></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/js/main.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var d="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?05520debdbedd780ba345d83b7d5e6f4":"https://jspassport.ssl.qhimg.com/11.0.1.js?05520debdbedd780ba345d83b7d5e6f4";document.write('<script src="'+d+'" id="sozz"><\/script>')}()</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>