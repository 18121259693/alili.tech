<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="$(function(){ var html = &#34;\n\n \x3ch2\x3e简介\x3c\/h2\x3e\n\x3cp\x3e这一章专门讨论了ECMA-262-5 规范的新概念之一 — 属性特性及其处理机制 — \x3cem\x3e属性描述符\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e当我们说“一个对象有一些属性”的时候，通常指的是\x3cem\x3e属性名\x3c"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="ECMA-262-5详述 第一章. 属性和属性描述符"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="$(function(){ var html = &#34;\n\n \x3ch2\x3e简介\x3c\/h2\x3e\n\x3cp\x3e这一章专门讨论了ECMA-262-5 规范的新概念之一 — 属性特性及其处理机制 — \x3cem\x3e属性描述符\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e当我们说“一个对象有一些属性”的时候，通常指的是\x3cem\x3e属性名\x3c"><meta property="og:site_name" content="Alili"><title>ECMA-262-5详述 第一章. 属性和属性描述符 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad()</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error",function(e){var t=e.target;"img"==t.tagName.toLowerCase()&&(t.style.display="none")},!0)</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/c7b3b162/",
				"appid": "1613049289050283", 
				"title": "ECMA-262-5详述 第一章. 属性和属性描述符 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2018-10-19T00:00:00"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/d1d5ae47/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" href="https://alili.tech/archive/9196ee0d/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">Previous post</span> <span id="i-next" class="info" style="display:none">Next post</span> <span id="i-top" class="info" style="display:none">Back to top</span> <span id="i-share" class="info" style="display:none">Share post</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&text=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&text=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&title=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&is_video=false&description=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&title=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&title=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&title=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc7b3b162%2f&title=ECMA-262-5%e8%af%a6%e8%bf%b0%20%e7%ac%ac%e4%b8%80%e7%ab%a0.%20%e5%b1%9e%e6%80%a7%e5%92%8c%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">ECMA-262-5详述 第一章. 属性和属性描述符</h1><div class="meta"><div class="postdate"><time datetime="2018-10-19" itemprop="datePublished">2018-10-19</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><script>$(function(){var s='\n\n            <h2>简介</h2>\n<p>这一章专门讨论了ECMA-262-5 规范的新概念之一 — 属性特性及其处理机制 — <em>属性描述符</em>。</p>\n<p>当我们说“一个对象有一些属性”的时候，通常指的是<em>属性名</em>和<em>属性值</em>之间的关联关系。但是，正如在ES3系列文章中分析的那样，一个属性不仅仅是一个<em>字符串名</em>，它还包括一系列特性—比如我们在ES3系列文章中已经讨论过的<code>{ReadOnly}</code>，<code>{DontEnum}</code>等。因此从这个观点来看，一个属性本身就是一个对象。</p>\n<p>为了更充分地理解本章节的内容，我建议阅读ECMA-262-3系列文章中的 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/">Chaper 7.2. OOP: ECMAScript implementation</a>。</p>\n<h2>新的API方法</h2>\n<p>为了处理属性及其特性，ES5标准化了一些新的API方法。稍后我们会详细讨论这些方法：</p>\n<pre><code class="hljs dart"><span class="hljs-comment">// better prototypal inheritance</span>\n<span class="hljs-built_in">Object</span>.create(parentProto, properties);\n<span class="hljs-comment">// getting the prototype</span>\n<span class="hljs-built_in">Object</span>.getPrototypeOf(o);\n<span class="hljs-comment">// define properties with specific attributes</span>\n<span class="hljs-built_in">Object</span>.defineProperty(o, propertyName, descriptor);\n<span class="hljs-built_in">Object</span>.defineProperties(o, properties);\n<span class="hljs-comment">// analyze properties</span>\n<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(o, propertyName);\n<span class="hljs-comment">// static (or "frozen") objects</span>\n<span class="hljs-built_in">Object</span>.freeze(o);\n<span class="hljs-built_in">Object</span>.isFrozen(o);\n<span class="hljs-comment">// non-extensible objects</span>\n<span class="hljs-built_in">Object</span>.preventExtensions(o);\n<span class="hljs-built_in">Object</span>.isExtensible(o);\n<span class="hljs-comment">// "sealed": non-extensible</span>\n<span class="hljs-comment">// and non-configurable objects</span>\n<span class="hljs-built_in">Object</span>.seal(o);\n<span class="hljs-built_in">Object</span>.isSealed(o);\n<span class="hljs-comment">// lists of properties</span>\n<span class="hljs-built_in">Object</span>.keys(o);\n<span class="hljs-built_in">Object</span>.getOwnPropertyNames(o);\n\n</code></pre><p>我们一个一个地讲。</p>\n<h2>属性类型</h2>\n<p>在ES3中，属性名和属性值是直接相关联的。虽然在一些ES3的实现版本中提供了扩展概念：<em>getters</em>（访问器函数）和<em>setters</em>（设置器函数），即与属性值间接相关的函数 。ECMA-262-5标准化了这个概念，现在总共有三种属性类型。</p>\n<p>并且你应该知道，属性可以是自己的，即直接由对象包含，也可以是继承的，即由原型链中的一个对象包含。</p>\n<p>属性包括命名属性和内部属性。命名属性是供ECMAScript代码使用的。内部属性则只能被实现层级的代码使用（虽然通过一些特殊的方法也能在ECMAScript代码中操作部分内部属性）。我们稍后会介绍。</p>\n<h3>属性特性</h3>\n<p>命名属性是通过一系列特性区分的。 在ES3系列文章中<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/#property-attributes">讨论</a> 过的<code>{ReadOnly}</code>，<code>{DontEnum}</code>等特性，在ES5中被重新命名了，表示ES3中相应特性的相反布尔状态。在ECMA-262-5中，数据属性和存取器属性有两个共同的特性：</p>\n<ul>\n<li><code>[[Enumerable]]</code>可枚举</li>\n</ul>\n<p>特性（对应ES3中<code>{DontEnum}</code>特性的相反布尔状态）的值如果是<code>true</code>，则可以被<code>for-in</code>枚举。</p>\n<ul>\n<li><code>[[Configurable]]</code>可配置</li>\n</ul>\n<p>特性（对应ES3中<code>{DontDelete}</code>特性的相反布尔状态）在<code>false</code>的状态下不允许删除属性，把属性设置成存取器属性或者改变<code>[[Value]]</code>以外的特性。</p>\n<p>需要注意的是，一旦<code>[[Configurable]]</code>特性被设置成<code>false</code>，就不能重新被设置成<code>true</code>。正如我们刚才说的，在 <code>[[Configurable]]</code>特性为<code>false</code>的情况下，不能改变<code>[[Value]]</code>以外的特性，当然也包括这里的<code>[[Configurable]]</code>。虽然可以改变<code>[[Writable]]</code>的值，但是只能把它从<code>true</code>改为<code>false</code>，反过来不行。也就是说如果一个属性是不可配置的，那么<code>[[Writable]]</code>不能从<code>false</code>变为<code>true</code>。</p>\n<p>稍后我们会讨论具体命名属性类型的其它特性。我们先详细介绍属性类型。</p>\n<h3>命名数据属性</h3>\n<p>这些属性我们已经在ES3中使用过了。这类属性包含一个名字（通常是字符串类型）以及名字和值之间的直接关联关系。</p>\n<p>比如：</p>\n<pre><code class="hljs fortran">// define <span class="hljs-keyword">in</span> the declarative <span class="hljs-keyword">form</span>\nvar foo = {\n  bar: <span class="hljs-number">10</span> // <span class="hljs-keyword">direct</span> <span class="hljs-keyword">Number</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">value</span>\n};\n// define <span class="hljs-keyword">in</span> the imperative <span class="hljs-keyword">form</span>,\n// also <span class="hljs-keyword">direct</span>, but <span class="hljs-function"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">value</span>, a <span class="hljs-string">"method"</span>\nfoo.baz = <span class="hljs-function"><span class="hljs-keyword">function</span></span> () {\n  <span class="hljs-keyword">return</span> this.bar;\n};\n\n</code></pre><p>和ES3一样，如果一个属性的值是一个函数，那么这个属性叫做方法。但是，不要混淆直接的函数值和间接的特殊的存取器函数。存取器函数会在后面介绍。</p>\n<p>除了命名属性的通用特性之外，数据属性还有下列特性：</p>\n<ul>\n<li><code>[[Value]]</code>值</li>\n</ul>\n<p>特性提供了一个值，这个值用于属性的读取操作。</p>\n<ul>\n<li><code>[[Writable]]</code>可写</li>\n</ul>\n<p>特性（对应ES3中<code>{ReadOnly}</code>特性的反向布尔状态），如果是<code>false</code>，会阻止内部方法<code>[[Put]]</code>修改属性的<code>[[Value]]</code>特性。</p>\n<p>带有默认值的命名数据属性的完整特性如下：</p>\n<pre><code class="hljs lua">var defaultDataPropertyAttributes = {\n  <span class="hljs-string">[[Value]]</span>: undefined,\n  <span class="hljs-string">[[Writable]]</span>: <span class="hljs-literal">false</span>,\n  <span class="hljs-string">[[Enumerable]]</span>: <span class="hljs-literal">false</span>,\n  <span class="hljs-string">[[Configurable]]</span>: <span class="hljs-literal">false</span>\n};\n\n</code></pre><p>所以，在特性的默认状态下，属性是常量：</p>\n<pre><code class="hljs lua">// define a global constant\n\nObject.defineProperty(this, <span class="hljs-string">"MAX_SIZE"</span>, {\n  value: <span class="hljs-number">100</span>\n});\nconsole.<span class="hljs-built_in">log</span>(MAX_SIZE);\n// <span class="hljs-number">100</span>\n\nMAX_SIZE = <span class="hljs-number">200</span>;\n// <span class="hljs-built_in">error</span> <span class="hljs-keyword">in</span> strict mode, <span class="hljs-string">[[Writable]]</span> = <span class="hljs-literal">false</span>,\ndelete MAX_SIZE;\n// <span class="hljs-built_in">error</span> <span class="hljs-keyword">in</span> strict mode, <span class="hljs-string">[[Configurable]]</span> = <span class="hljs-literal">false</span>\n\nconsole.<span class="hljs-built_in">log</span>(MAX_SIZE);\n// still <span class="hljs-number">100</span>\n\n</code></pre><p>不幸的是，在ES3中我们无法控制属性特性，这也导致了著名的内置原型扩大问题。由于ECMAScript对象可以动态修改的本质，所以可以非常方便地在原型上添加新的功能，然后使用它，就像对象本身就有这个功能一样。但是，因为无法控制ES3中的属性特性，比如<code>{DontEnum}</code>，在使用<code>for-in</code>的时候就会出现问题。</p>\n<pre><code class="hljs javascript"> <span class="hljs-comment">// ES3</span>\n\n<span class="hljs-built_in">Array</span>.prototype.sum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n  <span class="hljs-comment">// sum implementation</span>\n};\n<span class="hljs-keyword">var</span> a = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];\n<span class="hljs-comment">// works fine</span>\n<span class="hljs-built_in">console</span>.log(a.sum());\n<span class="hljs-comment">// 60</span>\n\n<span class="hljs-comment">// but because of for-in examines the </span>\n<span class="hljs-comment">// prototype chain as well, the new "sum"</span>\n<span class="hljs-comment">// property is also enumerated, because has</span>\n<span class="hljs-comment">// {DontEnum} == false</span>\n\n<span class="hljs-comment">// iterate over properties</span>\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> a) {\n  <span class="hljs-built_in">console</span>.log(k);\n<span class="hljs-comment">// 0, 1, 2, sum</span>\n}\n\n</code></pre><p>ES5提供了特殊的元方法来操作属性特性：</p>\n<pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Array</span>.prototype, <span class="hljs-string">"sum"</span>, {\n\n  <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arraySum</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-comment">//  sum implementation</span>\n  },\n\n  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>\n\n});\n<span class="hljs-comment">// now with using the same example this "sum"</span>\n<span class="hljs-comment">// is no longer enumerable</span>\n\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> a) {\n  <span class="hljs-built_in">console</span>.log(k);\n<span class="hljs-comment">// 0, 1, 2</span>\n}\n\n</code></pre><p>在上面的例子中，我们人为明确地设置了<code>enumerable</code>特性。然而，正如我们上面说过的，所有特性的默认状态是<code>false</code>，所以我们可以省略明确的<code>false</code>设置：</p>\n<p>并且一个简单的赋值操作对应所有特性的<em>相反默认</em>状态（正如在ES3中的一样）：</p>\n<pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">simple</span> <span class="hljs-string">assignment</span> <span class="hljs-string">(if</span> <span class="hljs-string">we</span> <span class="hljs-string">create</span> <span class="hljs-string">a</span> <span class="hljs-string">new</span> <span class="hljs-string">property)</span>\n<span class="hljs-string">foo.bar</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">;</span>\n<span class="hljs-string">//</span> <span class="hljs-string">the</span> <span class="hljs-string">same</span> <span class="hljs-string">as</span>\n<span class="hljs-string">Object.defineProperty(foo,</span> <span class="hljs-string">"bar"</span><span class="hljs-string">,</span> <span class="hljs-string">{</span>\n<span class="hljs-attr">  value:</span> <span class="hljs-number">10</span><span class="hljs-string">,</span>\n<span class="hljs-attr">  writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>\n<span class="hljs-attr">  enumerable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>\n<span class="hljs-attr">  configurable:</span> <span class="hljs-literal">true</span>\n<span class="hljs-string">});</span>\n\n\n</code></pre><p>可以发现，元方法<code>Object.defineProperty</code>不仅可以用来新建对象属性，还可以用来修改对象属性。另外，这个方法返回更新后的对象，所以我们可以使用这个方法同时把新创建的对象绑定到想要的变量名上。</p>\n<pre><code class="hljs sql">// <span class="hljs-keyword">create</span> <span class="hljs-string">"foo"</span>\n<span class="hljs-keyword">object</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">define</span> <span class="hljs-string">"bar"</span>\nproperty\n<span class="hljs-keyword">var</span> foo = Object.defineProperty({}, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-keyword">value</span>: <span class="hljs-number">10</span>,\n  enumerable: <span class="hljs-literal">true</span>\n});\n// <span class="hljs-keyword">alter</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">and</span> enumerable <span class="hljs-keyword">attribute</span>\nObject.defineProperty(foo, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-keyword">value</span>: <span class="hljs-number">20</span>,\n  enumerable: <span class="hljs-literal">false</span>\n});\nconsole.log(foo.bar);\n// 20\n\n</code></pre><p>有两个获取对象自身属性数组的元方法： <code>Object.keys</code>，只返回可枚举属性，和<code>Object.getOwnPropertyNames</code>，可枚举和不可枚举属性都返回：</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = {<span class="hljs-attr">bar</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">20</span>};\n<span class="hljs-built_in">Object</span>.defineProperty(foo, <span class="hljs-string">"x"</span>, {\n  <span class="hljs-attr">value</span>: <span class="hljs-number">30</span>,\n  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>\n});\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(foo));\n<span class="hljs-comment">// ["bar", "baz"]</span>\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyNames(foo));\n<span class="hljs-comment">// ["bar", "baz", "x"]</span>\n\n</code></pre><h3>命名存取器属性</h3>\n<p>命名存取器属性包括一个名字（同样只是一个字符串）和一到两个存取器函数：<code>getter</code>（访问器函数）和<code>setter</code>（设置器函数）。</p>\n<p>存取器函数用于间接地设置或访问与属性名相关的值。</p>\n<p>正如上面提到的，ES3的一些实现版本已经有了这个概念。但是ES5把这种属性类型的定义官方的具体化了并且提供了稍微不同的语法，比如和SpiderMonkey的相应扩展相比。</p>\n<p>除了通用特性，存取器属性还有下面和访问器函数以及设置器函数相关的特性：</p>\n<ul>\n<li><code>[[Get]]</code>访问器</li>\n</ul>\n<p>特性是一个函数对象，当每次间接获取属性名对应的值的时候会被调用。不要把属性特性和对象的同名内部方法—通用获取属性值的方法—混淆。对于存取器属性来说，对象内部的<code>[[Get]]</code>方法会调用对象属性的<code>[[Get]]</code>特性。</p>\n<ul>\n<li><code>[[Set]]</code>设置器</li>\n</ul>\n<p>特性也是一个函数，它被用来给一个属性名对应的属性设置一个新值。这个特性会被对象的内部方法<code>[[Put]]</code>调用。</p>\n<p>需要注意的是，<code>[[Set]]</code>可以，但不是必须的，影响后续属性<code>[[Get]]</code>特性的返回值。换句话说，如果我们通过设置器函数把属性值设置为<code>10</code>，访问器函数完全可以返回不同的值，比如<code>20</code>，因为这种关联是间接的。</p>\n<p>带有默认值的命名存取器属性的完整特性如下：</p>\n<pre><code class="hljs lua">var defaultAccessorPropertyAttributes = {\n  <span class="hljs-string">[[Get]]</span>: undefined,\n  <span class="hljs-string">[[Set]]</span>: undefined,\n  <span class="hljs-string">[[Enumerable]]</span>: <span class="hljs-literal">false</span>,\n  <span class="hljs-string">[[Configurable]]</span>: <span class="hljs-literal">false</span>\n};\n\n</code></pre><p>如果 <code>[[Set]]</code>特性缺省，那么这个存取器属性是只读的，和数据属性中<code>[[Writable]]</code>特性的状态为<code>false</code>一样。</p>\n<p>存取器属性既可以通过上面已经提到的元方法<code>Object.defineProperty</code>定义：</p>\n<pre><code class="hljs markdown">var foo = {};\nObject.defineProperty(foo, "bar", {\n\n  get: function getBar() {\n<span class="hljs-code">    return 20;</span>\n},\n\n  set: function setBar(value) {\n<span class="hljs-code">    // setting implementation</span>\n  }\n\n});\nfoo.bar = 10;\n// calls foo.bar.[<span class="hljs-string">[Set</span>]](10)\n\n// independently always 20\nconsole.log(foo.bar);\n// calls foo.bar.[<span class="hljs-string">[Get</span>]]()\n\n</code></pre><p>也可以在对象初始化时使用声明式的形式定义：</p>\n<pre><code class="hljs cs"><span class="hljs-keyword">var</span> foo = {\n\n  <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">bar</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;\n},\n\n  <span class="hljs-function"><span class="hljs-keyword">set</span> <span class="hljs-title">bar</span> (<span class="hljs-params"><span class="hljs-keyword">value</span></span>) </span>{\n    console.log(<span class="hljs-keyword">value</span>);\n}\n\n};\nfoo.bar = <span class="hljs-number">100</span>;\nconsole.log(foo.bar);\n<span class="hljs-comment">// 20</span>\n\n</code></pre><p>同样需要注意和存取器属性的可配置特性相关的一个重要特点。正如在上面<code>[[Configurable]]</code>特性部分描述的那样，一旦<code>[[Configurable]]</code>被设置成<code>false</code>，那么这个属性的特性就不能再修改了（除了数据属性的<code>[[Value]]</code>特性）。下面的例子可能会让你很疑惑：</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">// configurable false by default</span>\n<span class="hljs-keyword">var</span> foo = <span class="hljs-built_in">Object</span>.defineProperty({}, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-string">"bar"</span>;\n}\n});\n<span class="hljs-comment">// trying to reconfigure the "bar"</span>\n<span class="hljs-comment">// property =&gt;</span>\nexception is thrown\n<span class="hljs-keyword">try</span> {\n  <span class="hljs-built_in">Object</span>.defineProperty(foo, <span class="hljs-string">"bar"</span>, {\n    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n      <span class="hljs-keyword">return</span> <span class="hljs-string">"baz"</span>\n}\n  });\n} <span class="hljs-keyword">catch</span> (e) {\n  <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">TypeError</span>) {\n    <span class="hljs-built_in">console</span>.log(foo.bar);\n<span class="hljs-comment">// still "bar"</span>\n}\n}\n\n</code></pre><p>当设置属性特性的值和原先一样时，不会产生异常。虽然，这个知识点在实际中并不重要，甚至可以说毫无用处，因为我们不会给特性设置同样的值：</p>\n<pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBar</span>(<span class="hljs-params"></span>) </span>{\n  <span class="hljs-keyword">return</span> <span class="hljs-string">"bar"</span>;\n}\n\n<span class="hljs-keyword">var</span> foo = <span class="hljs-built_in">Object</span>.defineProperty({}, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-keyword">get</span>: getBar\n});\n<span class="hljs-comment">// no exception even if configurable is false,</span>\n<span class="hljs-comment">// but practically such "re"-configuration is useless</span>\n<span class="hljs-built_in">Object</span>.defineProperty(foo, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-keyword">get</span>: getBar\n});\n\n\n</code></pre><p>正如我们上面提到的，即使<code>[[Configurable]]</code>特性是<code>false</code>的状态，数据属性的<code>[[Value]]</code>特性也可以被修改，当然前提是<code>[[Writable]]</code>特性是在为<code>true</code>的情况下。同样，对于不可配置属性来说，<code>[[Writable]]</code>可以由<code>true</code>变为<code>false</code>，但是不能由<code>false</code>变为<code>true</code>。</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-built_in">Object</span>.defineProperty({}, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-attr">value</span>: <span class="hljs-string">"bar"</span>,\n  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>\n});\n<span class="hljs-built_in">Object</span>.defineProperty(foo, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-attr">value</span>: <span class="hljs-string">"baz"</span>\n});\n<span class="hljs-built_in">console</span>.log(foo.bar);\n<span class="hljs-comment">// "baz"</span>\n<span class="hljs-comment">// change writable</span>\n<span class="hljs-built_in">Object</span>.defineProperty(foo, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-attr">value</span>: <span class="hljs-string">"qux"</span>,\n  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// changed from true to false, OK</span>\n});\n<span class="hljs-built_in">console</span>.log(foo.bar);\n<span class="hljs-comment">// "qux"</span>\n<span class="hljs-comment">// try to change writable again - back to true</span>\n<span class="hljs-built_in">Object</span>.defineProperty(foo, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-attr">value</span>: <span class="hljs-string">"qux"</span>,\n  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// ERROR</span>\n});\n\n\n</code></pre><p>当<code>[[Configuragle]]</code>特性是<code>false</code>的时候，属性类型不能在数据属性和存取器属性间转换。当<code>[[Configuragle]]</code>特性是<code>true</code>的时候，属性类型之间是可以相互转换的。因此，<code>[[Writable]]</code>特性的状态并不是很重要并且可以是<code>false</code>：</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">// writable false by default</span>\n<span class="hljs-keyword">var</span> foo = <span class="hljs-built_in">Object</span>.defineProperty({}, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-attr">value</span>: <span class="hljs-string">"bar"</span>,\n  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>\n});\n<span class="hljs-built_in">Object</span>.defineProperty(foo, <span class="hljs-string">"bar"</span>, {\n  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-string">"baz"</span>;\n}\n});\n<span class="hljs-built_in">console</span>.log(foo.bar);\n<span class="hljs-comment">// OK, "baz"</span>\n\n</code></pre><p>很明显，一个属性不能同时既是数据类型又是存取器类型。这也就意味着一个属性如果同时具有互斥的特性，那么就会抛出异常：</p>\n<pre><code class="hljs lua">// <span class="hljs-built_in">error</span>, <span class="hljs-string">"get"</span>\n<span class="hljs-keyword">and</span> <span class="hljs-string">"writable"</span>\nat the same <span class="hljs-built_in">time</span>\nvar foo = Object.defineProperty({}, <span class="hljs-string">"bar"</span>, {\n  get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> {\n    <span class="hljs-keyword">return</span> <span class="hljs-string">"baz"</span>;\n},\n  writable: <span class="hljs-literal">true</span>\n});\n// also <span class="hljs-built_in">error</span>: mutually exclusive  <span class="hljs-string">"value"</span>\n<span class="hljs-keyword">and</span> <span class="hljs-string">"set"</span>\nattributes\nvar baz = Object.defineProperty({}, <span class="hljs-string">"bar"</span>, {\n  value: <span class="hljs-string">"baz"</span>,\n  set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(v)</span></span> {}\n})\n\n</code></pre><p>让我们回忆一下，只有当我们需要封装使用了辅助数据的复杂计算时，为了简化属性的访问方式—就像一个简单的数据属性一样，使用访问器和设置器函数才更有意义。我们已经在专门的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/#encapsulation">封装</a>部分以属性<code>element.innerHTML</code>为例提到过：我们可以概括的说“现在html元素的内容如下”，但是在<code>innerHTML</code>属性的设置器函数里面会进行大量的计算和校验，然后引起DOM树的重建和用户界面的更新。</p>\n<p>对于不抽象的，使用存取器特性就没有必要了。比如：</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = {};\n<span class="hljs-built_in">Object</span>.defineProperty(foo, <span class="hljs-string">"bar"</span>, {\n\n  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBar</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.baz;\n},\n\n  <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setBar</span>(<span class="hljs-params">value</span>) </span>{\n    <span class="hljs-keyword">this</span>.baz = value;\n}\n});\nfoo.bar = <span class="hljs-number">10</span>;\n<span class="hljs-built_in">console</span>.log(foo.bar);\n<span class="hljs-comment">// 10</span>\n<span class="hljs-built_in">console</span>.log(foo.baz);\n<span class="hljs-comment">// 10</span>\n\n\n\n</code></pre><p>在上面的例子中，我们不仅给不抽象的属性定义了存取器函数，还在对象自身上创建了一个“baz”属性。在这个例子中一个简单的数据属性就足够了，同时也能提高性能。</p>\n<p>真正值得使用访问器函数的情况通常和用于封装辅助数据的抽象程度的增加有关。最简单的例子如下：</p>\n<pre><code class="hljs scilab">var foo = {};\n<span class="hljs-comment">// encapsulated context</span>\n(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>\n\n  <span class="hljs-comment">// some internal state</span>\n  var data = [];\nObject.defineProperty(foo, <span class="hljs-string">"bar"</span>, {\n\n    get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBar</span><span class="hljs-params">()</span> {</span>\n      <span class="hljs-keyword">return</span> <span class="hljs-string">"We have "</span>\n+ data.<span class="hljs-built_in">length</span> + <span class="hljs-string">"\nbars: "</span>\n+ data;\n},\n\n    set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setBar</span><span class="hljs-params">(value)</span> {</span>\n\n      <span class="hljs-comment">// call getter first</span>\n      console.<span class="hljs-built_in">log</span>(<span class="hljs-string">\'Alert from "</span>bar<span class="hljs-string">"\nsetter: \'</span>\n+ this.bar);\ndata = Array(value).join(<span class="hljs-string">"bar-"</span>).concat(<span class="hljs-string">"bar"</span>).split(<span class="hljs-string">"-"</span>);\n<span class="hljs-comment">// of course if needed we can update</span>\n      <span class="hljs-comment">// also some public property</span>\n      this.baz = <span class="hljs-string">\'updated from "</span>bar<span class="hljs-string">"\nsetter: \'</span>\n+ value;\n},\n\n    configurable: true,\n    enumerable: true\n\n  });\n})();\nfoo.baz = <span class="hljs-number">100</span>;\nconsole.<span class="hljs-built_in">log</span>(foo.baz);\n<span class="hljs-comment">// 100</span>\n\n<span class="hljs-comment">// first getter will be called inside the setter:</span>\n<span class="hljs-comment">// We have 0 bars:</span>\nfoo.bar = <span class="hljs-number">3</span>;\n<span class="hljs-comment">// getting</span>\nconsole.<span class="hljs-built_in">log</span>(foo.bar);\n<span class="hljs-comment">// We have 3 bars: bar, bar, bar</span>\nconsole.<span class="hljs-built_in">log</span>(foo.baz);\n<span class="hljs-comment">// updated from "bar"</span>\nsetter: <span class="hljs-number">3</span>\n\n</code></pre><p>当然上面的例子并没有实际意义，但是它说明了存取器函数的主要目的—把内部辅助数据封装起来。</p>\n<p>和存取器属性相关的另一个特点是给继承的存取器属性赋值。正如从ES3系列文章中了解的那样，继承数据属性只可用于读取操作，给一个数据属性赋值总是会在对象自身上新建一个属性：</p>\n<pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.x = <span class="hljs-number">10</span>;\n<span class="hljs-keyword">var</span> foo = {};\n<span class="hljs-comment">// read inherited property</span>\n<span class="hljs-built_in">console</span>.log(foo.x);\n<span class="hljs-comment">// 10</span>\n\n<span class="hljs-comment">// but with assignment</span>\n<span class="hljs-comment">// create always own property</span>\nfoo.x = <span class="hljs-number">20</span>;\n<span class="hljs-comment">// read own property</span>\n<span class="hljs-built_in">console</span>.log(foo.x);\n<span class="hljs-comment">// 20</span>\n<span class="hljs-built_in">console</span>.log(foo.hasOwnProperty(<span class="hljs-string">"x"</span>));\n<span class="hljs-comment">// true</span>\n\n</code></pre><p>和数据属性不同的是，继承的存取器属性也可用于对象属性的修改：</p>\n<pre><code class="hljs typescript"><span class="hljs-keyword">var</span> _x = <span class="hljs-number">10</span>;\n<span class="hljs-keyword">var</span> proto = {\n  <span class="hljs-keyword">get</span> x() {\n    <span class="hljs-keyword">return</span> _x;\n},\n  <span class="hljs-keyword">set</span> x(x) {\n    _x = x;\n}\n};\n<span class="hljs-built_in">console</span>.log(proto.hasOwnProperty(<span class="hljs-string">"x"</span>));\n<span class="hljs-comment">// true</span>\n\n<span class="hljs-built_in">console</span>.log(proto.x);\n<span class="hljs-comment">// 10</span>\n\nproto.x = <span class="hljs-number">20</span>;\n<span class="hljs-comment">// set own property</span>\n\n<span class="hljs-built_in">console</span>.log(proto.x);\n<span class="hljs-comment">// 20</span>\n\n<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Object</span>.create(proto);\n<span class="hljs-comment">// "a"</span>\ninherits <span class="hljs-keyword">from</span> <span class="hljs-string">"proto"</span>\n<span class="hljs-built_in">console</span>.log(a.x);\n<span class="hljs-comment">// 20, read inherited</span>\n\na.x = <span class="hljs-number">30</span>;\n<span class="hljs-comment">// set *inherited*, but not own</span>\n\n<span class="hljs-built_in">console</span>.log(a.x);\n<span class="hljs-comment">// 30</span>\n<span class="hljs-built_in">console</span>.log(proto.x);\n<span class="hljs-comment">// 30</span>\n<span class="hljs-built_in">console</span>.log(a.hasOwnProperty(<span class="hljs-string">"x"</span>));\n<span class="hljs-comment">//false</span>\n\n</code></pre><p>然而，如果我们在创建以<code>proto</code>为原型的对象<code>a</code>的时候，把<code>x</code> 设置成了<code>a</code>本身的属性，那么赋值当然也是设置的<code>a</code>本身的属性：</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Object</span>.create(proto, {\n  <span class="hljs-attr">x</span>: {\n    <span class="hljs-attr">value</span>: <span class="hljs-number">100</span>,\n    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>\n  }\n});\n<span class="hljs-built_in">console</span>.log(a.x);\n<span class="hljs-comment">// 100, read own</span>\n\na.x = <span class="hljs-number">30</span>;\n<span class="hljs-comment">// set also own</span>\n\n<span class="hljs-built_in">console</span>.log(a.x);\n<span class="hljs-comment">// 30</span>\n<span class="hljs-built_in">console</span>.log(proto.x);\n<span class="hljs-comment">// 20</span>\n<span class="hljs-built_in">console</span>.log(a.hasOwnProperty(<span class="hljs-string">"x"</span>));\n<span class="hljs-comment">// true</span>\n\n</code></pre><p>通过元方法而不是赋值操作设置自身属性同样也能得到和上面相同的结果：</p>\n<pre><code class="hljs dart"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Object</span>.create(proto);\na.x = <span class="hljs-number">30</span>;\n<span class="hljs-comment">// set inherited</span>\n\n<span class="hljs-built_in">Object</span>.defineProperty(a, <span class="hljs-string">"x"</span>, {\n  value: <span class="hljs-number">100</span>,\n  writable: <span class="hljs-keyword">true</span>\n});\na.x = <span class="hljs-number">30</span>;\n<span class="hljs-comment">// set own</span>\n\n</code></pre><p>值得一提的是，当我们试图通过赋值操作覆盖不可写的继承属性时，无论数据属性还是存取器属性，严格模式下都会报错。然而，如果不是通过赋值操作，而是通过<code>Object.defineProperty</code>方法，就不会报错：</p>\n<pre><code class="hljs javascript"><span class="hljs-meta">"use strict"</span>;\n<span class="hljs-keyword">var</span> foo = <span class="hljs-built_in">Object</span>.defineProperty({}, <span class="hljs-string">"x"</span>, {\n  <span class="hljs-attr">value</span>: <span class="hljs-number">10</span>,\n  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>\n});\n<span class="hljs-comment">// "bar"</span>\ninherits <span class="hljs-keyword">from</span> <span class="hljs-string">"foo"</span>\n<span class="hljs-keyword">var</span> bar = <span class="hljs-built_in">Object</span>.create(foo);\n<span class="hljs-built_in">console</span>.log(bar.x);\n<span class="hljs-comment">// 10, inherited</span>\n\n<span class="hljs-comment">// try to shadow "x"</span>\nproperty\n<span class="hljs-comment">// and get an error in strict</span>\n<span class="hljs-comment">// mode, or just silent failure</span>\n<span class="hljs-comment">// in non-strict ES5 or ES3</span>\n\nbar.x = <span class="hljs-number">20</span>;\n<span class="hljs-comment">// TypeError</span>\n\n<span class="hljs-built_in">console</span>.log(bar.x);\n<span class="hljs-comment">// still 10, if non-strict mode</span>\n\n<span class="hljs-comment">// however shadowing works</span>\n<span class="hljs-comment">// if we use "Object.defineProperty"</span>\n<span class="hljs-built_in">Object</span>.defineProperty(bar, <span class="hljs-string">"x"</span>, { <span class="hljs-comment">// OK</span>\n  value: <span class="hljs-number">20</span>\n});\n<span class="hljs-built_in">console</span>.log(bar.x);\n<span class="hljs-comment">// and now 20</span>\n\n</code></pre><p>想了解严格模式可以查看ES5系列文章的<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/">Chapter 2. Strict Mode</a>。</p>\n<h3>内部属性</h3>\n<p>内部属性并不是ECMAScript语言的一部分。定义它们纯粹出于说明的目的。ES3系列文章中已经<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/#internal-properties-and-methods">讨论过</a>了。</p>\n<p>ES5新增了一些新的内部属性。你可以在ECMA-262-5规范的8.6.2. 章节看到这些内部属性的详细定义。因为在ES3系列文章中已经讨论过一些内部属性了，所以在这里只讨论一些新增的内部属性。</p>\n<p>比如，ES5中的对象可以被设置成密封的，冻结的或者不可扩展的，也就是静态的。这三种状态都和对象内部的<code>[[Extensible]]</code>属性相关。可以通过元方法进行操作：</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = {<span class="hljs-attr">bar</span>: <span class="hljs-number">10</span>};\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.isExtensible(foo));\n<span class="hljs-comment">// true</span>\n\n<span class="hljs-built_in">Object</span>.preventExtensions(foo);\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.isExtensible(foo));\n<span class="hljs-comment">// false</span>\n\nfoo.baz = <span class="hljs-number">20</span>;\n<span class="hljs-comment">// error in "strict"</span>\nmode\n<span class="hljs-built_in">console</span>.log(foo.baz);\n<span class="hljs-comment">// undefined</span>\n\n</code></pre><p>注意，一旦对象的内部属性<code>[[Extensible]]</code>被设置成<code>false</code>，就不能重新变为<code>true</code>了。</p>\n<p>但是不可扩展对象的一些属性仍然可以被移除。为了防止这种情况的发生，可以使用元方法<code>Object.seal</code>，该方法除了把<code>[[Extensible]]</code>设置成<code>false</code>之外，还会把对象的所有属性的<code>[[Configurable]]</code>特性设置成<code>false</code>：</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = {<span class="hljs-attr">bar</span>: <span class="hljs-number">10</span>};\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.isSealed(foo));\n<span class="hljs-comment">// false</span>\n\n<span class="hljs-built_in">Object</span>.seal(foo);\n<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.isSealed(foo));\n<span class="hljs-comment">// true</span>\n\n<span class="hljs-keyword">delete</span> foo.bar;\n<span class="hljs-comment">// error in strict mode</span>\n<span class="hljs-built_in">console</span>.log(foo.bar);\n<span class="hljs-comment">// 10</span>\n\n</code></pre><p>如果想要把对象完全变成静态的，也就是冻结对象，阻止已有属性的修改，可以使用相应的元方法<code>Object.freeze</code>。这个方法除了会修改上面提到的<code>[[Configurable]]</code>特性和内部属性<code>[[Extensible]]</code>之外，还会把数据属性的<code>[[Writable]]</code>特性改为<code>false</code>：</p>\n<pre><code class="hljs gauss">var foo = {<span class="hljs-built_in">bar</span>: <span class="hljs-number">10</span>};\n<span class="hljs-keyword">print</span>(Object.isFrozen(foo));\n<span class="hljs-comment">// false</span>\n\nObject.freeze(foo);\n<span class="hljs-keyword">print</span>(Object.isFrozen(foo));\n<span class="hljs-comment">// true</span>\n\n<span class="hljs-keyword">delete</span> foo.<span class="hljs-built_in">bar</span>;\n<span class="hljs-comment">// error in strict mode</span>\nfoo.<span class="hljs-built_in">bar</span> = <span class="hljs-number">20</span>;\n<span class="hljs-comment">// error in strict</span>\n\n<span class="hljs-keyword">print</span>(foo.<span class="hljs-built_in">bar</span>);\n<span class="hljs-comment">// 10</span>\n\n</code></pre><p>对象一旦被设置成密封或者冻结状态，就不能回到原先的状态了。</p>\n<p>和在ES3中一样，我们仍然可以使用<code>Object.prototype.toString</code>方法的默认返回值获取内部属性<code>[[Class]]</code>的值：</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> getClass = <span class="hljs-built_in">Object</span>.prototype.toString;\n<span class="hljs-built_in">console</span>.log(\n  getClass.call(<span class="hljs-number">1</span>), <span class="hljs-comment">// [object Number]</span>\n  getClass.call({}), <span class="hljs-comment">// [object Object]</span>\n  getClass.call([]), <span class="hljs-comment">// [object Array]</span>\n  getClass.call(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}) <span class="hljs-comment">// [object Function]</span>\n  <span class="hljs-comment">// etc.</span>\n);\n\n</code></pre><p>和ES3不同的是，ES5提供了获取内部属性<code>[[Prototype]]</code>的元方法<code>Object.getPrototypeOf</code>。在现行的规范版本中可以使用元方法<code>Object.create</code>创建一个以指定对象为原型的对象：</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">// create "foo"</span>\nobject <span class="hljs-keyword">with</span> two own\n<span class="hljs-comment">// properties "sum"</span>\nand <span class="hljs-string">"length"</span>\nand which has\n<span class="hljs-comment">// Array.prototype as its [[Prototype]] property</span>\n\n<span class="hljs-keyword">var</span> foo = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Array</span>.prototype, {\n  <span class="hljs-attr">sum</span>: {\n    <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arraySum</span>(<span class="hljs-params"></span>) </span>{\n      <span class="hljs-comment">// sum implementation</span>\n    }\n  },\n  <span class="hljs-comment">// non-enumerable but writable!</span>\n  <span class="hljs-comment">// else array methods won\'t work</span>\n  length: {\n    <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>,\n    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,\n    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>\n  }\n});\nfoo.push(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);\n<span class="hljs-built_in">console</span>.log(foo.length);\n<span class="hljs-comment">// 3</span>\n<span class="hljs-built_in">console</span>.log(foo.join(<span class="hljs-string">"-"</span>));\n<span class="hljs-string">"1-2-3"</span>\n<span class="hljs-comment">// neither "sum", nor "length"</span>\n<span class="hljs-comment">// are enumerable</span>\n\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> foo) {\n  <span class="hljs-built_in">console</span>.log(k);\n<span class="hljs-comment">// 0, 1, 2</span>\n}\n\n<span class="hljs-comment">// getting prototype of "foo"</span>\n<span class="hljs-keyword">var</span> fooPrototype = <span class="hljs-built_in">Object</span>.getPrototypeOf(foo);\n<span class="hljs-built_in">console</span>.log(fooPrototype === <span class="hljs-built_in">Array</span>.prototype);\n<span class="hljs-comment">// true</span>\n\n</code></pre><p>不幸的是，使用这种方式并不能创建一个以<code>Array.prototype</code>为原型，具有所有普通数组功能的“类”，包括重载处理<code>length</code>属性的内部方法<code>[[DefineOwnProperty]]</code>（参考15.4.5.1）。如上例子所述。</p>\n<pre><code class="hljs glsl">foo[<span class="hljs-number">5</span>] = <span class="hljs-number">10</span>;\nconsole.<span class="hljs-built_in">log</span>(foo.<span class="hljs-built_in">length</span>);\n<span class="hljs-comment">// still 3</span>\n\n</code></pre><p>继承<code>Array.prototype</code>，同时具有所有相关重载内部方法的唯一方式仍然是使用普通数组（也就是内部属性<code>[[Class]]</code>是<code>"Array"</code>的对象），然后使用不标准的<code>__proto__</code>属性。但是并不是所有的实现都提供了通过<code>__proto__</code>属性设置原型的功能：</p>\n<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = [];\nfoo.__proto__= {<span class="hljs-attr">bar</span>: <span class="hljs-number">10</span>};\nfoo.__proto__.__proto__= <span class="hljs-built_in">Array</span>.prototype;\n<span class="hljs-built_in">console</span>.log(foo <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);\n<span class="hljs-comment">// true</span>\n\n<span class="hljs-built_in">console</span>.log(foo.bar);\n<span class="hljs-comment">// 10</span>\n\n<span class="hljs-built_in">console</span>.log(foo.length);\n<span class="hljs-comment">// 0</span>\n\nfoo.push(<span class="hljs-number">20</span>);\nfoo[<span class="hljs-number">3</span>] = <span class="hljs-number">30</span>;\n<span class="hljs-built_in">console</span>.log(foo.length);\n<span class="hljs-comment">//4</span>\n\n<span class="hljs-built_in">console</span>.log(foo);\n<span class="hljs-comment">// 20,,,30</span>\n\nfoo.length = <span class="hljs-number">0</span>;\n<span class="hljs-built_in">console</span>.log(foo);\n<span class="hljs-comment">// empty array</span>\n\n</code></pre><p>不幸的是，和一些ES3实现版本中的非标准<code>__proto__</code>扩展不同，ES5没有提供设置对象原型的方式。</p>\n<h2>属性描述符和属性标识符类型</h2>\n<p>正如上面描述的，ES5允许操作属性特性。属性特性以及它们的值在ES5中被叫做属性描述符。</p>\n<p>和命名属性类型一样，描述符要么是数据描述符要么是存取器描述符。</p>\n<p>规范也定义了一个通用属性描述符，这个描述符要么是数据描述符要么是存取器描述符。一个完全填充的属性描述符要么是属性描述符要么是数据描述符并且具有相应类型的所有特性。但是那主要和实现层级相关。</p>\n<p>因为特性都有默认值，如果描述符是一个空对象，则会创建一个数据属性。显然，当描述符对象包含<code>writable</code>或者<code>value</code>属性的时候，会创建一个数据属性。当描述符对象有<code>get</code>或者<code>set</code>属性的时候，会创建一个存取器属性。可以使用元方法<code>Object.getOwnPropertyDescriptor</code>获取属性描述符：</p>\n<pre><code class="hljs qml"><span class="hljs-comment">// define several properties at once</span>\n<span class="hljs-built_in">Object</span>.defineProperties(foo, {\n  <span class="hljs-attribute">bar</span>: {}, <span class="hljs-comment">// "empty"</span>\ndescriptor,\n  <span class="hljs-attribute">baz</span>: {<span class="hljs-attribute">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}}\n});\n<span class="hljs-keyword">var</span> barProperty = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(foo, <span class="hljs-string">"bar"</span>);\n<span class="hljs-keyword">var</span> hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;\n<span class="hljs-built_in">console</span>.log(\n  barProperty.value, <span class="hljs-comment">// undefined</span>\n  hasOwn.call(barProperty, <span class="hljs-string">"value"</span>), <span class="hljs-comment">// true</span>\n\n  barProperty.get, <span class="hljs-comment">// undefined</span>\n  hasOwn.call(barProperty, <span class="hljs-string">"get"</span>), <span class="hljs-comment">// false</span>\n\n  barProperty.set, <span class="hljs-comment">// undefined</span>\n  hasOwn.call(barProperty, <span class="hljs-string">"set"</span>), <span class="hljs-comment">// false</span>\n);\n<span class="hljs-built_in">console</span>.log(foo.bar);\n<span class="hljs-comment">// undefined (correct), in Rhino 1.73 - null</span>\n<span class="hljs-built_in">console</span>.log(foo.nonExisting);\n<span class="hljs-comment">// undefined and in Rhino too</span>\n\n<span class="hljs-comment">// in contrast "baz"</span>\n<span class="hljs-keyword">property</span><span class="hljs-string"> is an accessor property</span>\n\n<span class="hljs-keyword">var</span> bazProperty = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(foo, <span class="hljs-string">"baz"</span>);\n<span class="hljs-built_in">console</span>.log(\n  bazProperty.value, <span class="hljs-comment">// undefined</span>\n  hasOwn.call(bazProperty, <span class="hljs-string">"value"</span>), <span class="hljs-comment">// false</span>\n\n  bazProperty.get, <span class="hljs-comment">// function</span>\n  hasOwn.call(bazProperty, <span class="hljs-string">"get"</span>), <span class="hljs-comment">// true</span>\n\n  bazProperty.set, <span class="hljs-comment">// undefined</span>\n  hasOwn.call(bazProperty, <span class="hljs-string">"set"</span>), <span class="hljs-comment">// false</span>\n);\n\n</code></pre><p>属性标识符类型用来关联属性名和属性描述符。所以，属性，也就是属性标识符类型的值，可以用形式<code>(name, descriptor)</code>描述：</p>\n<p>也就是：</p>\n<pre><code class="hljs yaml"><span class="hljs-string">foo.bar</span> <span class="hljs-string">=</span> <span class="hljs-number">10</span><span class="hljs-string">;</span>\n<span class="hljs-string">//</span> <span class="hljs-string">property</span> <span class="hljs-string">is</span> <span class="hljs-string">an</span> <span class="hljs-string">object</span> <span class="hljs-string">of</span>\n<span class="hljs-string">//</span> <span class="hljs-string">the</span> <span class="hljs-string">Property</span> <span class="hljs-string">Identifier</span> <span class="hljs-string">type</span>\n\n<span class="hljs-string">var</span> <span class="hljs-string">barProperty</span> <span class="hljs-string">=</span> <span class="hljs-string">{</span>\n<span class="hljs-attr">  name:</span> <span class="hljs-string">"bar"</span><span class="hljs-string">,</span>\n<span class="hljs-attr">  descriptor:</span> <span class="hljs-string">{</span>\n<span class="hljs-attr">    value:</span> <span class="hljs-number">10</span><span class="hljs-string">,</span>\n<span class="hljs-attr">    writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>\n<span class="hljs-attr">    enumerable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>\n<span class="hljs-attr">    configurable:</span> <span class="hljs-literal">true</span>\n  <span class="hljs-string">}</span>\n<span class="hljs-string">};</span>\n\n</code></pre><h2>总结</h2>\n<p>在这一章中，我们深入了解了ECMA-262-5规范的一个新概念。接下来的章节会专门介绍执行上下文的新细节，比如词法环境、环境记录等。一如既往，如果你有问题或补充，我们可以在评论中讨论。</p>\n<h2>扩展阅读</h2>\n<ul>\n<li><p><a href="http://es5.github.com/#x4.3">4.3 定义</a>；</p>\n</li>\n<li><p><a href="http://es5.github.com/#x8.6">8.6 对象类型</a>；</p>\n</li>\n<li><p><a href="http://es5.github.com/#x8.10">8.10 属性描述符和属性标识符规范类型</a>；</p>\n</li>\n<li><p><a href="http://es5.github.com/#x8.12">8.12 对象内部方法的算法</a>；</p>\n</li>\n<li><p><a href="http://es5.github.com/#x15.2.3">15.2.3 对象构造器的属性</a>。</p>\n</li>\n</ul>\n<p><strong>作者：</strong> Dmitry A. Soshnikov <strong>发布日期：</strong> 2010-04-28</p>\n\n          \n';s=(s=(s=(s=s.replace(/"{/g,"{")).replace(/{"/g,"{")).replace(/"}/g,"}")).replace(/}"/g,"}"),$("#raw").html(s)})</script></div><h1 id="版权声明">版权声明</h1><p>原文链接: <a href="https://www.zcfy.cc/article/ecma-262-5-in-detail-chapter-1-properties-and-property-descriptors">https://www.zcfy.cc/article/ecma-262-5-in-detail-chapter-1-properties-and-property-descriptors</a> 原文标题: ECMA-262-5详述 第一章. 属性和属性描述符 本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2>本文链接：</h2><a href="https://alili.tech/archive/c7b3b162/" target="_blank">https://alili.tech/archive/c7b3b162/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({el:".blog-post-comments",app_id:"ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz",app_key:"hLhtmd4tT0qJbyO2SgQ8odya",placeholder:"说点什么?",avatar:"retro",notify:!0,verify:!0})</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/7tgdk8pc84c/">16种水平居中垂直居中方法<aside class="dates">2018-11-22</aside></a></li><li><a href="/archive/mkkye92qi6/">30分钟从零开始教会你什么是PWA<aside class="dates">2018-11-22</aside></a></li><li><a href="/archive/9g6f68y2uot/">Angular2 http服务<aside class="dates">2018-11-22</aside></a></li><li><a href="/archive/eyi0lbtj75w/">Axios实现多个并行请求<aside class="dates">2018-11-22</aside></a></li><li><a href="/archive/gq7liv6z5pe/">JS 实现全屏预览 F11功能<aside class="dates">2018-11-22</aside></a></li><li><a href="/archive/48cgtocx8en/">JS自问自答『数据类型与类型检测』<aside class="dates">2018-11-22</aside></a></li><li><a href="/archive/tbccta00dp9/">JavaScript异步编程<aside class="dates">2018-11-22</aside></a></li><li><a href="/archive/ym27ocuynce/">React源码解读之setState<aside class="dates">2018-11-22</aside></a></li><li><a href="/archive/s7z6zvdctma/">TypeScript在node项目中的实践<aside class="dates">2018-11-22</aside></a></li><li><a href="/archive/h411n2vaqzj/">[翻译]React组件模式<aside class="dates">2018-11-22</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2018 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>!function(){if("alili.tech"===location.host){var t=document.createElement("script");window.location.protocol.split(":")[0];t.src="https://www.googletagmanager.com/gtag/js?id=UA-129382678-1";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(t,a),window.dataLayer=window.dataLayer||[],e("js",new Date),e("config","UA-129382678-1")}function e(){dataLayer.push(arguments)}}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>